
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model OtpVerification
 * 
 */
export type OtpVerification = $Result.DefaultSelection<Prisma.$OtpVerificationPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Manager
 * 
 */
export type Manager = $Result.DefaultSelection<Prisma.$ManagerPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model NotificationProvision
 * 
 */
export type NotificationProvision = $Result.DefaultSelection<Prisma.$NotificationProvisionPayload>
/**
 * Model NotificationPermissionEmployee
 * 
 */
export type NotificationPermissionEmployee = $Result.DefaultSelection<Prisma.$NotificationPermissionEmployeePayload>
/**
 * Model NotificationPermissionManager
 * 
 */
export type NotificationPermissionManager = $Result.DefaultSelection<Prisma.$NotificationPermissionManagerPayload>
/**
 * Model NotificationPermissionClient
 * 
 */
export type NotificationPermissionClient = $Result.DefaultSelection<Prisma.$NotificationPermissionClientPayload>
/**
 * Model NotificationPermissionSupporter
 * 
 */
export type NotificationPermissionSupporter = $Result.DefaultSelection<Prisma.$NotificationPermissionSupporterPayload>
/**
 * Model NotificationPermissionAdmin
 * 
 */
export type NotificationPermissionAdmin = $Result.DefaultSelection<Prisma.$NotificationPermissionAdminPayload>
/**
 * Model NotificationPermissionSuperAdmin
 * 
 */
export type NotificationPermissionSuperAdmin = $Result.DefaultSelection<Prisma.$NotificationPermissionSuperAdminPayload>
/**
 * Model Program
 * 
 */
export type Program = $Result.DefaultSelection<Prisma.$ProgramPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectEmployee
 * 
 */
export type ProjectEmployee = $Result.DefaultSelection<Prisma.$ProjectEmployeePayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Sheet
 * 
 */
export type Sheet = $Result.DefaultSelection<Prisma.$SheetPayload>
/**
 * Model SubmissionReturn
 * 
 */
export type SubmissionReturn = $Result.DefaultSelection<Prisma.$SubmissionReturnPayload>
/**
 * Model Submitted
 * 
 */
export type Submitted = $Result.DefaultSelection<Prisma.$SubmittedPayload>
/**
 * Model SuperAdmin
 * 
 */
export type SuperAdmin = $Result.DefaultSelection<Prisma.$SuperAdminPayload>
/**
 * Model Supporter
 * 
 */
export type Supporter = $Result.DefaultSelection<Prisma.$SupporterPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model Ticket
 * 
 */
export type Ticket = $Result.DefaultSelection<Prisma.$TicketPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model ReferredPerson
 * 
 */
export type ReferredPerson = $Result.DefaultSelection<Prisma.$ReferredPersonPayload>
/**
 * Model RequestToAddProjectMember
 * 
 */
export type RequestToAddProjectMember = $Result.DefaultSelection<Prisma.$RequestToAddProjectMemberPayload>
/**
 * Model Viewer
 * 
 */
export type Viewer = $Result.DefaultSelection<Prisma.$ViewerPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  VIEWER: 'VIEWER',
  EMPLOYEE: 'EMPLOYEE',
  SUPPORTER: 'SUPPORTER',
  MANAGER: 'MANAGER',
  ADMIN: 'ADMIN',
  CLIENT: 'CLIENT',
  SUPERADMIN: 'SUPERADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Language: {
  ENGLISH: 'ENGLISH'
};

export type Language = (typeof Language)[keyof typeof Language]


export const BillingCycle: {
  MONTHLY: 'MONTHLY',
  HALFYEARLY: 'HALFYEARLY',
  YEARLY: 'YEARLY',
  TWOYEARLY: 'TWOYEARLY',
  ENTERPRISE: 'ENTERPRISE'
};

export type BillingCycle = (typeof BillingCycle)[keyof typeof BillingCycle]


export const IndustryCategory: {
  REALESTATE: 'REALESTATE',
  FINANCE: 'FINANCE',
  RENEWABLE_ENERGY: 'RENEWABLE_ENERGY',
  TRAVEL_AGENCY: 'TRAVEL_AGENCY',
  BEAUTY_AND_WELLNESS: 'BEAUTY_AND_WELLNESS'
};

export type IndustryCategory = (typeof IndustryCategory)[keyof typeof IndustryCategory]


export const SupporterRole: {
  CALLATTENDANCE: 'CALLATTENDANCE',
  SUPPORTMANAGER: 'SUPPORTMANAGER',
  SALESOFFICER: 'SALESOFFICER',
  SYSTEMENGINEER: 'SYSTEMENGINEER'
};

export type SupporterRole = (typeof SupporterRole)[keyof typeof SupporterRole]


export const Priority: {
  HIGH: 'HIGH',
  MEDIUM: 'MEDIUM',
  LOW: 'LOW',
  NORMAL: 'NORMAL'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const ProjectCycle: {
  WEEKLY: 'WEEKLY',
  BI_WEEKLY: 'BI_WEEKLY',
  MONTHLY: 'MONTHLY'
};

export type ProjectCycle = (typeof ProjectCycle)[keyof typeof ProjectCycle]


export const ProjectStatus: {
  PENDING: 'PENDING',
  LIVE: 'LIVE',
  DRAFT: 'DRAFT',
  OVERDUE: 'OVERDUE',
  PROBLEM: 'PROBLEM',
  COMPLETED: 'COMPLETED'
};

export type ProjectStatus = (typeof ProjectStatus)[keyof typeof ProjectStatus]


export const TaskStatus: {
  INPROGRESS: 'INPROGRESS',
  COMPLETED: 'COMPLETED',
  OVERDUE: 'OVERDUE',
  NOSTART: 'NOSTART'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const TicketStatus: {
  OPEN: 'OPEN',
  UNASSIGNED: 'UNASSIGNED',
  IN_PROGRESS: 'IN_PROGRESS',
  SOLVED: 'SOLVED'
};

export type TicketStatus = (typeof TicketStatus)[keyof typeof TicketStatus]


export const IssueType: {
  LOGINFAILED: 'LOGINFAILED',
  SYSTEMERROR: 'SYSTEMERROR',
  OTHERPROBLEM: 'OTHERPROBLEM'
};

export type IssueType = (typeof IssueType)[keyof typeof IssueType]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  BANNED: 'BANNED',
  DELETED: 'DELETED',
  SUSPENDED: 'SUSPENDED'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const ActivityActionType: {
  ASSIGNEE_ADDED: 'ASSIGNEE_ADDED',
  ASSIGNEE_REMOVED: 'ASSIGNEE_REMOVED',
  FILE_ADDED: 'FILE_ADDED',
  FILE_REMOVED: 'FILE_REMOVED',
  LINK_ADDED: 'LINK_ADDED',
  LINK_REMOVED: 'LINK_REMOVED',
  DUE_DATE_CHANGED: 'DUE_DATE_CHANGED',
  PROGRESS_CHANGED: 'PROGRESS_CHANGED',
  SUBTASK_ADDED: 'SUBTASK_ADDED',
  SUBTASK_REMOVED: 'SUBTASK_REMOVED',
  STATUS_CHANGED: 'STATUS_CHANGED',
  PRIORITY_CHANGED: 'PRIORITY_CHANGED',
  COMMENT_ADDED: 'COMMENT_ADDED',
  PROJECT_CREATED: 'PROJECT_CREATED',
  PROJECT_UPDATED: 'PROJECT_UPDATED',
  TASK_CREATED: 'TASK_CREATED',
  TASK_COMPLETED: 'TASK_COMPLETED',
  GENERAL: 'GENERAL'
};

export type ActivityActionType = (typeof ActivityActionType)[keyof typeof ActivityActionType]


export const SubmittedStatus: {
  APPROVED: 'APPROVED',
  PENDING: 'PENDING',
  REJECTED: 'REJECTED'
};

export type SubmittedStatus = (typeof SubmittedStatus)[keyof typeof SubmittedStatus]


export const NotificationType: {
  NEW_EMPLOYEE_ASSIGNED: 'NEW_EMPLOYEE_ASSIGNED',
  NEW_MANAGER_ASSIGNED: 'NEW_MANAGER_ASSIGNED'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Language = $Enums.Language

export const Language: typeof $Enums.Language

export type BillingCycle = $Enums.BillingCycle

export const BillingCycle: typeof $Enums.BillingCycle

export type IndustryCategory = $Enums.IndustryCategory

export const IndustryCategory: typeof $Enums.IndustryCategory

export type SupporterRole = $Enums.SupporterRole

export const SupporterRole: typeof $Enums.SupporterRole

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type ProjectCycle = $Enums.ProjectCycle

export const ProjectCycle: typeof $Enums.ProjectCycle

export type ProjectStatus = $Enums.ProjectStatus

export const ProjectStatus: typeof $Enums.ProjectStatus

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type TicketStatus = $Enums.TicketStatus

export const TicketStatus: typeof $Enums.TicketStatus

export type IssueType = $Enums.IssueType

export const IssueType: typeof $Enums.IssueType

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type ActivityActionType = $Enums.ActivityActionType

export const ActivityActionType: typeof $Enums.ActivityActionType

export type SubmittedStatus = $Enums.SubmittedStatus

export const SubmittedStatus: typeof $Enums.SubmittedStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Activities
 * const activities = await prisma.activity.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Activities
   * const activities = await prisma.activity.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.otpVerification`: Exposes CRUD operations for the **OtpVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OtpVerifications
    * const otpVerifications = await prisma.otpVerification.findMany()
    * ```
    */
  get otpVerification(): Prisma.OtpVerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.manager`: Exposes CRUD operations for the **Manager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Managers
    * const managers = await prisma.manager.findMany()
    * ```
    */
  get manager(): Prisma.ManagerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationProvision`: Exposes CRUD operations for the **NotificationProvision** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationProvisions
    * const notificationProvisions = await prisma.notificationProvision.findMany()
    * ```
    */
  get notificationProvision(): Prisma.NotificationProvisionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationPermissionEmployee`: Exposes CRUD operations for the **NotificationPermissionEmployee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPermissionEmployees
    * const notificationPermissionEmployees = await prisma.notificationPermissionEmployee.findMany()
    * ```
    */
  get notificationPermissionEmployee(): Prisma.NotificationPermissionEmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationPermissionManager`: Exposes CRUD operations for the **NotificationPermissionManager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPermissionManagers
    * const notificationPermissionManagers = await prisma.notificationPermissionManager.findMany()
    * ```
    */
  get notificationPermissionManager(): Prisma.NotificationPermissionManagerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationPermissionClient`: Exposes CRUD operations for the **NotificationPermissionClient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPermissionClients
    * const notificationPermissionClients = await prisma.notificationPermissionClient.findMany()
    * ```
    */
  get notificationPermissionClient(): Prisma.NotificationPermissionClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationPermissionSupporter`: Exposes CRUD operations for the **NotificationPermissionSupporter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPermissionSupporters
    * const notificationPermissionSupporters = await prisma.notificationPermissionSupporter.findMany()
    * ```
    */
  get notificationPermissionSupporter(): Prisma.NotificationPermissionSupporterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationPermissionAdmin`: Exposes CRUD operations for the **NotificationPermissionAdmin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPermissionAdmins
    * const notificationPermissionAdmins = await prisma.notificationPermissionAdmin.findMany()
    * ```
    */
  get notificationPermissionAdmin(): Prisma.NotificationPermissionAdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationPermissionSuperAdmin`: Exposes CRUD operations for the **NotificationPermissionSuperAdmin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPermissionSuperAdmins
    * const notificationPermissionSuperAdmins = await prisma.notificationPermissionSuperAdmin.findMany()
    * ```
    */
  get notificationPermissionSuperAdmin(): Prisma.NotificationPermissionSuperAdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.program`: Exposes CRUD operations for the **Program** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Programs
    * const programs = await prisma.program.findMany()
    * ```
    */
  get program(): Prisma.ProgramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectEmployee`: Exposes CRUD operations for the **ProjectEmployee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectEmployees
    * const projectEmployees = await prisma.projectEmployee.findMany()
    * ```
    */
  get projectEmployee(): Prisma.ProjectEmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sheet`: Exposes CRUD operations for the **Sheet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sheets
    * const sheets = await prisma.sheet.findMany()
    * ```
    */
  get sheet(): Prisma.SheetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.submissionReturn`: Exposes CRUD operations for the **SubmissionReturn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubmissionReturns
    * const submissionReturns = await prisma.submissionReturn.findMany()
    * ```
    */
  get submissionReturn(): Prisma.SubmissionReturnDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.submitted`: Exposes CRUD operations for the **Submitted** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Submitteds
    * const submitteds = await prisma.submitted.findMany()
    * ```
    */
  get submitted(): Prisma.SubmittedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.superAdmin`: Exposes CRUD operations for the **SuperAdmin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SuperAdmins
    * const superAdmins = await prisma.superAdmin.findMany()
    * ```
    */
  get superAdmin(): Prisma.SuperAdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supporter`: Exposes CRUD operations for the **Supporter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Supporters
    * const supporters = await prisma.supporter.findMany()
    * ```
    */
  get supporter(): Prisma.SupporterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticket`: Exposes CRUD operations for the **Ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.TicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referredPerson`: Exposes CRUD operations for the **ReferredPerson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReferredPeople
    * const referredPeople = await prisma.referredPerson.findMany()
    * ```
    */
  get referredPerson(): Prisma.ReferredPersonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requestToAddProjectMember`: Exposes CRUD operations for the **RequestToAddProjectMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestToAddProjectMembers
    * const requestToAddProjectMembers = await prisma.requestToAddProjectMember.findMany()
    * ```
    */
  get requestToAddProjectMember(): Prisma.RequestToAddProjectMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.viewer`: Exposes CRUD operations for the **Viewer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Viewers
    * const viewers = await prisma.viewer.findMany()
    * ```
    */
  get viewer(): Prisma.ViewerDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Activity: 'Activity',
    Client: 'Client',
    Employee: 'Employee',
    OtpVerification: 'OtpVerification',
    Payment: 'Payment',
    Manager: 'Manager',
    Notification: 'Notification',
    NotificationProvision: 'NotificationProvision',
    NotificationPermissionEmployee: 'NotificationPermissionEmployee',
    NotificationPermissionManager: 'NotificationPermissionManager',
    NotificationPermissionClient: 'NotificationPermissionClient',
    NotificationPermissionSupporter: 'NotificationPermissionSupporter',
    NotificationPermissionAdmin: 'NotificationPermissionAdmin',
    NotificationPermissionSuperAdmin: 'NotificationPermissionSuperAdmin',
    Program: 'Program',
    Project: 'Project',
    ProjectEmployee: 'ProjectEmployee',
    Review: 'Review',
    Sheet: 'Sheet',
    SubmissionReturn: 'SubmissionReturn',
    Submitted: 'Submitted',
    SuperAdmin: 'SuperAdmin',
    Supporter: 'Supporter',
    Task: 'Task',
    Ticket: 'Ticket',
    User: 'User',
    Tag: 'Tag',
    ReferredPerson: 'ReferredPerson',
    RequestToAddProjectMember: 'RequestToAddProjectMember',
    Viewer: 'Viewer'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "activity" | "client" | "employee" | "otpVerification" | "payment" | "manager" | "notification" | "notificationProvision" | "notificationPermissionEmployee" | "notificationPermissionManager" | "notificationPermissionClient" | "notificationPermissionSupporter" | "notificationPermissionAdmin" | "notificationPermissionSuperAdmin" | "program" | "project" | "projectEmployee" | "review" | "sheet" | "submissionReturn" | "submitted" | "superAdmin" | "supporter" | "task" | "ticket" | "user" | "tag" | "referredPerson" | "requestToAddProjectMember" | "viewer"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      OtpVerification: {
        payload: Prisma.$OtpVerificationPayload<ExtArgs>
        fields: Prisma.OtpVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtpVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtpVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpVerificationPayload>
          }
          findFirst: {
            args: Prisma.OtpVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtpVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpVerificationPayload>
          }
          findMany: {
            args: Prisma.OtpVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpVerificationPayload>[]
          }
          create: {
            args: Prisma.OtpVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpVerificationPayload>
          }
          createMany: {
            args: Prisma.OtpVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OtpVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpVerificationPayload>[]
          }
          delete: {
            args: Prisma.OtpVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpVerificationPayload>
          }
          update: {
            args: Prisma.OtpVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpVerificationPayload>
          }
          deleteMany: {
            args: Prisma.OtpVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OtpVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OtpVerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpVerificationPayload>[]
          }
          upsert: {
            args: Prisma.OtpVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpVerificationPayload>
          }
          aggregate: {
            args: Prisma.OtpVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtpVerification>
          }
          groupBy: {
            args: Prisma.OtpVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtpVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OtpVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<OtpVerificationCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Manager: {
        payload: Prisma.$ManagerPayload<ExtArgs>
        fields: Prisma.ManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManagerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManagerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          findFirst: {
            args: Prisma.ManagerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManagerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          findMany: {
            args: Prisma.ManagerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>[]
          }
          create: {
            args: Prisma.ManagerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          createMany: {
            args: Prisma.ManagerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ManagerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>[]
          }
          delete: {
            args: Prisma.ManagerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          update: {
            args: Prisma.ManagerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          deleteMany: {
            args: Prisma.ManagerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ManagerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ManagerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>[]
          }
          upsert: {
            args: Prisma.ManagerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          aggregate: {
            args: Prisma.ManagerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManager>
          }
          groupBy: {
            args: Prisma.ManagerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManagerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ManagerCountArgs<ExtArgs>
            result: $Utils.Optional<ManagerCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      NotificationProvision: {
        payload: Prisma.$NotificationProvisionPayload<ExtArgs>
        fields: Prisma.NotificationProvisionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationProvisionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationProvisionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationProvisionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationProvisionPayload>
          }
          findFirst: {
            args: Prisma.NotificationProvisionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationProvisionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationProvisionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationProvisionPayload>
          }
          findMany: {
            args: Prisma.NotificationProvisionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationProvisionPayload>[]
          }
          create: {
            args: Prisma.NotificationProvisionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationProvisionPayload>
          }
          createMany: {
            args: Prisma.NotificationProvisionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationProvisionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationProvisionPayload>[]
          }
          delete: {
            args: Prisma.NotificationProvisionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationProvisionPayload>
          }
          update: {
            args: Prisma.NotificationProvisionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationProvisionPayload>
          }
          deleteMany: {
            args: Prisma.NotificationProvisionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationProvisionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationProvisionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationProvisionPayload>[]
          }
          upsert: {
            args: Prisma.NotificationProvisionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationProvisionPayload>
          }
          aggregate: {
            args: Prisma.NotificationProvisionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationProvision>
          }
          groupBy: {
            args: Prisma.NotificationProvisionGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationProvisionGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationProvisionCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationProvisionCountAggregateOutputType> | number
          }
        }
      }
      NotificationPermissionEmployee: {
        payload: Prisma.$NotificationPermissionEmployeePayload<ExtArgs>
        fields: Prisma.NotificationPermissionEmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPermissionEmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionEmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPermissionEmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionEmployeePayload>
          }
          findFirst: {
            args: Prisma.NotificationPermissionEmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionEmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPermissionEmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionEmployeePayload>
          }
          findMany: {
            args: Prisma.NotificationPermissionEmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionEmployeePayload>[]
          }
          create: {
            args: Prisma.NotificationPermissionEmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionEmployeePayload>
          }
          createMany: {
            args: Prisma.NotificationPermissionEmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationPermissionEmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionEmployeePayload>[]
          }
          delete: {
            args: Prisma.NotificationPermissionEmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionEmployeePayload>
          }
          update: {
            args: Prisma.NotificationPermissionEmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionEmployeePayload>
          }
          deleteMany: {
            args: Prisma.NotificationPermissionEmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPermissionEmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationPermissionEmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionEmployeePayload>[]
          }
          upsert: {
            args: Prisma.NotificationPermissionEmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionEmployeePayload>
          }
          aggregate: {
            args: Prisma.NotificationPermissionEmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPermissionEmployee>
          }
          groupBy: {
            args: Prisma.NotificationPermissionEmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPermissionEmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPermissionEmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPermissionEmployeeCountAggregateOutputType> | number
          }
        }
      }
      NotificationPermissionManager: {
        payload: Prisma.$NotificationPermissionManagerPayload<ExtArgs>
        fields: Prisma.NotificationPermissionManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPermissionManagerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPermissionManagerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionManagerPayload>
          }
          findFirst: {
            args: Prisma.NotificationPermissionManagerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPermissionManagerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionManagerPayload>
          }
          findMany: {
            args: Prisma.NotificationPermissionManagerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionManagerPayload>[]
          }
          create: {
            args: Prisma.NotificationPermissionManagerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionManagerPayload>
          }
          createMany: {
            args: Prisma.NotificationPermissionManagerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationPermissionManagerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionManagerPayload>[]
          }
          delete: {
            args: Prisma.NotificationPermissionManagerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionManagerPayload>
          }
          update: {
            args: Prisma.NotificationPermissionManagerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionManagerPayload>
          }
          deleteMany: {
            args: Prisma.NotificationPermissionManagerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPermissionManagerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationPermissionManagerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionManagerPayload>[]
          }
          upsert: {
            args: Prisma.NotificationPermissionManagerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionManagerPayload>
          }
          aggregate: {
            args: Prisma.NotificationPermissionManagerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPermissionManager>
          }
          groupBy: {
            args: Prisma.NotificationPermissionManagerGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPermissionManagerGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPermissionManagerCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPermissionManagerCountAggregateOutputType> | number
          }
        }
      }
      NotificationPermissionClient: {
        payload: Prisma.$NotificationPermissionClientPayload<ExtArgs>
        fields: Prisma.NotificationPermissionClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPermissionClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPermissionClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionClientPayload>
          }
          findFirst: {
            args: Prisma.NotificationPermissionClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPermissionClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionClientPayload>
          }
          findMany: {
            args: Prisma.NotificationPermissionClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionClientPayload>[]
          }
          create: {
            args: Prisma.NotificationPermissionClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionClientPayload>
          }
          createMany: {
            args: Prisma.NotificationPermissionClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationPermissionClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionClientPayload>[]
          }
          delete: {
            args: Prisma.NotificationPermissionClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionClientPayload>
          }
          update: {
            args: Prisma.NotificationPermissionClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionClientPayload>
          }
          deleteMany: {
            args: Prisma.NotificationPermissionClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPermissionClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationPermissionClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionClientPayload>[]
          }
          upsert: {
            args: Prisma.NotificationPermissionClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionClientPayload>
          }
          aggregate: {
            args: Prisma.NotificationPermissionClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPermissionClient>
          }
          groupBy: {
            args: Prisma.NotificationPermissionClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPermissionClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPermissionClientCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPermissionClientCountAggregateOutputType> | number
          }
        }
      }
      NotificationPermissionSupporter: {
        payload: Prisma.$NotificationPermissionSupporterPayload<ExtArgs>
        fields: Prisma.NotificationPermissionSupporterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPermissionSupporterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionSupporterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPermissionSupporterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionSupporterPayload>
          }
          findFirst: {
            args: Prisma.NotificationPermissionSupporterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionSupporterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPermissionSupporterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionSupporterPayload>
          }
          findMany: {
            args: Prisma.NotificationPermissionSupporterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionSupporterPayload>[]
          }
          create: {
            args: Prisma.NotificationPermissionSupporterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionSupporterPayload>
          }
          createMany: {
            args: Prisma.NotificationPermissionSupporterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationPermissionSupporterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionSupporterPayload>[]
          }
          delete: {
            args: Prisma.NotificationPermissionSupporterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionSupporterPayload>
          }
          update: {
            args: Prisma.NotificationPermissionSupporterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionSupporterPayload>
          }
          deleteMany: {
            args: Prisma.NotificationPermissionSupporterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPermissionSupporterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationPermissionSupporterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionSupporterPayload>[]
          }
          upsert: {
            args: Prisma.NotificationPermissionSupporterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionSupporterPayload>
          }
          aggregate: {
            args: Prisma.NotificationPermissionSupporterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPermissionSupporter>
          }
          groupBy: {
            args: Prisma.NotificationPermissionSupporterGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPermissionSupporterGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPermissionSupporterCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPermissionSupporterCountAggregateOutputType> | number
          }
        }
      }
      NotificationPermissionAdmin: {
        payload: Prisma.$NotificationPermissionAdminPayload<ExtArgs>
        fields: Prisma.NotificationPermissionAdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPermissionAdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionAdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPermissionAdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionAdminPayload>
          }
          findFirst: {
            args: Prisma.NotificationPermissionAdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionAdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPermissionAdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionAdminPayload>
          }
          findMany: {
            args: Prisma.NotificationPermissionAdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionAdminPayload>[]
          }
          create: {
            args: Prisma.NotificationPermissionAdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionAdminPayload>
          }
          createMany: {
            args: Prisma.NotificationPermissionAdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationPermissionAdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionAdminPayload>[]
          }
          delete: {
            args: Prisma.NotificationPermissionAdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionAdminPayload>
          }
          update: {
            args: Prisma.NotificationPermissionAdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionAdminPayload>
          }
          deleteMany: {
            args: Prisma.NotificationPermissionAdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPermissionAdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationPermissionAdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionAdminPayload>[]
          }
          upsert: {
            args: Prisma.NotificationPermissionAdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionAdminPayload>
          }
          aggregate: {
            args: Prisma.NotificationPermissionAdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPermissionAdmin>
          }
          groupBy: {
            args: Prisma.NotificationPermissionAdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPermissionAdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPermissionAdminCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPermissionAdminCountAggregateOutputType> | number
          }
        }
      }
      NotificationPermissionSuperAdmin: {
        payload: Prisma.$NotificationPermissionSuperAdminPayload<ExtArgs>
        fields: Prisma.NotificationPermissionSuperAdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPermissionSuperAdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionSuperAdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPermissionSuperAdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionSuperAdminPayload>
          }
          findFirst: {
            args: Prisma.NotificationPermissionSuperAdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionSuperAdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPermissionSuperAdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionSuperAdminPayload>
          }
          findMany: {
            args: Prisma.NotificationPermissionSuperAdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionSuperAdminPayload>[]
          }
          create: {
            args: Prisma.NotificationPermissionSuperAdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionSuperAdminPayload>
          }
          createMany: {
            args: Prisma.NotificationPermissionSuperAdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationPermissionSuperAdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionSuperAdminPayload>[]
          }
          delete: {
            args: Prisma.NotificationPermissionSuperAdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionSuperAdminPayload>
          }
          update: {
            args: Prisma.NotificationPermissionSuperAdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionSuperAdminPayload>
          }
          deleteMany: {
            args: Prisma.NotificationPermissionSuperAdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPermissionSuperAdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationPermissionSuperAdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionSuperAdminPayload>[]
          }
          upsert: {
            args: Prisma.NotificationPermissionSuperAdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPermissionSuperAdminPayload>
          }
          aggregate: {
            args: Prisma.NotificationPermissionSuperAdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPermissionSuperAdmin>
          }
          groupBy: {
            args: Prisma.NotificationPermissionSuperAdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPermissionSuperAdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPermissionSuperAdminCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPermissionSuperAdminCountAggregateOutputType> | number
          }
        }
      }
      Program: {
        payload: Prisma.$ProgramPayload<ExtArgs>
        fields: Prisma.ProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findFirst: {
            args: Prisma.ProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findMany: {
            args: Prisma.ProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          create: {
            args: Prisma.ProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          createMany: {
            args: Prisma.ProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          delete: {
            args: Prisma.ProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          update: {
            args: Prisma.ProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          deleteMany: {
            args: Prisma.ProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProgramUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          upsert: {
            args: Prisma.ProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          aggregate: {
            args: Prisma.ProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgram>
          }
          groupBy: {
            args: Prisma.ProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectEmployee: {
        payload: Prisma.$ProjectEmployeePayload<ExtArgs>
        fields: Prisma.ProjectEmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectEmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectEmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectEmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectEmployeePayload>
          }
          findFirst: {
            args: Prisma.ProjectEmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectEmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectEmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectEmployeePayload>
          }
          findMany: {
            args: Prisma.ProjectEmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectEmployeePayload>[]
          }
          create: {
            args: Prisma.ProjectEmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectEmployeePayload>
          }
          createMany: {
            args: Prisma.ProjectEmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectEmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectEmployeePayload>[]
          }
          delete: {
            args: Prisma.ProjectEmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectEmployeePayload>
          }
          update: {
            args: Prisma.ProjectEmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectEmployeePayload>
          }
          deleteMany: {
            args: Prisma.ProjectEmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectEmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectEmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectEmployeePayload>[]
          }
          upsert: {
            args: Prisma.ProjectEmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectEmployeePayload>
          }
          aggregate: {
            args: Prisma.ProjectEmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectEmployee>
          }
          groupBy: {
            args: Prisma.ProjectEmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectEmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectEmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectEmployeeCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Sheet: {
        payload: Prisma.$SheetPayload<ExtArgs>
        fields: Prisma.SheetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SheetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SheetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SheetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SheetPayload>
          }
          findFirst: {
            args: Prisma.SheetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SheetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SheetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SheetPayload>
          }
          findMany: {
            args: Prisma.SheetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SheetPayload>[]
          }
          create: {
            args: Prisma.SheetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SheetPayload>
          }
          createMany: {
            args: Prisma.SheetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SheetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SheetPayload>[]
          }
          delete: {
            args: Prisma.SheetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SheetPayload>
          }
          update: {
            args: Prisma.SheetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SheetPayload>
          }
          deleteMany: {
            args: Prisma.SheetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SheetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SheetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SheetPayload>[]
          }
          upsert: {
            args: Prisma.SheetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SheetPayload>
          }
          aggregate: {
            args: Prisma.SheetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSheet>
          }
          groupBy: {
            args: Prisma.SheetGroupByArgs<ExtArgs>
            result: $Utils.Optional<SheetGroupByOutputType>[]
          }
          count: {
            args: Prisma.SheetCountArgs<ExtArgs>
            result: $Utils.Optional<SheetCountAggregateOutputType> | number
          }
        }
      }
      SubmissionReturn: {
        payload: Prisma.$SubmissionReturnPayload<ExtArgs>
        fields: Prisma.SubmissionReturnFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubmissionReturnFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionReturnPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubmissionReturnFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionReturnPayload>
          }
          findFirst: {
            args: Prisma.SubmissionReturnFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionReturnPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubmissionReturnFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionReturnPayload>
          }
          findMany: {
            args: Prisma.SubmissionReturnFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionReturnPayload>[]
          }
          create: {
            args: Prisma.SubmissionReturnCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionReturnPayload>
          }
          createMany: {
            args: Prisma.SubmissionReturnCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubmissionReturnCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionReturnPayload>[]
          }
          delete: {
            args: Prisma.SubmissionReturnDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionReturnPayload>
          }
          update: {
            args: Prisma.SubmissionReturnUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionReturnPayload>
          }
          deleteMany: {
            args: Prisma.SubmissionReturnDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubmissionReturnUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubmissionReturnUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionReturnPayload>[]
          }
          upsert: {
            args: Prisma.SubmissionReturnUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionReturnPayload>
          }
          aggregate: {
            args: Prisma.SubmissionReturnAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubmissionReturn>
          }
          groupBy: {
            args: Prisma.SubmissionReturnGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubmissionReturnGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubmissionReturnCountArgs<ExtArgs>
            result: $Utils.Optional<SubmissionReturnCountAggregateOutputType> | number
          }
        }
      }
      Submitted: {
        payload: Prisma.$SubmittedPayload<ExtArgs>
        fields: Prisma.SubmittedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubmittedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmittedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubmittedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmittedPayload>
          }
          findFirst: {
            args: Prisma.SubmittedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmittedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubmittedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmittedPayload>
          }
          findMany: {
            args: Prisma.SubmittedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmittedPayload>[]
          }
          create: {
            args: Prisma.SubmittedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmittedPayload>
          }
          createMany: {
            args: Prisma.SubmittedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubmittedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmittedPayload>[]
          }
          delete: {
            args: Prisma.SubmittedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmittedPayload>
          }
          update: {
            args: Prisma.SubmittedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmittedPayload>
          }
          deleteMany: {
            args: Prisma.SubmittedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubmittedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubmittedUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmittedPayload>[]
          }
          upsert: {
            args: Prisma.SubmittedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmittedPayload>
          }
          aggregate: {
            args: Prisma.SubmittedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubmitted>
          }
          groupBy: {
            args: Prisma.SubmittedGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubmittedGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubmittedCountArgs<ExtArgs>
            result: $Utils.Optional<SubmittedCountAggregateOutputType> | number
          }
        }
      }
      SuperAdmin: {
        payload: Prisma.$SuperAdminPayload<ExtArgs>
        fields: Prisma.SuperAdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SuperAdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SuperAdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          findFirst: {
            args: Prisma.SuperAdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SuperAdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          findMany: {
            args: Prisma.SuperAdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>[]
          }
          create: {
            args: Prisma.SuperAdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          createMany: {
            args: Prisma.SuperAdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SuperAdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>[]
          }
          delete: {
            args: Prisma.SuperAdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          update: {
            args: Prisma.SuperAdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          deleteMany: {
            args: Prisma.SuperAdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SuperAdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SuperAdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>[]
          }
          upsert: {
            args: Prisma.SuperAdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          aggregate: {
            args: Prisma.SuperAdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuperAdmin>
          }
          groupBy: {
            args: Prisma.SuperAdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuperAdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.SuperAdminCountArgs<ExtArgs>
            result: $Utils.Optional<SuperAdminCountAggregateOutputType> | number
          }
        }
      }
      Supporter: {
        payload: Prisma.$SupporterPayload<ExtArgs>
        fields: Prisma.SupporterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupporterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupporterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupporterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupporterPayload>
          }
          findFirst: {
            args: Prisma.SupporterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupporterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupporterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupporterPayload>
          }
          findMany: {
            args: Prisma.SupporterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupporterPayload>[]
          }
          create: {
            args: Prisma.SupporterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupporterPayload>
          }
          createMany: {
            args: Prisma.SupporterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupporterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupporterPayload>[]
          }
          delete: {
            args: Prisma.SupporterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupporterPayload>
          }
          update: {
            args: Prisma.SupporterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupporterPayload>
          }
          deleteMany: {
            args: Prisma.SupporterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupporterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupporterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupporterPayload>[]
          }
          upsert: {
            args: Prisma.SupporterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupporterPayload>
          }
          aggregate: {
            args: Prisma.SupporterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupporter>
          }
          groupBy: {
            args: Prisma.SupporterGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupporterGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupporterCountArgs<ExtArgs>
            result: $Utils.Optional<SupporterCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      Ticket: {
        payload: Prisma.$TicketPayload<ExtArgs>
        fields: Prisma.TicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findFirst: {
            args: Prisma.TicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findMany: {
            args: Prisma.TicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          create: {
            args: Prisma.TicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          createMany: {
            args: Prisma.TicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          delete: {
            args: Prisma.TicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          update: {
            args: Prisma.TicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          deleteMany: {
            args: Prisma.TicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          upsert: {
            args: Prisma.TicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.TicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      ReferredPerson: {
        payload: Prisma.$ReferredPersonPayload<ExtArgs>
        fields: Prisma.ReferredPersonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferredPersonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferredPersonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferredPersonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferredPersonPayload>
          }
          findFirst: {
            args: Prisma.ReferredPersonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferredPersonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferredPersonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferredPersonPayload>
          }
          findMany: {
            args: Prisma.ReferredPersonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferredPersonPayload>[]
          }
          create: {
            args: Prisma.ReferredPersonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferredPersonPayload>
          }
          createMany: {
            args: Prisma.ReferredPersonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferredPersonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferredPersonPayload>[]
          }
          delete: {
            args: Prisma.ReferredPersonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferredPersonPayload>
          }
          update: {
            args: Prisma.ReferredPersonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferredPersonPayload>
          }
          deleteMany: {
            args: Prisma.ReferredPersonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferredPersonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReferredPersonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferredPersonPayload>[]
          }
          upsert: {
            args: Prisma.ReferredPersonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferredPersonPayload>
          }
          aggregate: {
            args: Prisma.ReferredPersonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferredPerson>
          }
          groupBy: {
            args: Prisma.ReferredPersonGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferredPersonGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferredPersonCountArgs<ExtArgs>
            result: $Utils.Optional<ReferredPersonCountAggregateOutputType> | number
          }
        }
      }
      RequestToAddProjectMember: {
        payload: Prisma.$RequestToAddProjectMemberPayload<ExtArgs>
        fields: Prisma.RequestToAddProjectMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequestToAddProjectMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestToAddProjectMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequestToAddProjectMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestToAddProjectMemberPayload>
          }
          findFirst: {
            args: Prisma.RequestToAddProjectMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestToAddProjectMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequestToAddProjectMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestToAddProjectMemberPayload>
          }
          findMany: {
            args: Prisma.RequestToAddProjectMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestToAddProjectMemberPayload>[]
          }
          create: {
            args: Prisma.RequestToAddProjectMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestToAddProjectMemberPayload>
          }
          createMany: {
            args: Prisma.RequestToAddProjectMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequestToAddProjectMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestToAddProjectMemberPayload>[]
          }
          delete: {
            args: Prisma.RequestToAddProjectMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestToAddProjectMemberPayload>
          }
          update: {
            args: Prisma.RequestToAddProjectMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestToAddProjectMemberPayload>
          }
          deleteMany: {
            args: Prisma.RequestToAddProjectMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequestToAddProjectMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequestToAddProjectMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestToAddProjectMemberPayload>[]
          }
          upsert: {
            args: Prisma.RequestToAddProjectMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestToAddProjectMemberPayload>
          }
          aggregate: {
            args: Prisma.RequestToAddProjectMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequestToAddProjectMember>
          }
          groupBy: {
            args: Prisma.RequestToAddProjectMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequestToAddProjectMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequestToAddProjectMemberCountArgs<ExtArgs>
            result: $Utils.Optional<RequestToAddProjectMemberCountAggregateOutputType> | number
          }
        }
      }
      Viewer: {
        payload: Prisma.$ViewerPayload<ExtArgs>
        fields: Prisma.ViewerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViewerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViewerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewerPayload>
          }
          findFirst: {
            args: Prisma.ViewerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViewerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewerPayload>
          }
          findMany: {
            args: Prisma.ViewerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewerPayload>[]
          }
          create: {
            args: Prisma.ViewerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewerPayload>
          }
          createMany: {
            args: Prisma.ViewerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViewerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewerPayload>[]
          }
          delete: {
            args: Prisma.ViewerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewerPayload>
          }
          update: {
            args: Prisma.ViewerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewerPayload>
          }
          deleteMany: {
            args: Prisma.ViewerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViewerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ViewerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewerPayload>[]
          }
          upsert: {
            args: Prisma.ViewerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewerPayload>
          }
          aggregate: {
            args: Prisma.ViewerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViewer>
          }
          groupBy: {
            args: Prisma.ViewerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViewerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViewerCountArgs<ExtArgs>
            result: $Utils.Optional<ViewerCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    activity?: ActivityOmit
    client?: ClientOmit
    employee?: EmployeeOmit
    otpVerification?: OtpVerificationOmit
    payment?: PaymentOmit
    manager?: ManagerOmit
    notification?: NotificationOmit
    notificationProvision?: NotificationProvisionOmit
    notificationPermissionEmployee?: NotificationPermissionEmployeeOmit
    notificationPermissionManager?: NotificationPermissionManagerOmit
    notificationPermissionClient?: NotificationPermissionClientOmit
    notificationPermissionSupporter?: NotificationPermissionSupporterOmit
    notificationPermissionAdmin?: NotificationPermissionAdminOmit
    notificationPermissionSuperAdmin?: NotificationPermissionSuperAdminOmit
    program?: ProgramOmit
    project?: ProjectOmit
    projectEmployee?: ProjectEmployeeOmit
    review?: ReviewOmit
    sheet?: SheetOmit
    submissionReturn?: SubmissionReturnOmit
    submitted?: SubmittedOmit
    superAdmin?: SuperAdminOmit
    supporter?: SupporterOmit
    task?: TaskOmit
    ticket?: TicketOmit
    user?: UserOmit
    tag?: TagOmit
    referredPerson?: ReferredPersonOmit
    requestToAddProjectMember?: RequestToAddProjectMemberOmit
    viewer?: ViewerOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    referredPersons: number
    tickets: number
    programs: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referredPersons?: boolean | ClientCountOutputTypeCountReferredPersonsArgs
    tickets?: boolean | ClientCountOutputTypeCountTicketsArgs
    programs?: boolean | ClientCountOutputTypeCountProgramsArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountReferredPersonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferredPersonWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    projectEmployees: number
    submitted: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectEmployees?: boolean | EmployeeCountOutputTypeCountProjectEmployeesArgs
    submitted?: boolean | EmployeeCountOutputTypeCountSubmittedArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountProjectEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectEmployeeWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountSubmittedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmittedWhereInput
  }


  /**
   * Count Type ManagerCountOutputType
   */

  export type ManagerCountOutputType = {
    projects: number
    requestsToAddProjectMember: number
  }

  export type ManagerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | ManagerCountOutputTypeCountProjectsArgs
    requestsToAddProjectMember?: boolean | ManagerCountOutputTypeCountRequestsToAddProjectMemberArgs
  }

  // Custom InputTypes
  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerCountOutputType
     */
    select?: ManagerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeCountRequestsToAddProjectMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestToAddProjectMemberWhereInput
  }


  /**
   * Count Type NotificationCountOutputType
   */

  export type NotificationCountOutputType = {
    provisions: number
  }

  export type NotificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provisions?: boolean | NotificationCountOutputTypeCountProvisionsArgs
  }

  // Custom InputTypes
  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCountOutputType
     */
    select?: NotificationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeCountProvisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationProvisionWhereInput
  }


  /**
   * Count Type ProgramCountOutputType
   */

  export type ProgramCountOutputType = {
    projects: number
  }

  export type ProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | ProgramCountOutputTypeCountProjectsArgs
  }

  // Custom InputTypes
  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCountOutputType
     */
    select?: ProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    projectEmployees: number
    tasks: number
    activities: number
    reviews: number
    requestsToAddProjectMember: number
    submitted: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectEmployees?: boolean | ProjectCountOutputTypeCountProjectEmployeesArgs
    tasks?: boolean | ProjectCountOutputTypeCountTasksArgs
    activities?: boolean | ProjectCountOutputTypeCountActivitiesArgs
    reviews?: boolean | ProjectCountOutputTypeCountReviewsArgs
    requestsToAddProjectMember?: boolean | ProjectCountOutputTypeCountRequestsToAddProjectMemberArgs
    submitted?: boolean | ProjectCountOutputTypeCountSubmittedArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountProjectEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectEmployeeWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountRequestsToAddProjectMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestToAddProjectMemberWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSubmittedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmittedWhereInput
  }


  /**
   * Count Type SheetCountOutputType
   */

  export type SheetCountOutputType = {
    submitted: number
  }

  export type SheetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submitted?: boolean | SheetCountOutputTypeCountSubmittedArgs
  }

  // Custom InputTypes
  /**
   * SheetCountOutputType without action
   */
  export type SheetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SheetCountOutputType
     */
    select?: SheetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SheetCountOutputType without action
   */
  export type SheetCountOutputTypeCountSubmittedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmittedWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    notifications: number
    payments: number
    activities: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    activities?: boolean | UserCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationProvisionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    userId: string | null
    timestamp: Date | null
    description: string | null
    projectId: string | null
    ipAddress: string | null
    actionType: $Enums.ActivityActionType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    timestamp: Date | null
    description: string | null
    projectId: string | null
    ipAddress: string | null
    actionType: $Enums.ActivityActionType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    userId: number
    timestamp: number
    description: number
    projectId: number
    ipAddress: number
    actionType: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActivityMinAggregateInputType = {
    id?: true
    userId?: true
    timestamp?: true
    description?: true
    projectId?: true
    ipAddress?: true
    actionType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    userId?: true
    timestamp?: true
    description?: true
    projectId?: true
    ipAddress?: true
    actionType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    userId?: true
    timestamp?: true
    description?: true
    projectId?: true
    ipAddress?: true
    actionType?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    userId: string
    timestamp: Date
    description: string
    projectId: string
    ipAddress: string | null
    actionType: $Enums.ActivityActionType
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    timestamp?: boolean
    description?: boolean
    projectId?: boolean
    ipAddress?: boolean
    actionType?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    timestamp?: boolean
    description?: boolean
    projectId?: boolean
    ipAddress?: boolean
    actionType?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    timestamp?: boolean
    description?: boolean
    projectId?: boolean
    ipAddress?: boolean
    actionType?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    userId?: boolean
    timestamp?: boolean
    description?: boolean
    projectId?: boolean
    ipAddress?: boolean
    actionType?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "timestamp" | "description" | "projectId" | "ipAddress" | "actionType" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["activity"]>
  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      timestamp: Date
      description: string
      projectId: string
      ipAddress: string | null
      actionType: $Enums.ActivityActionType
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities and returns the data updated in the database.
     * @param {ActivityUpdateManyAndReturnArgs} args - Arguments to update many Activities.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly userId: FieldRef<"Activity", 'String'>
    readonly timestamp: FieldRef<"Activity", 'DateTime'>
    readonly description: FieldRef<"Activity", 'String'>
    readonly projectId: FieldRef<"Activity", 'String'>
    readonly ipAddress: FieldRef<"Activity", 'String'>
    readonly actionType: FieldRef<"Activity", 'ActivityActionType'>
    readonly metadata: FieldRef<"Activity", 'Json'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
    readonly updatedAt: FieldRef<"Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity updateManyAndReturn
   */
  export type ActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to delete.
     */
    limit?: number
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    threshold: number | null
    archiveAfter: number | null
    trialPeriod: number | null
  }

  export type ClientSumAggregateOutputType = {
    threshold: number | null
    archiveAfter: number | null
    trialPeriod: number | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    contactPersonName: string | null
    clientLogo: string | null
    favicon: string | null
    primaryColor: string | null
    secondaryColor: string | null
    footerText: string | null
    supportMail: string | null
    subdomain: string | null
    serverLocation: string | null
    category: $Enums.IndustryCategory | null
    onboarding: boolean | null
    welcomeDashboard: boolean | null
    storage: string | null
    threshold: number | null
    archiveAfter: number | null
    userWarning: boolean | null
    adminNote: string | null
    trialPeriod: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    contactPersonName: string | null
    clientLogo: string | null
    favicon: string | null
    primaryColor: string | null
    secondaryColor: string | null
    footerText: string | null
    supportMail: string | null
    subdomain: string | null
    serverLocation: string | null
    category: $Enums.IndustryCategory | null
    onboarding: boolean | null
    welcomeDashboard: boolean | null
    storage: string | null
    threshold: number | null
    archiveAfter: number | null
    userWarning: boolean | null
    adminNote: string | null
    trialPeriod: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    userId: number
    email: number
    contactPersonName: number
    clientLogo: number
    favicon: number
    primaryColor: number
    secondaryColor: number
    footerText: number
    supportMail: number
    subdomain: number
    serverLocation: number
    category: number
    onboarding: number
    welcomeDashboard: number
    chartList: number
    storage: number
    threshold: number
    archiveAfter: number
    userWarning: number
    adminNote: number
    trialPeriod: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    threshold?: true
    archiveAfter?: true
    trialPeriod?: true
  }

  export type ClientSumAggregateInputType = {
    threshold?: true
    archiveAfter?: true
    trialPeriod?: true
  }

  export type ClientMinAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    contactPersonName?: true
    clientLogo?: true
    favicon?: true
    primaryColor?: true
    secondaryColor?: true
    footerText?: true
    supportMail?: true
    subdomain?: true
    serverLocation?: true
    category?: true
    onboarding?: true
    welcomeDashboard?: true
    storage?: true
    threshold?: true
    archiveAfter?: true
    userWarning?: true
    adminNote?: true
    trialPeriod?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    contactPersonName?: true
    clientLogo?: true
    favicon?: true
    primaryColor?: true
    secondaryColor?: true
    footerText?: true
    supportMail?: true
    subdomain?: true
    serverLocation?: true
    category?: true
    onboarding?: true
    welcomeDashboard?: true
    storage?: true
    threshold?: true
    archiveAfter?: true
    userWarning?: true
    adminNote?: true
    trialPeriod?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    contactPersonName?: true
    clientLogo?: true
    favicon?: true
    primaryColor?: true
    secondaryColor?: true
    footerText?: true
    supportMail?: true
    subdomain?: true
    serverLocation?: true
    category?: true
    onboarding?: true
    welcomeDashboard?: true
    chartList?: true
    storage?: true
    threshold?: true
    archiveAfter?: true
    userWarning?: true
    adminNote?: true
    trialPeriod?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    userId: string
    email: string
    contactPersonName: string | null
    clientLogo: string | null
    favicon: string | null
    primaryColor: string | null
    secondaryColor: string | null
    footerText: string | null
    supportMail: string | null
    subdomain: string | null
    serverLocation: string | null
    category: $Enums.IndustryCategory
    onboarding: boolean
    welcomeDashboard: boolean
    chartList: string[]
    storage: string | null
    threshold: number | null
    archiveAfter: number | null
    userWarning: boolean
    adminNote: string | null
    trialPeriod: number | null
    createdAt: Date
    updatedAt: Date
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    contactPersonName?: boolean
    clientLogo?: boolean
    favicon?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    footerText?: boolean
    supportMail?: boolean
    subdomain?: boolean
    serverLocation?: boolean
    category?: boolean
    onboarding?: boolean
    welcomeDashboard?: boolean
    chartList?: boolean
    storage?: boolean
    threshold?: boolean
    archiveAfter?: boolean
    userWarning?: boolean
    adminNote?: boolean
    trialPeriod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    referredPersons?: boolean | Client$referredPersonsArgs<ExtArgs>
    tickets?: boolean | Client$ticketsArgs<ExtArgs>
    programs?: boolean | Client$programsArgs<ExtArgs>
    tags?: boolean | Client$tagsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    contactPersonName?: boolean
    clientLogo?: boolean
    favicon?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    footerText?: boolean
    supportMail?: boolean
    subdomain?: boolean
    serverLocation?: boolean
    category?: boolean
    onboarding?: boolean
    welcomeDashboard?: boolean
    chartList?: boolean
    storage?: boolean
    threshold?: boolean
    archiveAfter?: boolean
    userWarning?: boolean
    adminNote?: boolean
    trialPeriod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    contactPersonName?: boolean
    clientLogo?: boolean
    favicon?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    footerText?: boolean
    supportMail?: boolean
    subdomain?: boolean
    serverLocation?: boolean
    category?: boolean
    onboarding?: boolean
    welcomeDashboard?: boolean
    chartList?: boolean
    storage?: boolean
    threshold?: boolean
    archiveAfter?: boolean
    userWarning?: boolean
    adminNote?: boolean
    trialPeriod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    userId?: boolean
    email?: boolean
    contactPersonName?: boolean
    clientLogo?: boolean
    favicon?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    footerText?: boolean
    supportMail?: boolean
    subdomain?: boolean
    serverLocation?: boolean
    category?: boolean
    onboarding?: boolean
    welcomeDashboard?: boolean
    chartList?: boolean
    storage?: boolean
    threshold?: boolean
    archiveAfter?: boolean
    userWarning?: boolean
    adminNote?: boolean
    trialPeriod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "email" | "contactPersonName" | "clientLogo" | "favicon" | "primaryColor" | "secondaryColor" | "footerText" | "supportMail" | "subdomain" | "serverLocation" | "category" | "onboarding" | "welcomeDashboard" | "chartList" | "storage" | "threshold" | "archiveAfter" | "userWarning" | "adminNote" | "trialPeriod" | "createdAt" | "updatedAt", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    referredPersons?: boolean | Client$referredPersonsArgs<ExtArgs>
    tickets?: boolean | Client$ticketsArgs<ExtArgs>
    programs?: boolean | Client$programsArgs<ExtArgs>
    tags?: boolean | Client$tagsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      referredPersons: Prisma.$ReferredPersonPayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      programs: Prisma.$ProgramPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      email: string
      contactPersonName: string | null
      clientLogo: string | null
      favicon: string | null
      primaryColor: string | null
      secondaryColor: string | null
      footerText: string | null
      supportMail: string | null
      subdomain: string | null
      serverLocation: string | null
      category: $Enums.IndustryCategory
      onboarding: boolean
      welcomeDashboard: boolean
      chartList: string[]
      storage: string | null
      threshold: number | null
      archiveAfter: number | null
      userWarning: boolean
      adminNote: string | null
      trialPeriod: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    referredPersons<T extends Client$referredPersonsArgs<ExtArgs> = {}>(args?: Subset<T, Client$referredPersonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferredPersonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets<T extends Client$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Client$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    programs<T extends Client$programsArgs<ExtArgs> = {}>(args?: Subset<T, Client$programsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Client$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Client$tagsArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly userId: FieldRef<"Client", 'String'>
    readonly email: FieldRef<"Client", 'String'>
    readonly contactPersonName: FieldRef<"Client", 'String'>
    readonly clientLogo: FieldRef<"Client", 'String'>
    readonly favicon: FieldRef<"Client", 'String'>
    readonly primaryColor: FieldRef<"Client", 'String'>
    readonly secondaryColor: FieldRef<"Client", 'String'>
    readonly footerText: FieldRef<"Client", 'String'>
    readonly supportMail: FieldRef<"Client", 'String'>
    readonly subdomain: FieldRef<"Client", 'String'>
    readonly serverLocation: FieldRef<"Client", 'String'>
    readonly category: FieldRef<"Client", 'IndustryCategory'>
    readonly onboarding: FieldRef<"Client", 'Boolean'>
    readonly welcomeDashboard: FieldRef<"Client", 'Boolean'>
    readonly chartList: FieldRef<"Client", 'String[]'>
    readonly storage: FieldRef<"Client", 'String'>
    readonly threshold: FieldRef<"Client", 'Int'>
    readonly archiveAfter: FieldRef<"Client", 'Int'>
    readonly userWarning: FieldRef<"Client", 'Boolean'>
    readonly adminNote: FieldRef<"Client", 'String'>
    readonly trialPeriod: FieldRef<"Client", 'Int'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.referredPersons
   */
  export type Client$referredPersonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferredPerson
     */
    select?: ReferredPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferredPerson
     */
    omit?: ReferredPersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferredPersonInclude<ExtArgs> | null
    where?: ReferredPersonWhereInput
    orderBy?: ReferredPersonOrderByWithRelationInput | ReferredPersonOrderByWithRelationInput[]
    cursor?: ReferredPersonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferredPersonScalarFieldEnum | ReferredPersonScalarFieldEnum[]
  }

  /**
   * Client.tickets
   */
  export type Client$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Client.programs
   */
  export type Client$programsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    cursor?: ProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Client.tags
   */
  export type Client$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    joinedDate: string | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    joinedDate: string | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    updatedAt: number
    description: number
    joinedDate: number
    skills: number
    _all: number
  }


  export type EmployeeMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    joinedDate?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    joinedDate?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    joinedDate?: true
    skills?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: string
    userId: string
    createdAt: Date
    updatedAt: Date
    description: string
    joinedDate: string
    skills: string[]
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    joinedDate?: boolean
    skills?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    projectEmployees?: boolean | Employee$projectEmployeesArgs<ExtArgs>
    submitted?: boolean | Employee$submittedArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    joinedDate?: boolean
    skills?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    joinedDate?: boolean
    skills?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    joinedDate?: boolean
    skills?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "createdAt" | "updatedAt" | "description" | "joinedDate" | "skills", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    projectEmployees?: boolean | Employee$projectEmployeesArgs<ExtArgs>
    submitted?: boolean | Employee$submittedArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      projectEmployees: Prisma.$ProjectEmployeePayload<ExtArgs>[]
      submitted: Prisma.$SubmittedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      createdAt: Date
      updatedAt: Date
      description: string
      joinedDate: string
      skills: string[]
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    projectEmployees<T extends Employee$projectEmployeesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$projectEmployeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectEmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    submitted<T extends Employee$submittedArgs<ExtArgs> = {}>(args?: Subset<T, Employee$submittedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmittedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'String'>
    readonly userId: FieldRef<"Employee", 'String'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
    readonly description: FieldRef<"Employee", 'String'>
    readonly joinedDate: FieldRef<"Employee", 'String'>
    readonly skills: FieldRef<"Employee", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.projectEmployees
   */
  export type Employee$projectEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEmployee
     */
    select?: ProjectEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEmployee
     */
    omit?: ProjectEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEmployeeInclude<ExtArgs> | null
    where?: ProjectEmployeeWhereInput
    orderBy?: ProjectEmployeeOrderByWithRelationInput | ProjectEmployeeOrderByWithRelationInput[]
    cursor?: ProjectEmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectEmployeeScalarFieldEnum | ProjectEmployeeScalarFieldEnum[]
  }

  /**
   * Employee.submitted
   */
  export type Employee$submittedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submitted
     */
    select?: SubmittedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submitted
     */
    omit?: SubmittedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmittedInclude<ExtArgs> | null
    where?: SubmittedWhereInput
    orderBy?: SubmittedOrderByWithRelationInput | SubmittedOrderByWithRelationInput[]
    cursor?: SubmittedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubmittedScalarFieldEnum | SubmittedScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model OtpVerification
   */

  export type AggregateOtpVerification = {
    _count: OtpVerificationCountAggregateOutputType | null
    _min: OtpVerificationMinAggregateOutputType | null
    _max: OtpVerificationMaxAggregateOutputType | null
  }

  export type OtpVerificationMinAggregateOutputType = {
    id: string | null
    email: string | null
    otp: string | null
    expiresAt: Date | null
    verified: boolean | null
    createdAt: Date | null
  }

  export type OtpVerificationMaxAggregateOutputType = {
    id: string | null
    email: string | null
    otp: string | null
    expiresAt: Date | null
    verified: boolean | null
    createdAt: Date | null
  }

  export type OtpVerificationCountAggregateOutputType = {
    id: number
    email: number
    otp: number
    expiresAt: number
    verified: number
    createdAt: number
    _all: number
  }


  export type OtpVerificationMinAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    expiresAt?: true
    verified?: true
    createdAt?: true
  }

  export type OtpVerificationMaxAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    expiresAt?: true
    verified?: true
    createdAt?: true
  }

  export type OtpVerificationCountAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    expiresAt?: true
    verified?: true
    createdAt?: true
    _all?: true
  }

  export type OtpVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OtpVerification to aggregate.
     */
    where?: OtpVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtpVerifications to fetch.
     */
    orderBy?: OtpVerificationOrderByWithRelationInput | OtpVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtpVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtpVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtpVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OtpVerifications
    **/
    _count?: true | OtpVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpVerificationMaxAggregateInputType
  }

  export type GetOtpVerificationAggregateType<T extends OtpVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateOtpVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtpVerification[P]>
      : GetScalarType<T[P], AggregateOtpVerification[P]>
  }




  export type OtpVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpVerificationWhereInput
    orderBy?: OtpVerificationOrderByWithAggregationInput | OtpVerificationOrderByWithAggregationInput[]
    by: OtpVerificationScalarFieldEnum[] | OtpVerificationScalarFieldEnum
    having?: OtpVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpVerificationCountAggregateInputType | true
    _min?: OtpVerificationMinAggregateInputType
    _max?: OtpVerificationMaxAggregateInputType
  }

  export type OtpVerificationGroupByOutputType = {
    id: string
    email: string
    otp: string
    expiresAt: Date
    verified: boolean
    createdAt: Date
    _count: OtpVerificationCountAggregateOutputType | null
    _min: OtpVerificationMinAggregateOutputType | null
    _max: OtpVerificationMaxAggregateOutputType | null
  }

  type GetOtpVerificationGroupByPayload<T extends OtpVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], OtpVerificationGroupByOutputType[P]>
        }
      >
    >


  export type OtpVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp?: boolean
    expiresAt?: boolean
    verified?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["otpVerification"]>

  export type OtpVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp?: boolean
    expiresAt?: boolean
    verified?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["otpVerification"]>

  export type OtpVerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp?: boolean
    expiresAt?: boolean
    verified?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["otpVerification"]>

  export type OtpVerificationSelectScalar = {
    id?: boolean
    email?: boolean
    otp?: boolean
    expiresAt?: boolean
    verified?: boolean
    createdAt?: boolean
  }

  export type OtpVerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "otp" | "expiresAt" | "verified" | "createdAt", ExtArgs["result"]["otpVerification"]>
  export type OtpVerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OtpVerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OtpVerificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OtpVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OtpVerification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      otp: string
      expiresAt: Date
      verified: boolean
      createdAt: Date
    }, ExtArgs["result"]["otpVerification"]>
    composites: {}
  }

  type OtpVerificationGetPayload<S extends boolean | null | undefined | OtpVerificationDefaultArgs> = $Result.GetResult<Prisma.$OtpVerificationPayload, S>

  type OtpVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OtpVerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OtpVerificationCountAggregateInputType | true
    }

  export interface OtpVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OtpVerification'], meta: { name: 'OtpVerification' } }
    /**
     * Find zero or one OtpVerification that matches the filter.
     * @param {OtpVerificationFindUniqueArgs} args - Arguments to find a OtpVerification
     * @example
     * // Get one OtpVerification
     * const otpVerification = await prisma.otpVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OtpVerificationFindUniqueArgs>(args: SelectSubset<T, OtpVerificationFindUniqueArgs<ExtArgs>>): Prisma__OtpVerificationClient<$Result.GetResult<Prisma.$OtpVerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OtpVerification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OtpVerificationFindUniqueOrThrowArgs} args - Arguments to find a OtpVerification
     * @example
     * // Get one OtpVerification
     * const otpVerification = await prisma.otpVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OtpVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, OtpVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OtpVerificationClient<$Result.GetResult<Prisma.$OtpVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OtpVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpVerificationFindFirstArgs} args - Arguments to find a OtpVerification
     * @example
     * // Get one OtpVerification
     * const otpVerification = await prisma.otpVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OtpVerificationFindFirstArgs>(args?: SelectSubset<T, OtpVerificationFindFirstArgs<ExtArgs>>): Prisma__OtpVerificationClient<$Result.GetResult<Prisma.$OtpVerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OtpVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpVerificationFindFirstOrThrowArgs} args - Arguments to find a OtpVerification
     * @example
     * // Get one OtpVerification
     * const otpVerification = await prisma.otpVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OtpVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, OtpVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OtpVerificationClient<$Result.GetResult<Prisma.$OtpVerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OtpVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OtpVerifications
     * const otpVerifications = await prisma.otpVerification.findMany()
     * 
     * // Get first 10 OtpVerifications
     * const otpVerifications = await prisma.otpVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpVerificationWithIdOnly = await prisma.otpVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OtpVerificationFindManyArgs>(args?: SelectSubset<T, OtpVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OtpVerification.
     * @param {OtpVerificationCreateArgs} args - Arguments to create a OtpVerification.
     * @example
     * // Create one OtpVerification
     * const OtpVerification = await prisma.otpVerification.create({
     *   data: {
     *     // ... data to create a OtpVerification
     *   }
     * })
     * 
     */
    create<T extends OtpVerificationCreateArgs>(args: SelectSubset<T, OtpVerificationCreateArgs<ExtArgs>>): Prisma__OtpVerificationClient<$Result.GetResult<Prisma.$OtpVerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OtpVerifications.
     * @param {OtpVerificationCreateManyArgs} args - Arguments to create many OtpVerifications.
     * @example
     * // Create many OtpVerifications
     * const otpVerification = await prisma.otpVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OtpVerificationCreateManyArgs>(args?: SelectSubset<T, OtpVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OtpVerifications and returns the data saved in the database.
     * @param {OtpVerificationCreateManyAndReturnArgs} args - Arguments to create many OtpVerifications.
     * @example
     * // Create many OtpVerifications
     * const otpVerification = await prisma.otpVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OtpVerifications and only return the `id`
     * const otpVerificationWithIdOnly = await prisma.otpVerification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OtpVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, OtpVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpVerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OtpVerification.
     * @param {OtpVerificationDeleteArgs} args - Arguments to delete one OtpVerification.
     * @example
     * // Delete one OtpVerification
     * const OtpVerification = await prisma.otpVerification.delete({
     *   where: {
     *     // ... filter to delete one OtpVerification
     *   }
     * })
     * 
     */
    delete<T extends OtpVerificationDeleteArgs>(args: SelectSubset<T, OtpVerificationDeleteArgs<ExtArgs>>): Prisma__OtpVerificationClient<$Result.GetResult<Prisma.$OtpVerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OtpVerification.
     * @param {OtpVerificationUpdateArgs} args - Arguments to update one OtpVerification.
     * @example
     * // Update one OtpVerification
     * const otpVerification = await prisma.otpVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OtpVerificationUpdateArgs>(args: SelectSubset<T, OtpVerificationUpdateArgs<ExtArgs>>): Prisma__OtpVerificationClient<$Result.GetResult<Prisma.$OtpVerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OtpVerifications.
     * @param {OtpVerificationDeleteManyArgs} args - Arguments to filter OtpVerifications to delete.
     * @example
     * // Delete a few OtpVerifications
     * const { count } = await prisma.otpVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OtpVerificationDeleteManyArgs>(args?: SelectSubset<T, OtpVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OtpVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OtpVerifications
     * const otpVerification = await prisma.otpVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OtpVerificationUpdateManyArgs>(args: SelectSubset<T, OtpVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OtpVerifications and returns the data updated in the database.
     * @param {OtpVerificationUpdateManyAndReturnArgs} args - Arguments to update many OtpVerifications.
     * @example
     * // Update many OtpVerifications
     * const otpVerification = await prisma.otpVerification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OtpVerifications and only return the `id`
     * const otpVerificationWithIdOnly = await prisma.otpVerification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OtpVerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, OtpVerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpVerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OtpVerification.
     * @param {OtpVerificationUpsertArgs} args - Arguments to update or create a OtpVerification.
     * @example
     * // Update or create a OtpVerification
     * const otpVerification = await prisma.otpVerification.upsert({
     *   create: {
     *     // ... data to create a OtpVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OtpVerification we want to update
     *   }
     * })
     */
    upsert<T extends OtpVerificationUpsertArgs>(args: SelectSubset<T, OtpVerificationUpsertArgs<ExtArgs>>): Prisma__OtpVerificationClient<$Result.GetResult<Prisma.$OtpVerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OtpVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpVerificationCountArgs} args - Arguments to filter OtpVerifications to count.
     * @example
     * // Count the number of OtpVerifications
     * const count = await prisma.otpVerification.count({
     *   where: {
     *     // ... the filter for the OtpVerifications we want to count
     *   }
     * })
    **/
    count<T extends OtpVerificationCountArgs>(
      args?: Subset<T, OtpVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OtpVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpVerificationAggregateArgs>(args: Subset<T, OtpVerificationAggregateArgs>): Prisma.PrismaPromise<GetOtpVerificationAggregateType<T>>

    /**
     * Group by OtpVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtpVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtpVerificationGroupByArgs['orderBy'] }
        : { orderBy?: OtpVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtpVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OtpVerification model
   */
  readonly fields: OtpVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OtpVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtpVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OtpVerification model
   */
  interface OtpVerificationFieldRefs {
    readonly id: FieldRef<"OtpVerification", 'String'>
    readonly email: FieldRef<"OtpVerification", 'String'>
    readonly otp: FieldRef<"OtpVerification", 'String'>
    readonly expiresAt: FieldRef<"OtpVerification", 'DateTime'>
    readonly verified: FieldRef<"OtpVerification", 'Boolean'>
    readonly createdAt: FieldRef<"OtpVerification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OtpVerification findUnique
   */
  export type OtpVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpVerification
     */
    omit?: OtpVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpVerificationInclude<ExtArgs> | null
    /**
     * Filter, which OtpVerification to fetch.
     */
    where: OtpVerificationWhereUniqueInput
  }

  /**
   * OtpVerification findUniqueOrThrow
   */
  export type OtpVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpVerification
     */
    omit?: OtpVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpVerificationInclude<ExtArgs> | null
    /**
     * Filter, which OtpVerification to fetch.
     */
    where: OtpVerificationWhereUniqueInput
  }

  /**
   * OtpVerification findFirst
   */
  export type OtpVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpVerification
     */
    omit?: OtpVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpVerificationInclude<ExtArgs> | null
    /**
     * Filter, which OtpVerification to fetch.
     */
    where?: OtpVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtpVerifications to fetch.
     */
    orderBy?: OtpVerificationOrderByWithRelationInput | OtpVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OtpVerifications.
     */
    cursor?: OtpVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtpVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtpVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OtpVerifications.
     */
    distinct?: OtpVerificationScalarFieldEnum | OtpVerificationScalarFieldEnum[]
  }

  /**
   * OtpVerification findFirstOrThrow
   */
  export type OtpVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpVerification
     */
    omit?: OtpVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpVerificationInclude<ExtArgs> | null
    /**
     * Filter, which OtpVerification to fetch.
     */
    where?: OtpVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtpVerifications to fetch.
     */
    orderBy?: OtpVerificationOrderByWithRelationInput | OtpVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OtpVerifications.
     */
    cursor?: OtpVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtpVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtpVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OtpVerifications.
     */
    distinct?: OtpVerificationScalarFieldEnum | OtpVerificationScalarFieldEnum[]
  }

  /**
   * OtpVerification findMany
   */
  export type OtpVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpVerification
     */
    omit?: OtpVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpVerificationInclude<ExtArgs> | null
    /**
     * Filter, which OtpVerifications to fetch.
     */
    where?: OtpVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtpVerifications to fetch.
     */
    orderBy?: OtpVerificationOrderByWithRelationInput | OtpVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OtpVerifications.
     */
    cursor?: OtpVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtpVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtpVerifications.
     */
    skip?: number
    distinct?: OtpVerificationScalarFieldEnum | OtpVerificationScalarFieldEnum[]
  }

  /**
   * OtpVerification create
   */
  export type OtpVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpVerification
     */
    omit?: OtpVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpVerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a OtpVerification.
     */
    data: XOR<OtpVerificationCreateInput, OtpVerificationUncheckedCreateInput>
  }

  /**
   * OtpVerification createMany
   */
  export type OtpVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OtpVerifications.
     */
    data: OtpVerificationCreateManyInput | OtpVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OtpVerification createManyAndReturn
   */
  export type OtpVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OtpVerification
     */
    omit?: OtpVerificationOmit<ExtArgs> | null
    /**
     * The data used to create many OtpVerifications.
     */
    data: OtpVerificationCreateManyInput | OtpVerificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpVerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OtpVerification update
   */
  export type OtpVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpVerification
     */
    omit?: OtpVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpVerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a OtpVerification.
     */
    data: XOR<OtpVerificationUpdateInput, OtpVerificationUncheckedUpdateInput>
    /**
     * Choose, which OtpVerification to update.
     */
    where: OtpVerificationWhereUniqueInput
  }

  /**
   * OtpVerification updateMany
   */
  export type OtpVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OtpVerifications.
     */
    data: XOR<OtpVerificationUpdateManyMutationInput, OtpVerificationUncheckedUpdateManyInput>
    /**
     * Filter which OtpVerifications to update
     */
    where?: OtpVerificationWhereInput
    /**
     * Limit how many OtpVerifications to update.
     */
    limit?: number
  }

  /**
   * OtpVerification updateManyAndReturn
   */
  export type OtpVerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OtpVerification
     */
    omit?: OtpVerificationOmit<ExtArgs> | null
    /**
     * The data used to update OtpVerifications.
     */
    data: XOR<OtpVerificationUpdateManyMutationInput, OtpVerificationUncheckedUpdateManyInput>
    /**
     * Filter which OtpVerifications to update
     */
    where?: OtpVerificationWhereInput
    /**
     * Limit how many OtpVerifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpVerificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OtpVerification upsert
   */
  export type OtpVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpVerification
     */
    omit?: OtpVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpVerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the OtpVerification to update in case it exists.
     */
    where: OtpVerificationWhereUniqueInput
    /**
     * In case the OtpVerification found by the `where` argument doesn't exist, create a new OtpVerification with this data.
     */
    create: XOR<OtpVerificationCreateInput, OtpVerificationUncheckedCreateInput>
    /**
     * In case the OtpVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtpVerificationUpdateInput, OtpVerificationUncheckedUpdateInput>
  }

  /**
   * OtpVerification delete
   */
  export type OtpVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpVerification
     */
    omit?: OtpVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpVerificationInclude<ExtArgs> | null
    /**
     * Filter which OtpVerification to delete.
     */
    where: OtpVerificationWhereUniqueInput
  }

  /**
   * OtpVerification deleteMany
   */
  export type OtpVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OtpVerifications to delete
     */
    where?: OtpVerificationWhereInput
    /**
     * Limit how many OtpVerifications to delete.
     */
    limit?: number
  }

  /**
   * OtpVerification without action
   */
  export type OtpVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpVerification
     */
    omit?: OtpVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpVerificationInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    amount: number | null
    transactionId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    transactionId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    amount: number
    transactionId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    amount?: true
    transactionId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    amount?: true
    transactionId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    amount?: true
    transactionId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    amount: number
    transactionId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    transactionId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    transactionId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    transactionId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    amount?: boolean
    transactionId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "transactionId" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      transactionId: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly transactionId: FieldRef<"Payment", 'String'>
    readonly userId: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Manager
   */

  export type AggregateManager = {
    _count: ManagerCountAggregateOutputType | null
    _min: ManagerMinAggregateOutputType | null
    _max: ManagerMaxAggregateOutputType | null
  }

  export type ManagerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    joinedDate: string | null
  }

  export type ManagerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    joinedDate: string | null
  }

  export type ManagerCountAggregateOutputType = {
    id: number
    userId: number
    skills: number
    createdAt: number
    updatedAt: number
    description: number
    joinedDate: number
    _all: number
  }


  export type ManagerMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    joinedDate?: true
  }

  export type ManagerMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    joinedDate?: true
  }

  export type ManagerCountAggregateInputType = {
    id?: true
    userId?: true
    skills?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    joinedDate?: true
    _all?: true
  }

  export type ManagerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Manager to aggregate.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Managers
    **/
    _count?: true | ManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManagerMaxAggregateInputType
  }

  export type GetManagerAggregateType<T extends ManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManager[P]>
      : GetScalarType<T[P], AggregateManager[P]>
  }




  export type ManagerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManagerWhereInput
    orderBy?: ManagerOrderByWithAggregationInput | ManagerOrderByWithAggregationInput[]
    by: ManagerScalarFieldEnum[] | ManagerScalarFieldEnum
    having?: ManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManagerCountAggregateInputType | true
    _min?: ManagerMinAggregateInputType
    _max?: ManagerMaxAggregateInputType
  }

  export type ManagerGroupByOutputType = {
    id: string
    userId: string
    skills: string[]
    createdAt: Date
    updatedAt: Date
    description: string
    joinedDate: string
    _count: ManagerCountAggregateOutputType | null
    _min: ManagerMinAggregateOutputType | null
    _max: ManagerMaxAggregateOutputType | null
  }

  type GetManagerGroupByPayload<T extends ManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManagerGroupByOutputType[P]>
            : GetScalarType<T[P], ManagerGroupByOutputType[P]>
        }
      >
    >


  export type ManagerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    skills?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    joinedDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    projects?: boolean | Manager$projectsArgs<ExtArgs>
    requestsToAddProjectMember?: boolean | Manager$requestsToAddProjectMemberArgs<ExtArgs>
    _count?: boolean | ManagerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manager"]>

  export type ManagerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    skills?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    joinedDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manager"]>

  export type ManagerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    skills?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    joinedDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manager"]>

  export type ManagerSelectScalar = {
    id?: boolean
    userId?: boolean
    skills?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    joinedDate?: boolean
  }

  export type ManagerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "skills" | "createdAt" | "updatedAt" | "description" | "joinedDate", ExtArgs["result"]["manager"]>
  export type ManagerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    projects?: boolean | Manager$projectsArgs<ExtArgs>
    requestsToAddProjectMember?: boolean | Manager$requestsToAddProjectMemberArgs<ExtArgs>
    _count?: boolean | ManagerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ManagerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ManagerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ManagerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Manager"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      requestsToAddProjectMember: Prisma.$RequestToAddProjectMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      skills: string[]
      createdAt: Date
      updatedAt: Date
      description: string
      joinedDate: string
    }, ExtArgs["result"]["manager"]>
    composites: {}
  }

  type ManagerGetPayload<S extends boolean | null | undefined | ManagerDefaultArgs> = $Result.GetResult<Prisma.$ManagerPayload, S>

  type ManagerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ManagerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ManagerCountAggregateInputType | true
    }

  export interface ManagerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Manager'], meta: { name: 'Manager' } }
    /**
     * Find zero or one Manager that matches the filter.
     * @param {ManagerFindUniqueArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ManagerFindUniqueArgs>(args: SelectSubset<T, ManagerFindUniqueArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Manager that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ManagerFindUniqueOrThrowArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ManagerFindUniqueOrThrowArgs>(args: SelectSubset<T, ManagerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindFirstArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ManagerFindFirstArgs>(args?: SelectSubset<T, ManagerFindFirstArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindFirstOrThrowArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ManagerFindFirstOrThrowArgs>(args?: SelectSubset<T, ManagerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Managers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Managers
     * const managers = await prisma.manager.findMany()
     * 
     * // Get first 10 Managers
     * const managers = await prisma.manager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const managerWithIdOnly = await prisma.manager.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ManagerFindManyArgs>(args?: SelectSubset<T, ManagerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Manager.
     * @param {ManagerCreateArgs} args - Arguments to create a Manager.
     * @example
     * // Create one Manager
     * const Manager = await prisma.manager.create({
     *   data: {
     *     // ... data to create a Manager
     *   }
     * })
     * 
     */
    create<T extends ManagerCreateArgs>(args: SelectSubset<T, ManagerCreateArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Managers.
     * @param {ManagerCreateManyArgs} args - Arguments to create many Managers.
     * @example
     * // Create many Managers
     * const manager = await prisma.manager.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ManagerCreateManyArgs>(args?: SelectSubset<T, ManagerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Managers and returns the data saved in the database.
     * @param {ManagerCreateManyAndReturnArgs} args - Arguments to create many Managers.
     * @example
     * // Create many Managers
     * const manager = await prisma.manager.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Managers and only return the `id`
     * const managerWithIdOnly = await prisma.manager.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ManagerCreateManyAndReturnArgs>(args?: SelectSubset<T, ManagerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Manager.
     * @param {ManagerDeleteArgs} args - Arguments to delete one Manager.
     * @example
     * // Delete one Manager
     * const Manager = await prisma.manager.delete({
     *   where: {
     *     // ... filter to delete one Manager
     *   }
     * })
     * 
     */
    delete<T extends ManagerDeleteArgs>(args: SelectSubset<T, ManagerDeleteArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Manager.
     * @param {ManagerUpdateArgs} args - Arguments to update one Manager.
     * @example
     * // Update one Manager
     * const manager = await prisma.manager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ManagerUpdateArgs>(args: SelectSubset<T, ManagerUpdateArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Managers.
     * @param {ManagerDeleteManyArgs} args - Arguments to filter Managers to delete.
     * @example
     * // Delete a few Managers
     * const { count } = await prisma.manager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ManagerDeleteManyArgs>(args?: SelectSubset<T, ManagerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Managers
     * const manager = await prisma.manager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ManagerUpdateManyArgs>(args: SelectSubset<T, ManagerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Managers and returns the data updated in the database.
     * @param {ManagerUpdateManyAndReturnArgs} args - Arguments to update many Managers.
     * @example
     * // Update many Managers
     * const manager = await prisma.manager.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Managers and only return the `id`
     * const managerWithIdOnly = await prisma.manager.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ManagerUpdateManyAndReturnArgs>(args: SelectSubset<T, ManagerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Manager.
     * @param {ManagerUpsertArgs} args - Arguments to update or create a Manager.
     * @example
     * // Update or create a Manager
     * const manager = await prisma.manager.upsert({
     *   create: {
     *     // ... data to create a Manager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manager we want to update
     *   }
     * })
     */
    upsert<T extends ManagerUpsertArgs>(args: SelectSubset<T, ManagerUpsertArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerCountArgs} args - Arguments to filter Managers to count.
     * @example
     * // Count the number of Managers
     * const count = await prisma.manager.count({
     *   where: {
     *     // ... the filter for the Managers we want to count
     *   }
     * })
    **/
    count<T extends ManagerCountArgs>(
      args?: Subset<T, ManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManagerAggregateArgs>(args: Subset<T, ManagerAggregateArgs>): Prisma.PrismaPromise<GetManagerAggregateType<T>>

    /**
     * Group by Manager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManagerGroupByArgs['orderBy'] }
        : { orderBy?: ManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Manager model
   */
  readonly fields: ManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Manager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManagerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    projects<T extends Manager$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Manager$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requestsToAddProjectMember<T extends Manager$requestsToAddProjectMemberArgs<ExtArgs> = {}>(args?: Subset<T, Manager$requestsToAddProjectMemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestToAddProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Manager model
   */
  interface ManagerFieldRefs {
    readonly id: FieldRef<"Manager", 'String'>
    readonly userId: FieldRef<"Manager", 'String'>
    readonly skills: FieldRef<"Manager", 'String[]'>
    readonly createdAt: FieldRef<"Manager", 'DateTime'>
    readonly updatedAt: FieldRef<"Manager", 'DateTime'>
    readonly description: FieldRef<"Manager", 'String'>
    readonly joinedDate: FieldRef<"Manager", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Manager findUnique
   */
  export type ManagerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager findUniqueOrThrow
   */
  export type ManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager findFirst
   */
  export type ManagerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managers.
     */
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager findFirstOrThrow
   */
  export type ManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managers.
     */
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager findMany
   */
  export type ManagerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Managers to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager create
   */
  export type ManagerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The data needed to create a Manager.
     */
    data: XOR<ManagerCreateInput, ManagerUncheckedCreateInput>
  }

  /**
   * Manager createMany
   */
  export type ManagerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Managers.
     */
    data: ManagerCreateManyInput | ManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Manager createManyAndReturn
   */
  export type ManagerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * The data used to create many Managers.
     */
    data: ManagerCreateManyInput | ManagerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Manager update
   */
  export type ManagerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The data needed to update a Manager.
     */
    data: XOR<ManagerUpdateInput, ManagerUncheckedUpdateInput>
    /**
     * Choose, which Manager to update.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager updateMany
   */
  export type ManagerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Managers.
     */
    data: XOR<ManagerUpdateManyMutationInput, ManagerUncheckedUpdateManyInput>
    /**
     * Filter which Managers to update
     */
    where?: ManagerWhereInput
    /**
     * Limit how many Managers to update.
     */
    limit?: number
  }

  /**
   * Manager updateManyAndReturn
   */
  export type ManagerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * The data used to update Managers.
     */
    data: XOR<ManagerUpdateManyMutationInput, ManagerUncheckedUpdateManyInput>
    /**
     * Filter which Managers to update
     */
    where?: ManagerWhereInput
    /**
     * Limit how many Managers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Manager upsert
   */
  export type ManagerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The filter to search for the Manager to update in case it exists.
     */
    where: ManagerWhereUniqueInput
    /**
     * In case the Manager found by the `where` argument doesn't exist, create a new Manager with this data.
     */
    create: XOR<ManagerCreateInput, ManagerUncheckedCreateInput>
    /**
     * In case the Manager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManagerUpdateInput, ManagerUncheckedUpdateInput>
  }

  /**
   * Manager delete
   */
  export type ManagerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter which Manager to delete.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager deleteMany
   */
  export type ManagerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Managers to delete
     */
    where?: ManagerWhereInput
    /**
     * Limit how many Managers to delete.
     */
    limit?: number
  }

  /**
   * Manager.projects
   */
  export type Manager$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Manager.requestsToAddProjectMember
   */
  export type Manager$requestsToAddProjectMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestToAddProjectMember
     */
    select?: RequestToAddProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestToAddProjectMember
     */
    omit?: RequestToAddProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestToAddProjectMemberInclude<ExtArgs> | null
    where?: RequestToAddProjectMemberWhereInput
    orderBy?: RequestToAddProjectMemberOrderByWithRelationInput | RequestToAddProjectMemberOrderByWithRelationInput[]
    cursor?: RequestToAddProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestToAddProjectMemberScalarFieldEnum | RequestToAddProjectMemberScalarFieldEnum[]
  }

  /**
   * Manager without action
   */
  export type ManagerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    context: string | null
    type: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    context: string | null
    type: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    senderId: number
    receiverIds: number
    context: number
    type: number
    isRead: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    senderId?: true
    context?: true
    type?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    senderId?: true
    context?: true
    type?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    senderId?: true
    receiverIds?: true
    context?: true
    type?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    senderId: string
    receiverIds: string[]
    context: string
    type: string
    isRead: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverIds?: boolean
    context?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provisions?: boolean | Notification$provisionsArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverIds?: boolean
    context?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverIds?: boolean
    context?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    senderId?: boolean
    receiverIds?: boolean
    context?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "senderId" | "receiverIds" | "context" | "type" | "isRead" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provisions?: boolean | Notification$provisionsArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      provisions: Prisma.$NotificationProvisionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderId: string
      receiverIds: string[]
      context: string
      type: string
      isRead: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provisions<T extends Notification$provisionsArgs<ExtArgs> = {}>(args?: Subset<T, Notification$provisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationProvisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly senderId: FieldRef<"Notification", 'String'>
    readonly receiverIds: FieldRef<"Notification", 'String[]'>
    readonly context: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.provisions
   */
  export type Notification$provisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProvision
     */
    select?: NotificationProvisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationProvision
     */
    omit?: NotificationProvisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationProvisionInclude<ExtArgs> | null
    where?: NotificationProvisionWhereInput
    orderBy?: NotificationProvisionOrderByWithRelationInput | NotificationProvisionOrderByWithRelationInput[]
    cursor?: NotificationProvisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationProvisionScalarFieldEnum | NotificationProvisionScalarFieldEnum[]
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model NotificationProvision
   */

  export type AggregateNotificationProvision = {
    _count: NotificationProvisionCountAggregateOutputType | null
    _min: NotificationProvisionMinAggregateOutputType | null
    _max: NotificationProvisionMaxAggregateOutputType | null
  }

  export type NotificationProvisionMinAggregateOutputType = {
    userId: string | null
    notificationId: string | null
  }

  export type NotificationProvisionMaxAggregateOutputType = {
    userId: string | null
    notificationId: string | null
  }

  export type NotificationProvisionCountAggregateOutputType = {
    userId: number
    notificationId: number
    _all: number
  }


  export type NotificationProvisionMinAggregateInputType = {
    userId?: true
    notificationId?: true
  }

  export type NotificationProvisionMaxAggregateInputType = {
    userId?: true
    notificationId?: true
  }

  export type NotificationProvisionCountAggregateInputType = {
    userId?: true
    notificationId?: true
    _all?: true
  }

  export type NotificationProvisionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationProvision to aggregate.
     */
    where?: NotificationProvisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationProvisions to fetch.
     */
    orderBy?: NotificationProvisionOrderByWithRelationInput | NotificationProvisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationProvisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationProvisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationProvisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationProvisions
    **/
    _count?: true | NotificationProvisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationProvisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationProvisionMaxAggregateInputType
  }

  export type GetNotificationProvisionAggregateType<T extends NotificationProvisionAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationProvision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationProvision[P]>
      : GetScalarType<T[P], AggregateNotificationProvision[P]>
  }




  export type NotificationProvisionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationProvisionWhereInput
    orderBy?: NotificationProvisionOrderByWithAggregationInput | NotificationProvisionOrderByWithAggregationInput[]
    by: NotificationProvisionScalarFieldEnum[] | NotificationProvisionScalarFieldEnum
    having?: NotificationProvisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationProvisionCountAggregateInputType | true
    _min?: NotificationProvisionMinAggregateInputType
    _max?: NotificationProvisionMaxAggregateInputType
  }

  export type NotificationProvisionGroupByOutputType = {
    userId: string
    notificationId: string
    _count: NotificationProvisionCountAggregateOutputType | null
    _min: NotificationProvisionMinAggregateOutputType | null
    _max: NotificationProvisionMaxAggregateOutputType | null
  }

  type GetNotificationProvisionGroupByPayload<T extends NotificationProvisionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationProvisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationProvisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationProvisionGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationProvisionGroupByOutputType[P]>
        }
      >
    >


  export type NotificationProvisionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    notificationId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationProvision"]>

  export type NotificationProvisionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    notificationId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationProvision"]>

  export type NotificationProvisionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    notificationId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationProvision"]>

  export type NotificationProvisionSelectScalar = {
    userId?: boolean
    notificationId?: boolean
  }

  export type NotificationProvisionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "notificationId", ExtArgs["result"]["notificationProvision"]>
  export type NotificationProvisionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
  }
  export type NotificationProvisionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
  }
  export type NotificationProvisionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
  }

  export type $NotificationProvisionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationProvision"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      notification: Prisma.$NotificationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      notificationId: string
    }, ExtArgs["result"]["notificationProvision"]>
    composites: {}
  }

  type NotificationProvisionGetPayload<S extends boolean | null | undefined | NotificationProvisionDefaultArgs> = $Result.GetResult<Prisma.$NotificationProvisionPayload, S>

  type NotificationProvisionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationProvisionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationProvisionCountAggregateInputType | true
    }

  export interface NotificationProvisionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationProvision'], meta: { name: 'NotificationProvision' } }
    /**
     * Find zero or one NotificationProvision that matches the filter.
     * @param {NotificationProvisionFindUniqueArgs} args - Arguments to find a NotificationProvision
     * @example
     * // Get one NotificationProvision
     * const notificationProvision = await prisma.notificationProvision.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationProvisionFindUniqueArgs>(args: SelectSubset<T, NotificationProvisionFindUniqueArgs<ExtArgs>>): Prisma__NotificationProvisionClient<$Result.GetResult<Prisma.$NotificationProvisionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationProvision that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationProvisionFindUniqueOrThrowArgs} args - Arguments to find a NotificationProvision
     * @example
     * // Get one NotificationProvision
     * const notificationProvision = await prisma.notificationProvision.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationProvisionFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationProvisionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationProvisionClient<$Result.GetResult<Prisma.$NotificationProvisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationProvision that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationProvisionFindFirstArgs} args - Arguments to find a NotificationProvision
     * @example
     * // Get one NotificationProvision
     * const notificationProvision = await prisma.notificationProvision.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationProvisionFindFirstArgs>(args?: SelectSubset<T, NotificationProvisionFindFirstArgs<ExtArgs>>): Prisma__NotificationProvisionClient<$Result.GetResult<Prisma.$NotificationProvisionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationProvision that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationProvisionFindFirstOrThrowArgs} args - Arguments to find a NotificationProvision
     * @example
     * // Get one NotificationProvision
     * const notificationProvision = await prisma.notificationProvision.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationProvisionFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationProvisionFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationProvisionClient<$Result.GetResult<Prisma.$NotificationProvisionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationProvisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationProvisionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationProvisions
     * const notificationProvisions = await prisma.notificationProvision.findMany()
     * 
     * // Get first 10 NotificationProvisions
     * const notificationProvisions = await prisma.notificationProvision.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const notificationProvisionWithUserIdOnly = await prisma.notificationProvision.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends NotificationProvisionFindManyArgs>(args?: SelectSubset<T, NotificationProvisionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationProvisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationProvision.
     * @param {NotificationProvisionCreateArgs} args - Arguments to create a NotificationProvision.
     * @example
     * // Create one NotificationProvision
     * const NotificationProvision = await prisma.notificationProvision.create({
     *   data: {
     *     // ... data to create a NotificationProvision
     *   }
     * })
     * 
     */
    create<T extends NotificationProvisionCreateArgs>(args: SelectSubset<T, NotificationProvisionCreateArgs<ExtArgs>>): Prisma__NotificationProvisionClient<$Result.GetResult<Prisma.$NotificationProvisionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationProvisions.
     * @param {NotificationProvisionCreateManyArgs} args - Arguments to create many NotificationProvisions.
     * @example
     * // Create many NotificationProvisions
     * const notificationProvision = await prisma.notificationProvision.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationProvisionCreateManyArgs>(args?: SelectSubset<T, NotificationProvisionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationProvisions and returns the data saved in the database.
     * @param {NotificationProvisionCreateManyAndReturnArgs} args - Arguments to create many NotificationProvisions.
     * @example
     * // Create many NotificationProvisions
     * const notificationProvision = await prisma.notificationProvision.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationProvisions and only return the `userId`
     * const notificationProvisionWithUserIdOnly = await prisma.notificationProvision.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationProvisionCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationProvisionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationProvisionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationProvision.
     * @param {NotificationProvisionDeleteArgs} args - Arguments to delete one NotificationProvision.
     * @example
     * // Delete one NotificationProvision
     * const NotificationProvision = await prisma.notificationProvision.delete({
     *   where: {
     *     // ... filter to delete one NotificationProvision
     *   }
     * })
     * 
     */
    delete<T extends NotificationProvisionDeleteArgs>(args: SelectSubset<T, NotificationProvisionDeleteArgs<ExtArgs>>): Prisma__NotificationProvisionClient<$Result.GetResult<Prisma.$NotificationProvisionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationProvision.
     * @param {NotificationProvisionUpdateArgs} args - Arguments to update one NotificationProvision.
     * @example
     * // Update one NotificationProvision
     * const notificationProvision = await prisma.notificationProvision.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationProvisionUpdateArgs>(args: SelectSubset<T, NotificationProvisionUpdateArgs<ExtArgs>>): Prisma__NotificationProvisionClient<$Result.GetResult<Prisma.$NotificationProvisionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationProvisions.
     * @param {NotificationProvisionDeleteManyArgs} args - Arguments to filter NotificationProvisions to delete.
     * @example
     * // Delete a few NotificationProvisions
     * const { count } = await prisma.notificationProvision.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationProvisionDeleteManyArgs>(args?: SelectSubset<T, NotificationProvisionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationProvisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationProvisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationProvisions
     * const notificationProvision = await prisma.notificationProvision.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationProvisionUpdateManyArgs>(args: SelectSubset<T, NotificationProvisionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationProvisions and returns the data updated in the database.
     * @param {NotificationProvisionUpdateManyAndReturnArgs} args - Arguments to update many NotificationProvisions.
     * @example
     * // Update many NotificationProvisions
     * const notificationProvision = await prisma.notificationProvision.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationProvisions and only return the `userId`
     * const notificationProvisionWithUserIdOnly = await prisma.notificationProvision.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationProvisionUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationProvisionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationProvisionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationProvision.
     * @param {NotificationProvisionUpsertArgs} args - Arguments to update or create a NotificationProvision.
     * @example
     * // Update or create a NotificationProvision
     * const notificationProvision = await prisma.notificationProvision.upsert({
     *   create: {
     *     // ... data to create a NotificationProvision
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationProvision we want to update
     *   }
     * })
     */
    upsert<T extends NotificationProvisionUpsertArgs>(args: SelectSubset<T, NotificationProvisionUpsertArgs<ExtArgs>>): Prisma__NotificationProvisionClient<$Result.GetResult<Prisma.$NotificationProvisionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationProvisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationProvisionCountArgs} args - Arguments to filter NotificationProvisions to count.
     * @example
     * // Count the number of NotificationProvisions
     * const count = await prisma.notificationProvision.count({
     *   where: {
     *     // ... the filter for the NotificationProvisions we want to count
     *   }
     * })
    **/
    count<T extends NotificationProvisionCountArgs>(
      args?: Subset<T, NotificationProvisionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationProvisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationProvision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationProvisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationProvisionAggregateArgs>(args: Subset<T, NotificationProvisionAggregateArgs>): Prisma.PrismaPromise<GetNotificationProvisionAggregateType<T>>

    /**
     * Group by NotificationProvision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationProvisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationProvisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationProvisionGroupByArgs['orderBy'] }
        : { orderBy?: NotificationProvisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationProvisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationProvisionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationProvision model
   */
  readonly fields: NotificationProvisionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationProvision.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationProvisionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notification<T extends NotificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NotificationDefaultArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationProvision model
   */
  interface NotificationProvisionFieldRefs {
    readonly userId: FieldRef<"NotificationProvision", 'String'>
    readonly notificationId: FieldRef<"NotificationProvision", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NotificationProvision findUnique
   */
  export type NotificationProvisionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProvision
     */
    select?: NotificationProvisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationProvision
     */
    omit?: NotificationProvisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationProvisionInclude<ExtArgs> | null
    /**
     * Filter, which NotificationProvision to fetch.
     */
    where: NotificationProvisionWhereUniqueInput
  }

  /**
   * NotificationProvision findUniqueOrThrow
   */
  export type NotificationProvisionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProvision
     */
    select?: NotificationProvisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationProvision
     */
    omit?: NotificationProvisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationProvisionInclude<ExtArgs> | null
    /**
     * Filter, which NotificationProvision to fetch.
     */
    where: NotificationProvisionWhereUniqueInput
  }

  /**
   * NotificationProvision findFirst
   */
  export type NotificationProvisionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProvision
     */
    select?: NotificationProvisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationProvision
     */
    omit?: NotificationProvisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationProvisionInclude<ExtArgs> | null
    /**
     * Filter, which NotificationProvision to fetch.
     */
    where?: NotificationProvisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationProvisions to fetch.
     */
    orderBy?: NotificationProvisionOrderByWithRelationInput | NotificationProvisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationProvisions.
     */
    cursor?: NotificationProvisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationProvisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationProvisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationProvisions.
     */
    distinct?: NotificationProvisionScalarFieldEnum | NotificationProvisionScalarFieldEnum[]
  }

  /**
   * NotificationProvision findFirstOrThrow
   */
  export type NotificationProvisionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProvision
     */
    select?: NotificationProvisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationProvision
     */
    omit?: NotificationProvisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationProvisionInclude<ExtArgs> | null
    /**
     * Filter, which NotificationProvision to fetch.
     */
    where?: NotificationProvisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationProvisions to fetch.
     */
    orderBy?: NotificationProvisionOrderByWithRelationInput | NotificationProvisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationProvisions.
     */
    cursor?: NotificationProvisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationProvisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationProvisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationProvisions.
     */
    distinct?: NotificationProvisionScalarFieldEnum | NotificationProvisionScalarFieldEnum[]
  }

  /**
   * NotificationProvision findMany
   */
  export type NotificationProvisionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProvision
     */
    select?: NotificationProvisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationProvision
     */
    omit?: NotificationProvisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationProvisionInclude<ExtArgs> | null
    /**
     * Filter, which NotificationProvisions to fetch.
     */
    where?: NotificationProvisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationProvisions to fetch.
     */
    orderBy?: NotificationProvisionOrderByWithRelationInput | NotificationProvisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationProvisions.
     */
    cursor?: NotificationProvisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationProvisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationProvisions.
     */
    skip?: number
    distinct?: NotificationProvisionScalarFieldEnum | NotificationProvisionScalarFieldEnum[]
  }

  /**
   * NotificationProvision create
   */
  export type NotificationProvisionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProvision
     */
    select?: NotificationProvisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationProvision
     */
    omit?: NotificationProvisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationProvisionInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationProvision.
     */
    data: XOR<NotificationProvisionCreateInput, NotificationProvisionUncheckedCreateInput>
  }

  /**
   * NotificationProvision createMany
   */
  export type NotificationProvisionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationProvisions.
     */
    data: NotificationProvisionCreateManyInput | NotificationProvisionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationProvision createManyAndReturn
   */
  export type NotificationProvisionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProvision
     */
    select?: NotificationProvisionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationProvision
     */
    omit?: NotificationProvisionOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationProvisions.
     */
    data: NotificationProvisionCreateManyInput | NotificationProvisionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationProvisionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationProvision update
   */
  export type NotificationProvisionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProvision
     */
    select?: NotificationProvisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationProvision
     */
    omit?: NotificationProvisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationProvisionInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationProvision.
     */
    data: XOR<NotificationProvisionUpdateInput, NotificationProvisionUncheckedUpdateInput>
    /**
     * Choose, which NotificationProvision to update.
     */
    where: NotificationProvisionWhereUniqueInput
  }

  /**
   * NotificationProvision updateMany
   */
  export type NotificationProvisionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationProvisions.
     */
    data: XOR<NotificationProvisionUpdateManyMutationInput, NotificationProvisionUncheckedUpdateManyInput>
    /**
     * Filter which NotificationProvisions to update
     */
    where?: NotificationProvisionWhereInput
    /**
     * Limit how many NotificationProvisions to update.
     */
    limit?: number
  }

  /**
   * NotificationProvision updateManyAndReturn
   */
  export type NotificationProvisionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProvision
     */
    select?: NotificationProvisionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationProvision
     */
    omit?: NotificationProvisionOmit<ExtArgs> | null
    /**
     * The data used to update NotificationProvisions.
     */
    data: XOR<NotificationProvisionUpdateManyMutationInput, NotificationProvisionUncheckedUpdateManyInput>
    /**
     * Filter which NotificationProvisions to update
     */
    where?: NotificationProvisionWhereInput
    /**
     * Limit how many NotificationProvisions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationProvisionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationProvision upsert
   */
  export type NotificationProvisionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProvision
     */
    select?: NotificationProvisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationProvision
     */
    omit?: NotificationProvisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationProvisionInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationProvision to update in case it exists.
     */
    where: NotificationProvisionWhereUniqueInput
    /**
     * In case the NotificationProvision found by the `where` argument doesn't exist, create a new NotificationProvision with this data.
     */
    create: XOR<NotificationProvisionCreateInput, NotificationProvisionUncheckedCreateInput>
    /**
     * In case the NotificationProvision was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationProvisionUpdateInput, NotificationProvisionUncheckedUpdateInput>
  }

  /**
   * NotificationProvision delete
   */
  export type NotificationProvisionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProvision
     */
    select?: NotificationProvisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationProvision
     */
    omit?: NotificationProvisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationProvisionInclude<ExtArgs> | null
    /**
     * Filter which NotificationProvision to delete.
     */
    where: NotificationProvisionWhereUniqueInput
  }

  /**
   * NotificationProvision deleteMany
   */
  export type NotificationProvisionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationProvisions to delete
     */
    where?: NotificationProvisionWhereInput
    /**
     * Limit how many NotificationProvisions to delete.
     */
    limit?: number
  }

  /**
   * NotificationProvision without action
   */
  export type NotificationProvisionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProvision
     */
    select?: NotificationProvisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationProvision
     */
    omit?: NotificationProvisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationProvisionInclude<ExtArgs> | null
  }


  /**
   * Model NotificationPermissionEmployee
   */

  export type AggregateNotificationPermissionEmployee = {
    _count: NotificationPermissionEmployeeCountAggregateOutputType | null
    _min: NotificationPermissionEmployeeMinAggregateOutputType | null
    _max: NotificationPermissionEmployeeMaxAggregateOutputType | null
  }

  export type NotificationPermissionEmployeeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    returnProject: boolean | null
    assignNewProject: boolean | null
    projectPublish: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPermissionEmployeeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    returnProject: boolean | null
    assignNewProject: boolean | null
    projectPublish: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPermissionEmployeeCountAggregateOutputType = {
    id: number
    userId: number
    returnProject: number
    assignNewProject: number
    projectPublish: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationPermissionEmployeeMinAggregateInputType = {
    id?: true
    userId?: true
    returnProject?: true
    assignNewProject?: true
    projectPublish?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPermissionEmployeeMaxAggregateInputType = {
    id?: true
    userId?: true
    returnProject?: true
    assignNewProject?: true
    projectPublish?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPermissionEmployeeCountAggregateInputType = {
    id?: true
    userId?: true
    returnProject?: true
    assignNewProject?: true
    projectPublish?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationPermissionEmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPermissionEmployee to aggregate.
     */
    where?: NotificationPermissionEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionEmployees to fetch.
     */
    orderBy?: NotificationPermissionEmployeeOrderByWithRelationInput | NotificationPermissionEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPermissionEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPermissionEmployees
    **/
    _count?: true | NotificationPermissionEmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPermissionEmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPermissionEmployeeMaxAggregateInputType
  }

  export type GetNotificationPermissionEmployeeAggregateType<T extends NotificationPermissionEmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPermissionEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPermissionEmployee[P]>
      : GetScalarType<T[P], AggregateNotificationPermissionEmployee[P]>
  }




  export type NotificationPermissionEmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPermissionEmployeeWhereInput
    orderBy?: NotificationPermissionEmployeeOrderByWithAggregationInput | NotificationPermissionEmployeeOrderByWithAggregationInput[]
    by: NotificationPermissionEmployeeScalarFieldEnum[] | NotificationPermissionEmployeeScalarFieldEnum
    having?: NotificationPermissionEmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPermissionEmployeeCountAggregateInputType | true
    _min?: NotificationPermissionEmployeeMinAggregateInputType
    _max?: NotificationPermissionEmployeeMaxAggregateInputType
  }

  export type NotificationPermissionEmployeeGroupByOutputType = {
    id: string
    userId: string
    returnProject: boolean
    assignNewProject: boolean
    projectPublish: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationPermissionEmployeeCountAggregateOutputType | null
    _min: NotificationPermissionEmployeeMinAggregateOutputType | null
    _max: NotificationPermissionEmployeeMaxAggregateOutputType | null
  }

  type GetNotificationPermissionEmployeeGroupByPayload<T extends NotificationPermissionEmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPermissionEmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPermissionEmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPermissionEmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPermissionEmployeeGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPermissionEmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    returnProject?: boolean
    assignNewProject?: boolean
    projectPublish?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPermissionEmployee"]>

  export type NotificationPermissionEmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    returnProject?: boolean
    assignNewProject?: boolean
    projectPublish?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPermissionEmployee"]>

  export type NotificationPermissionEmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    returnProject?: boolean
    assignNewProject?: boolean
    projectPublish?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPermissionEmployee"]>

  export type NotificationPermissionEmployeeSelectScalar = {
    id?: boolean
    userId?: boolean
    returnProject?: boolean
    assignNewProject?: boolean
    projectPublish?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationPermissionEmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "returnProject" | "assignNewProject" | "projectPublish" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationPermissionEmployee"]>
  export type NotificationPermissionEmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPermissionEmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPermissionEmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPermissionEmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPermissionEmployee"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      returnProject: boolean
      assignNewProject: boolean
      projectPublish: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationPermissionEmployee"]>
    composites: {}
  }

  type NotificationPermissionEmployeeGetPayload<S extends boolean | null | undefined | NotificationPermissionEmployeeDefaultArgs> = $Result.GetResult<Prisma.$NotificationPermissionEmployeePayload, S>

  type NotificationPermissionEmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationPermissionEmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationPermissionEmployeeCountAggregateInputType | true
    }

  export interface NotificationPermissionEmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPermissionEmployee'], meta: { name: 'NotificationPermissionEmployee' } }
    /**
     * Find zero or one NotificationPermissionEmployee that matches the filter.
     * @param {NotificationPermissionEmployeeFindUniqueArgs} args - Arguments to find a NotificationPermissionEmployee
     * @example
     * // Get one NotificationPermissionEmployee
     * const notificationPermissionEmployee = await prisma.notificationPermissionEmployee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPermissionEmployeeFindUniqueArgs>(args: SelectSubset<T, NotificationPermissionEmployeeFindUniqueArgs<ExtArgs>>): Prisma__NotificationPermissionEmployeeClient<$Result.GetResult<Prisma.$NotificationPermissionEmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationPermissionEmployee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationPermissionEmployeeFindUniqueOrThrowArgs} args - Arguments to find a NotificationPermissionEmployee
     * @example
     * // Get one NotificationPermissionEmployee
     * const notificationPermissionEmployee = await prisma.notificationPermissionEmployee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPermissionEmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPermissionEmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPermissionEmployeeClient<$Result.GetResult<Prisma.$NotificationPermissionEmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPermissionEmployee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionEmployeeFindFirstArgs} args - Arguments to find a NotificationPermissionEmployee
     * @example
     * // Get one NotificationPermissionEmployee
     * const notificationPermissionEmployee = await prisma.notificationPermissionEmployee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPermissionEmployeeFindFirstArgs>(args?: SelectSubset<T, NotificationPermissionEmployeeFindFirstArgs<ExtArgs>>): Prisma__NotificationPermissionEmployeeClient<$Result.GetResult<Prisma.$NotificationPermissionEmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPermissionEmployee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionEmployeeFindFirstOrThrowArgs} args - Arguments to find a NotificationPermissionEmployee
     * @example
     * // Get one NotificationPermissionEmployee
     * const notificationPermissionEmployee = await prisma.notificationPermissionEmployee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPermissionEmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPermissionEmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPermissionEmployeeClient<$Result.GetResult<Prisma.$NotificationPermissionEmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationPermissionEmployees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionEmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPermissionEmployees
     * const notificationPermissionEmployees = await prisma.notificationPermissionEmployee.findMany()
     * 
     * // Get first 10 NotificationPermissionEmployees
     * const notificationPermissionEmployees = await prisma.notificationPermissionEmployee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPermissionEmployeeWithIdOnly = await prisma.notificationPermissionEmployee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationPermissionEmployeeFindManyArgs>(args?: SelectSubset<T, NotificationPermissionEmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPermissionEmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationPermissionEmployee.
     * @param {NotificationPermissionEmployeeCreateArgs} args - Arguments to create a NotificationPermissionEmployee.
     * @example
     * // Create one NotificationPermissionEmployee
     * const NotificationPermissionEmployee = await prisma.notificationPermissionEmployee.create({
     *   data: {
     *     // ... data to create a NotificationPermissionEmployee
     *   }
     * })
     * 
     */
    create<T extends NotificationPermissionEmployeeCreateArgs>(args: SelectSubset<T, NotificationPermissionEmployeeCreateArgs<ExtArgs>>): Prisma__NotificationPermissionEmployeeClient<$Result.GetResult<Prisma.$NotificationPermissionEmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationPermissionEmployees.
     * @param {NotificationPermissionEmployeeCreateManyArgs} args - Arguments to create many NotificationPermissionEmployees.
     * @example
     * // Create many NotificationPermissionEmployees
     * const notificationPermissionEmployee = await prisma.notificationPermissionEmployee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPermissionEmployeeCreateManyArgs>(args?: SelectSubset<T, NotificationPermissionEmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPermissionEmployees and returns the data saved in the database.
     * @param {NotificationPermissionEmployeeCreateManyAndReturnArgs} args - Arguments to create many NotificationPermissionEmployees.
     * @example
     * // Create many NotificationPermissionEmployees
     * const notificationPermissionEmployee = await prisma.notificationPermissionEmployee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPermissionEmployees and only return the `id`
     * const notificationPermissionEmployeeWithIdOnly = await prisma.notificationPermissionEmployee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationPermissionEmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationPermissionEmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPermissionEmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationPermissionEmployee.
     * @param {NotificationPermissionEmployeeDeleteArgs} args - Arguments to delete one NotificationPermissionEmployee.
     * @example
     * // Delete one NotificationPermissionEmployee
     * const NotificationPermissionEmployee = await prisma.notificationPermissionEmployee.delete({
     *   where: {
     *     // ... filter to delete one NotificationPermissionEmployee
     *   }
     * })
     * 
     */
    delete<T extends NotificationPermissionEmployeeDeleteArgs>(args: SelectSubset<T, NotificationPermissionEmployeeDeleteArgs<ExtArgs>>): Prisma__NotificationPermissionEmployeeClient<$Result.GetResult<Prisma.$NotificationPermissionEmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationPermissionEmployee.
     * @param {NotificationPermissionEmployeeUpdateArgs} args - Arguments to update one NotificationPermissionEmployee.
     * @example
     * // Update one NotificationPermissionEmployee
     * const notificationPermissionEmployee = await prisma.notificationPermissionEmployee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPermissionEmployeeUpdateArgs>(args: SelectSubset<T, NotificationPermissionEmployeeUpdateArgs<ExtArgs>>): Prisma__NotificationPermissionEmployeeClient<$Result.GetResult<Prisma.$NotificationPermissionEmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationPermissionEmployees.
     * @param {NotificationPermissionEmployeeDeleteManyArgs} args - Arguments to filter NotificationPermissionEmployees to delete.
     * @example
     * // Delete a few NotificationPermissionEmployees
     * const { count } = await prisma.notificationPermissionEmployee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPermissionEmployeeDeleteManyArgs>(args?: SelectSubset<T, NotificationPermissionEmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPermissionEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionEmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPermissionEmployees
     * const notificationPermissionEmployee = await prisma.notificationPermissionEmployee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPermissionEmployeeUpdateManyArgs>(args: SelectSubset<T, NotificationPermissionEmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPermissionEmployees and returns the data updated in the database.
     * @param {NotificationPermissionEmployeeUpdateManyAndReturnArgs} args - Arguments to update many NotificationPermissionEmployees.
     * @example
     * // Update many NotificationPermissionEmployees
     * const notificationPermissionEmployee = await prisma.notificationPermissionEmployee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationPermissionEmployees and only return the `id`
     * const notificationPermissionEmployeeWithIdOnly = await prisma.notificationPermissionEmployee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationPermissionEmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationPermissionEmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPermissionEmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationPermissionEmployee.
     * @param {NotificationPermissionEmployeeUpsertArgs} args - Arguments to update or create a NotificationPermissionEmployee.
     * @example
     * // Update or create a NotificationPermissionEmployee
     * const notificationPermissionEmployee = await prisma.notificationPermissionEmployee.upsert({
     *   create: {
     *     // ... data to create a NotificationPermissionEmployee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPermissionEmployee we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPermissionEmployeeUpsertArgs>(args: SelectSubset<T, NotificationPermissionEmployeeUpsertArgs<ExtArgs>>): Prisma__NotificationPermissionEmployeeClient<$Result.GetResult<Prisma.$NotificationPermissionEmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationPermissionEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionEmployeeCountArgs} args - Arguments to filter NotificationPermissionEmployees to count.
     * @example
     * // Count the number of NotificationPermissionEmployees
     * const count = await prisma.notificationPermissionEmployee.count({
     *   where: {
     *     // ... the filter for the NotificationPermissionEmployees we want to count
     *   }
     * })
    **/
    count<T extends NotificationPermissionEmployeeCountArgs>(
      args?: Subset<T, NotificationPermissionEmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPermissionEmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPermissionEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionEmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPermissionEmployeeAggregateArgs>(args: Subset<T, NotificationPermissionEmployeeAggregateArgs>): Prisma.PrismaPromise<GetNotificationPermissionEmployeeAggregateType<T>>

    /**
     * Group by NotificationPermissionEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionEmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPermissionEmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPermissionEmployeeGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPermissionEmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPermissionEmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPermissionEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPermissionEmployee model
   */
  readonly fields: NotificationPermissionEmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPermissionEmployee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPermissionEmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPermissionEmployee model
   */
  interface NotificationPermissionEmployeeFieldRefs {
    readonly id: FieldRef<"NotificationPermissionEmployee", 'String'>
    readonly userId: FieldRef<"NotificationPermissionEmployee", 'String'>
    readonly returnProject: FieldRef<"NotificationPermissionEmployee", 'Boolean'>
    readonly assignNewProject: FieldRef<"NotificationPermissionEmployee", 'Boolean'>
    readonly projectPublish: FieldRef<"NotificationPermissionEmployee", 'Boolean'>
    readonly createdAt: FieldRef<"NotificationPermissionEmployee", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationPermissionEmployee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPermissionEmployee findUnique
   */
  export type NotificationPermissionEmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionEmployee
     */
    select?: NotificationPermissionEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionEmployee
     */
    omit?: NotificationPermissionEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionEmployee to fetch.
     */
    where: NotificationPermissionEmployeeWhereUniqueInput
  }

  /**
   * NotificationPermissionEmployee findUniqueOrThrow
   */
  export type NotificationPermissionEmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionEmployee
     */
    select?: NotificationPermissionEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionEmployee
     */
    omit?: NotificationPermissionEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionEmployee to fetch.
     */
    where: NotificationPermissionEmployeeWhereUniqueInput
  }

  /**
   * NotificationPermissionEmployee findFirst
   */
  export type NotificationPermissionEmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionEmployee
     */
    select?: NotificationPermissionEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionEmployee
     */
    omit?: NotificationPermissionEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionEmployee to fetch.
     */
    where?: NotificationPermissionEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionEmployees to fetch.
     */
    orderBy?: NotificationPermissionEmployeeOrderByWithRelationInput | NotificationPermissionEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPermissionEmployees.
     */
    cursor?: NotificationPermissionEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPermissionEmployees.
     */
    distinct?: NotificationPermissionEmployeeScalarFieldEnum | NotificationPermissionEmployeeScalarFieldEnum[]
  }

  /**
   * NotificationPermissionEmployee findFirstOrThrow
   */
  export type NotificationPermissionEmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionEmployee
     */
    select?: NotificationPermissionEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionEmployee
     */
    omit?: NotificationPermissionEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionEmployee to fetch.
     */
    where?: NotificationPermissionEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionEmployees to fetch.
     */
    orderBy?: NotificationPermissionEmployeeOrderByWithRelationInput | NotificationPermissionEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPermissionEmployees.
     */
    cursor?: NotificationPermissionEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPermissionEmployees.
     */
    distinct?: NotificationPermissionEmployeeScalarFieldEnum | NotificationPermissionEmployeeScalarFieldEnum[]
  }

  /**
   * NotificationPermissionEmployee findMany
   */
  export type NotificationPermissionEmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionEmployee
     */
    select?: NotificationPermissionEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionEmployee
     */
    omit?: NotificationPermissionEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionEmployees to fetch.
     */
    where?: NotificationPermissionEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionEmployees to fetch.
     */
    orderBy?: NotificationPermissionEmployeeOrderByWithRelationInput | NotificationPermissionEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPermissionEmployees.
     */
    cursor?: NotificationPermissionEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionEmployees.
     */
    skip?: number
    distinct?: NotificationPermissionEmployeeScalarFieldEnum | NotificationPermissionEmployeeScalarFieldEnum[]
  }

  /**
   * NotificationPermissionEmployee create
   */
  export type NotificationPermissionEmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionEmployee
     */
    select?: NotificationPermissionEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionEmployee
     */
    omit?: NotificationPermissionEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionEmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPermissionEmployee.
     */
    data: XOR<NotificationPermissionEmployeeCreateInput, NotificationPermissionEmployeeUncheckedCreateInput>
  }

  /**
   * NotificationPermissionEmployee createMany
   */
  export type NotificationPermissionEmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPermissionEmployees.
     */
    data: NotificationPermissionEmployeeCreateManyInput | NotificationPermissionEmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationPermissionEmployee createManyAndReturn
   */
  export type NotificationPermissionEmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionEmployee
     */
    select?: NotificationPermissionEmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionEmployee
     */
    omit?: NotificationPermissionEmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationPermissionEmployees.
     */
    data: NotificationPermissionEmployeeCreateManyInput | NotificationPermissionEmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionEmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPermissionEmployee update
   */
  export type NotificationPermissionEmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionEmployee
     */
    select?: NotificationPermissionEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionEmployee
     */
    omit?: NotificationPermissionEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionEmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPermissionEmployee.
     */
    data: XOR<NotificationPermissionEmployeeUpdateInput, NotificationPermissionEmployeeUncheckedUpdateInput>
    /**
     * Choose, which NotificationPermissionEmployee to update.
     */
    where: NotificationPermissionEmployeeWhereUniqueInput
  }

  /**
   * NotificationPermissionEmployee updateMany
   */
  export type NotificationPermissionEmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPermissionEmployees.
     */
    data: XOR<NotificationPermissionEmployeeUpdateManyMutationInput, NotificationPermissionEmployeeUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPermissionEmployees to update
     */
    where?: NotificationPermissionEmployeeWhereInput
    /**
     * Limit how many NotificationPermissionEmployees to update.
     */
    limit?: number
  }

  /**
   * NotificationPermissionEmployee updateManyAndReturn
   */
  export type NotificationPermissionEmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionEmployee
     */
    select?: NotificationPermissionEmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionEmployee
     */
    omit?: NotificationPermissionEmployeeOmit<ExtArgs> | null
    /**
     * The data used to update NotificationPermissionEmployees.
     */
    data: XOR<NotificationPermissionEmployeeUpdateManyMutationInput, NotificationPermissionEmployeeUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPermissionEmployees to update
     */
    where?: NotificationPermissionEmployeeWhereInput
    /**
     * Limit how many NotificationPermissionEmployees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionEmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPermissionEmployee upsert
   */
  export type NotificationPermissionEmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionEmployee
     */
    select?: NotificationPermissionEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionEmployee
     */
    omit?: NotificationPermissionEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionEmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPermissionEmployee to update in case it exists.
     */
    where: NotificationPermissionEmployeeWhereUniqueInput
    /**
     * In case the NotificationPermissionEmployee found by the `where` argument doesn't exist, create a new NotificationPermissionEmployee with this data.
     */
    create: XOR<NotificationPermissionEmployeeCreateInput, NotificationPermissionEmployeeUncheckedCreateInput>
    /**
     * In case the NotificationPermissionEmployee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPermissionEmployeeUpdateInput, NotificationPermissionEmployeeUncheckedUpdateInput>
  }

  /**
   * NotificationPermissionEmployee delete
   */
  export type NotificationPermissionEmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionEmployee
     */
    select?: NotificationPermissionEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionEmployee
     */
    omit?: NotificationPermissionEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionEmployeeInclude<ExtArgs> | null
    /**
     * Filter which NotificationPermissionEmployee to delete.
     */
    where: NotificationPermissionEmployeeWhereUniqueInput
  }

  /**
   * NotificationPermissionEmployee deleteMany
   */
  export type NotificationPermissionEmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPermissionEmployees to delete
     */
    where?: NotificationPermissionEmployeeWhereInput
    /**
     * Limit how many NotificationPermissionEmployees to delete.
     */
    limit?: number
  }

  /**
   * NotificationPermissionEmployee without action
   */
  export type NotificationPermissionEmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionEmployee
     */
    select?: NotificationPermissionEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionEmployee
     */
    omit?: NotificationPermissionEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionEmployeeInclude<ExtArgs> | null
  }


  /**
   * Model NotificationPermissionManager
   */

  export type AggregateNotificationPermissionManager = {
    _count: NotificationPermissionManagerCountAggregateOutputType | null
    _min: NotificationPermissionManagerMinAggregateOutputType | null
    _max: NotificationPermissionManagerMaxAggregateOutputType | null
  }

  export type NotificationPermissionManagerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    fileImportByEmployees: boolean | null
    weeklySummary: boolean | null
    createNewProject: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPermissionManagerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    fileImportByEmployees: boolean | null
    weeklySummary: boolean | null
    createNewProject: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPermissionManagerCountAggregateOutputType = {
    id: number
    userId: number
    fileImportByEmployees: number
    weeklySummary: number
    createNewProject: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationPermissionManagerMinAggregateInputType = {
    id?: true
    userId?: true
    fileImportByEmployees?: true
    weeklySummary?: true
    createNewProject?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPermissionManagerMaxAggregateInputType = {
    id?: true
    userId?: true
    fileImportByEmployees?: true
    weeklySummary?: true
    createNewProject?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPermissionManagerCountAggregateInputType = {
    id?: true
    userId?: true
    fileImportByEmployees?: true
    weeklySummary?: true
    createNewProject?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationPermissionManagerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPermissionManager to aggregate.
     */
    where?: NotificationPermissionManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionManagers to fetch.
     */
    orderBy?: NotificationPermissionManagerOrderByWithRelationInput | NotificationPermissionManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPermissionManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPermissionManagers
    **/
    _count?: true | NotificationPermissionManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPermissionManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPermissionManagerMaxAggregateInputType
  }

  export type GetNotificationPermissionManagerAggregateType<T extends NotificationPermissionManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPermissionManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPermissionManager[P]>
      : GetScalarType<T[P], AggregateNotificationPermissionManager[P]>
  }




  export type NotificationPermissionManagerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPermissionManagerWhereInput
    orderBy?: NotificationPermissionManagerOrderByWithAggregationInput | NotificationPermissionManagerOrderByWithAggregationInput[]
    by: NotificationPermissionManagerScalarFieldEnum[] | NotificationPermissionManagerScalarFieldEnum
    having?: NotificationPermissionManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPermissionManagerCountAggregateInputType | true
    _min?: NotificationPermissionManagerMinAggregateInputType
    _max?: NotificationPermissionManagerMaxAggregateInputType
  }

  export type NotificationPermissionManagerGroupByOutputType = {
    id: string
    userId: string
    fileImportByEmployees: boolean
    weeklySummary: boolean
    createNewProject: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationPermissionManagerCountAggregateOutputType | null
    _min: NotificationPermissionManagerMinAggregateOutputType | null
    _max: NotificationPermissionManagerMaxAggregateOutputType | null
  }

  type GetNotificationPermissionManagerGroupByPayload<T extends NotificationPermissionManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPermissionManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPermissionManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPermissionManagerGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPermissionManagerGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPermissionManagerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fileImportByEmployees?: boolean
    weeklySummary?: boolean
    createNewProject?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPermissionManager"]>

  export type NotificationPermissionManagerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fileImportByEmployees?: boolean
    weeklySummary?: boolean
    createNewProject?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPermissionManager"]>

  export type NotificationPermissionManagerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fileImportByEmployees?: boolean
    weeklySummary?: boolean
    createNewProject?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPermissionManager"]>

  export type NotificationPermissionManagerSelectScalar = {
    id?: boolean
    userId?: boolean
    fileImportByEmployees?: boolean
    weeklySummary?: boolean
    createNewProject?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationPermissionManagerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "fileImportByEmployees" | "weeklySummary" | "createNewProject" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationPermissionManager"]>
  export type NotificationPermissionManagerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPermissionManagerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPermissionManagerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPermissionManagerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPermissionManager"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      fileImportByEmployees: boolean
      weeklySummary: boolean
      createNewProject: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationPermissionManager"]>
    composites: {}
  }

  type NotificationPermissionManagerGetPayload<S extends boolean | null | undefined | NotificationPermissionManagerDefaultArgs> = $Result.GetResult<Prisma.$NotificationPermissionManagerPayload, S>

  type NotificationPermissionManagerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationPermissionManagerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationPermissionManagerCountAggregateInputType | true
    }

  export interface NotificationPermissionManagerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPermissionManager'], meta: { name: 'NotificationPermissionManager' } }
    /**
     * Find zero or one NotificationPermissionManager that matches the filter.
     * @param {NotificationPermissionManagerFindUniqueArgs} args - Arguments to find a NotificationPermissionManager
     * @example
     * // Get one NotificationPermissionManager
     * const notificationPermissionManager = await prisma.notificationPermissionManager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPermissionManagerFindUniqueArgs>(args: SelectSubset<T, NotificationPermissionManagerFindUniqueArgs<ExtArgs>>): Prisma__NotificationPermissionManagerClient<$Result.GetResult<Prisma.$NotificationPermissionManagerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationPermissionManager that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationPermissionManagerFindUniqueOrThrowArgs} args - Arguments to find a NotificationPermissionManager
     * @example
     * // Get one NotificationPermissionManager
     * const notificationPermissionManager = await prisma.notificationPermissionManager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPermissionManagerFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPermissionManagerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPermissionManagerClient<$Result.GetResult<Prisma.$NotificationPermissionManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPermissionManager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionManagerFindFirstArgs} args - Arguments to find a NotificationPermissionManager
     * @example
     * // Get one NotificationPermissionManager
     * const notificationPermissionManager = await prisma.notificationPermissionManager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPermissionManagerFindFirstArgs>(args?: SelectSubset<T, NotificationPermissionManagerFindFirstArgs<ExtArgs>>): Prisma__NotificationPermissionManagerClient<$Result.GetResult<Prisma.$NotificationPermissionManagerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPermissionManager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionManagerFindFirstOrThrowArgs} args - Arguments to find a NotificationPermissionManager
     * @example
     * // Get one NotificationPermissionManager
     * const notificationPermissionManager = await prisma.notificationPermissionManager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPermissionManagerFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPermissionManagerFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPermissionManagerClient<$Result.GetResult<Prisma.$NotificationPermissionManagerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationPermissionManagers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionManagerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPermissionManagers
     * const notificationPermissionManagers = await prisma.notificationPermissionManager.findMany()
     * 
     * // Get first 10 NotificationPermissionManagers
     * const notificationPermissionManagers = await prisma.notificationPermissionManager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPermissionManagerWithIdOnly = await prisma.notificationPermissionManager.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationPermissionManagerFindManyArgs>(args?: SelectSubset<T, NotificationPermissionManagerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPermissionManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationPermissionManager.
     * @param {NotificationPermissionManagerCreateArgs} args - Arguments to create a NotificationPermissionManager.
     * @example
     * // Create one NotificationPermissionManager
     * const NotificationPermissionManager = await prisma.notificationPermissionManager.create({
     *   data: {
     *     // ... data to create a NotificationPermissionManager
     *   }
     * })
     * 
     */
    create<T extends NotificationPermissionManagerCreateArgs>(args: SelectSubset<T, NotificationPermissionManagerCreateArgs<ExtArgs>>): Prisma__NotificationPermissionManagerClient<$Result.GetResult<Prisma.$NotificationPermissionManagerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationPermissionManagers.
     * @param {NotificationPermissionManagerCreateManyArgs} args - Arguments to create many NotificationPermissionManagers.
     * @example
     * // Create many NotificationPermissionManagers
     * const notificationPermissionManager = await prisma.notificationPermissionManager.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPermissionManagerCreateManyArgs>(args?: SelectSubset<T, NotificationPermissionManagerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPermissionManagers and returns the data saved in the database.
     * @param {NotificationPermissionManagerCreateManyAndReturnArgs} args - Arguments to create many NotificationPermissionManagers.
     * @example
     * // Create many NotificationPermissionManagers
     * const notificationPermissionManager = await prisma.notificationPermissionManager.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPermissionManagers and only return the `id`
     * const notificationPermissionManagerWithIdOnly = await prisma.notificationPermissionManager.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationPermissionManagerCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationPermissionManagerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPermissionManagerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationPermissionManager.
     * @param {NotificationPermissionManagerDeleteArgs} args - Arguments to delete one NotificationPermissionManager.
     * @example
     * // Delete one NotificationPermissionManager
     * const NotificationPermissionManager = await prisma.notificationPermissionManager.delete({
     *   where: {
     *     // ... filter to delete one NotificationPermissionManager
     *   }
     * })
     * 
     */
    delete<T extends NotificationPermissionManagerDeleteArgs>(args: SelectSubset<T, NotificationPermissionManagerDeleteArgs<ExtArgs>>): Prisma__NotificationPermissionManagerClient<$Result.GetResult<Prisma.$NotificationPermissionManagerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationPermissionManager.
     * @param {NotificationPermissionManagerUpdateArgs} args - Arguments to update one NotificationPermissionManager.
     * @example
     * // Update one NotificationPermissionManager
     * const notificationPermissionManager = await prisma.notificationPermissionManager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPermissionManagerUpdateArgs>(args: SelectSubset<T, NotificationPermissionManagerUpdateArgs<ExtArgs>>): Prisma__NotificationPermissionManagerClient<$Result.GetResult<Prisma.$NotificationPermissionManagerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationPermissionManagers.
     * @param {NotificationPermissionManagerDeleteManyArgs} args - Arguments to filter NotificationPermissionManagers to delete.
     * @example
     * // Delete a few NotificationPermissionManagers
     * const { count } = await prisma.notificationPermissionManager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPermissionManagerDeleteManyArgs>(args?: SelectSubset<T, NotificationPermissionManagerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPermissionManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPermissionManagers
     * const notificationPermissionManager = await prisma.notificationPermissionManager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPermissionManagerUpdateManyArgs>(args: SelectSubset<T, NotificationPermissionManagerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPermissionManagers and returns the data updated in the database.
     * @param {NotificationPermissionManagerUpdateManyAndReturnArgs} args - Arguments to update many NotificationPermissionManagers.
     * @example
     * // Update many NotificationPermissionManagers
     * const notificationPermissionManager = await prisma.notificationPermissionManager.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationPermissionManagers and only return the `id`
     * const notificationPermissionManagerWithIdOnly = await prisma.notificationPermissionManager.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationPermissionManagerUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationPermissionManagerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPermissionManagerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationPermissionManager.
     * @param {NotificationPermissionManagerUpsertArgs} args - Arguments to update or create a NotificationPermissionManager.
     * @example
     * // Update or create a NotificationPermissionManager
     * const notificationPermissionManager = await prisma.notificationPermissionManager.upsert({
     *   create: {
     *     // ... data to create a NotificationPermissionManager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPermissionManager we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPermissionManagerUpsertArgs>(args: SelectSubset<T, NotificationPermissionManagerUpsertArgs<ExtArgs>>): Prisma__NotificationPermissionManagerClient<$Result.GetResult<Prisma.$NotificationPermissionManagerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationPermissionManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionManagerCountArgs} args - Arguments to filter NotificationPermissionManagers to count.
     * @example
     * // Count the number of NotificationPermissionManagers
     * const count = await prisma.notificationPermissionManager.count({
     *   where: {
     *     // ... the filter for the NotificationPermissionManagers we want to count
     *   }
     * })
    **/
    count<T extends NotificationPermissionManagerCountArgs>(
      args?: Subset<T, NotificationPermissionManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPermissionManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPermissionManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPermissionManagerAggregateArgs>(args: Subset<T, NotificationPermissionManagerAggregateArgs>): Prisma.PrismaPromise<GetNotificationPermissionManagerAggregateType<T>>

    /**
     * Group by NotificationPermissionManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPermissionManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPermissionManagerGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPermissionManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPermissionManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPermissionManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPermissionManager model
   */
  readonly fields: NotificationPermissionManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPermissionManager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPermissionManagerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPermissionManager model
   */
  interface NotificationPermissionManagerFieldRefs {
    readonly id: FieldRef<"NotificationPermissionManager", 'String'>
    readonly userId: FieldRef<"NotificationPermissionManager", 'String'>
    readonly fileImportByEmployees: FieldRef<"NotificationPermissionManager", 'Boolean'>
    readonly weeklySummary: FieldRef<"NotificationPermissionManager", 'Boolean'>
    readonly createNewProject: FieldRef<"NotificationPermissionManager", 'Boolean'>
    readonly createdAt: FieldRef<"NotificationPermissionManager", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationPermissionManager", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPermissionManager findUnique
   */
  export type NotificationPermissionManagerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionManager
     */
    select?: NotificationPermissionManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionManager
     */
    omit?: NotificationPermissionManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionManagerInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionManager to fetch.
     */
    where: NotificationPermissionManagerWhereUniqueInput
  }

  /**
   * NotificationPermissionManager findUniqueOrThrow
   */
  export type NotificationPermissionManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionManager
     */
    select?: NotificationPermissionManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionManager
     */
    omit?: NotificationPermissionManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionManagerInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionManager to fetch.
     */
    where: NotificationPermissionManagerWhereUniqueInput
  }

  /**
   * NotificationPermissionManager findFirst
   */
  export type NotificationPermissionManagerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionManager
     */
    select?: NotificationPermissionManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionManager
     */
    omit?: NotificationPermissionManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionManagerInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionManager to fetch.
     */
    where?: NotificationPermissionManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionManagers to fetch.
     */
    orderBy?: NotificationPermissionManagerOrderByWithRelationInput | NotificationPermissionManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPermissionManagers.
     */
    cursor?: NotificationPermissionManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPermissionManagers.
     */
    distinct?: NotificationPermissionManagerScalarFieldEnum | NotificationPermissionManagerScalarFieldEnum[]
  }

  /**
   * NotificationPermissionManager findFirstOrThrow
   */
  export type NotificationPermissionManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionManager
     */
    select?: NotificationPermissionManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionManager
     */
    omit?: NotificationPermissionManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionManagerInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionManager to fetch.
     */
    where?: NotificationPermissionManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionManagers to fetch.
     */
    orderBy?: NotificationPermissionManagerOrderByWithRelationInput | NotificationPermissionManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPermissionManagers.
     */
    cursor?: NotificationPermissionManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPermissionManagers.
     */
    distinct?: NotificationPermissionManagerScalarFieldEnum | NotificationPermissionManagerScalarFieldEnum[]
  }

  /**
   * NotificationPermissionManager findMany
   */
  export type NotificationPermissionManagerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionManager
     */
    select?: NotificationPermissionManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionManager
     */
    omit?: NotificationPermissionManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionManagerInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionManagers to fetch.
     */
    where?: NotificationPermissionManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionManagers to fetch.
     */
    orderBy?: NotificationPermissionManagerOrderByWithRelationInput | NotificationPermissionManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPermissionManagers.
     */
    cursor?: NotificationPermissionManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionManagers.
     */
    skip?: number
    distinct?: NotificationPermissionManagerScalarFieldEnum | NotificationPermissionManagerScalarFieldEnum[]
  }

  /**
   * NotificationPermissionManager create
   */
  export type NotificationPermissionManagerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionManager
     */
    select?: NotificationPermissionManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionManager
     */
    omit?: NotificationPermissionManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionManagerInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPermissionManager.
     */
    data: XOR<NotificationPermissionManagerCreateInput, NotificationPermissionManagerUncheckedCreateInput>
  }

  /**
   * NotificationPermissionManager createMany
   */
  export type NotificationPermissionManagerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPermissionManagers.
     */
    data: NotificationPermissionManagerCreateManyInput | NotificationPermissionManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationPermissionManager createManyAndReturn
   */
  export type NotificationPermissionManagerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionManager
     */
    select?: NotificationPermissionManagerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionManager
     */
    omit?: NotificationPermissionManagerOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationPermissionManagers.
     */
    data: NotificationPermissionManagerCreateManyInput | NotificationPermissionManagerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionManagerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPermissionManager update
   */
  export type NotificationPermissionManagerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionManager
     */
    select?: NotificationPermissionManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionManager
     */
    omit?: NotificationPermissionManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionManagerInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPermissionManager.
     */
    data: XOR<NotificationPermissionManagerUpdateInput, NotificationPermissionManagerUncheckedUpdateInput>
    /**
     * Choose, which NotificationPermissionManager to update.
     */
    where: NotificationPermissionManagerWhereUniqueInput
  }

  /**
   * NotificationPermissionManager updateMany
   */
  export type NotificationPermissionManagerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPermissionManagers.
     */
    data: XOR<NotificationPermissionManagerUpdateManyMutationInput, NotificationPermissionManagerUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPermissionManagers to update
     */
    where?: NotificationPermissionManagerWhereInput
    /**
     * Limit how many NotificationPermissionManagers to update.
     */
    limit?: number
  }

  /**
   * NotificationPermissionManager updateManyAndReturn
   */
  export type NotificationPermissionManagerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionManager
     */
    select?: NotificationPermissionManagerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionManager
     */
    omit?: NotificationPermissionManagerOmit<ExtArgs> | null
    /**
     * The data used to update NotificationPermissionManagers.
     */
    data: XOR<NotificationPermissionManagerUpdateManyMutationInput, NotificationPermissionManagerUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPermissionManagers to update
     */
    where?: NotificationPermissionManagerWhereInput
    /**
     * Limit how many NotificationPermissionManagers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionManagerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPermissionManager upsert
   */
  export type NotificationPermissionManagerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionManager
     */
    select?: NotificationPermissionManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionManager
     */
    omit?: NotificationPermissionManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionManagerInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPermissionManager to update in case it exists.
     */
    where: NotificationPermissionManagerWhereUniqueInput
    /**
     * In case the NotificationPermissionManager found by the `where` argument doesn't exist, create a new NotificationPermissionManager with this data.
     */
    create: XOR<NotificationPermissionManagerCreateInput, NotificationPermissionManagerUncheckedCreateInput>
    /**
     * In case the NotificationPermissionManager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPermissionManagerUpdateInput, NotificationPermissionManagerUncheckedUpdateInput>
  }

  /**
   * NotificationPermissionManager delete
   */
  export type NotificationPermissionManagerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionManager
     */
    select?: NotificationPermissionManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionManager
     */
    omit?: NotificationPermissionManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionManagerInclude<ExtArgs> | null
    /**
     * Filter which NotificationPermissionManager to delete.
     */
    where: NotificationPermissionManagerWhereUniqueInput
  }

  /**
   * NotificationPermissionManager deleteMany
   */
  export type NotificationPermissionManagerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPermissionManagers to delete
     */
    where?: NotificationPermissionManagerWhereInput
    /**
     * Limit how many NotificationPermissionManagers to delete.
     */
    limit?: number
  }

  /**
   * NotificationPermissionManager without action
   */
  export type NotificationPermissionManagerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionManager
     */
    select?: NotificationPermissionManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionManager
     */
    omit?: NotificationPermissionManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionManagerInclude<ExtArgs> | null
  }


  /**
   * Model NotificationPermissionClient
   */

  export type AggregateNotificationPermissionClient = {
    _count: NotificationPermissionClientCountAggregateOutputType | null
    _min: NotificationPermissionClientMinAggregateOutputType | null
    _max: NotificationPermissionClientMaxAggregateOutputType | null
  }

  export type NotificationPermissionClientMinAggregateOutputType = {
    id: string | null
    userId: string | null
    onProjectApproval: boolean | null
    onProjectRejection: boolean | null
    fileImportByEmployees: boolean | null
    weeklySummary: boolean | null
    storageLimit: boolean | null
    billPayment: boolean | null
    overdueProject: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPermissionClientMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    onProjectApproval: boolean | null
    onProjectRejection: boolean | null
    fileImportByEmployees: boolean | null
    weeklySummary: boolean | null
    storageLimit: boolean | null
    billPayment: boolean | null
    overdueProject: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPermissionClientCountAggregateOutputType = {
    id: number
    userId: number
    onProjectApproval: number
    onProjectRejection: number
    fileImportByEmployees: number
    weeklySummary: number
    storageLimit: number
    billPayment: number
    overdueProject: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationPermissionClientMinAggregateInputType = {
    id?: true
    userId?: true
    onProjectApproval?: true
    onProjectRejection?: true
    fileImportByEmployees?: true
    weeklySummary?: true
    storageLimit?: true
    billPayment?: true
    overdueProject?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPermissionClientMaxAggregateInputType = {
    id?: true
    userId?: true
    onProjectApproval?: true
    onProjectRejection?: true
    fileImportByEmployees?: true
    weeklySummary?: true
    storageLimit?: true
    billPayment?: true
    overdueProject?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPermissionClientCountAggregateInputType = {
    id?: true
    userId?: true
    onProjectApproval?: true
    onProjectRejection?: true
    fileImportByEmployees?: true
    weeklySummary?: true
    storageLimit?: true
    billPayment?: true
    overdueProject?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationPermissionClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPermissionClient to aggregate.
     */
    where?: NotificationPermissionClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionClients to fetch.
     */
    orderBy?: NotificationPermissionClientOrderByWithRelationInput | NotificationPermissionClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPermissionClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPermissionClients
    **/
    _count?: true | NotificationPermissionClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPermissionClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPermissionClientMaxAggregateInputType
  }

  export type GetNotificationPermissionClientAggregateType<T extends NotificationPermissionClientAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPermissionClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPermissionClient[P]>
      : GetScalarType<T[P], AggregateNotificationPermissionClient[P]>
  }




  export type NotificationPermissionClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPermissionClientWhereInput
    orderBy?: NotificationPermissionClientOrderByWithAggregationInput | NotificationPermissionClientOrderByWithAggregationInput[]
    by: NotificationPermissionClientScalarFieldEnum[] | NotificationPermissionClientScalarFieldEnum
    having?: NotificationPermissionClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPermissionClientCountAggregateInputType | true
    _min?: NotificationPermissionClientMinAggregateInputType
    _max?: NotificationPermissionClientMaxAggregateInputType
  }

  export type NotificationPermissionClientGroupByOutputType = {
    id: string
    userId: string
    onProjectApproval: boolean
    onProjectRejection: boolean
    fileImportByEmployees: boolean
    weeklySummary: boolean
    storageLimit: boolean
    billPayment: boolean
    overdueProject: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationPermissionClientCountAggregateOutputType | null
    _min: NotificationPermissionClientMinAggregateOutputType | null
    _max: NotificationPermissionClientMaxAggregateOutputType | null
  }

  type GetNotificationPermissionClientGroupByPayload<T extends NotificationPermissionClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPermissionClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPermissionClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPermissionClientGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPermissionClientGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPermissionClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    onProjectApproval?: boolean
    onProjectRejection?: boolean
    fileImportByEmployees?: boolean
    weeklySummary?: boolean
    storageLimit?: boolean
    billPayment?: boolean
    overdueProject?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPermissionClient"]>

  export type NotificationPermissionClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    onProjectApproval?: boolean
    onProjectRejection?: boolean
    fileImportByEmployees?: boolean
    weeklySummary?: boolean
    storageLimit?: boolean
    billPayment?: boolean
    overdueProject?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPermissionClient"]>

  export type NotificationPermissionClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    onProjectApproval?: boolean
    onProjectRejection?: boolean
    fileImportByEmployees?: boolean
    weeklySummary?: boolean
    storageLimit?: boolean
    billPayment?: boolean
    overdueProject?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPermissionClient"]>

  export type NotificationPermissionClientSelectScalar = {
    id?: boolean
    userId?: boolean
    onProjectApproval?: boolean
    onProjectRejection?: boolean
    fileImportByEmployees?: boolean
    weeklySummary?: boolean
    storageLimit?: boolean
    billPayment?: boolean
    overdueProject?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationPermissionClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "onProjectApproval" | "onProjectRejection" | "fileImportByEmployees" | "weeklySummary" | "storageLimit" | "billPayment" | "overdueProject" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationPermissionClient"]>
  export type NotificationPermissionClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPermissionClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPermissionClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPermissionClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPermissionClient"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      onProjectApproval: boolean
      onProjectRejection: boolean
      fileImportByEmployees: boolean
      weeklySummary: boolean
      storageLimit: boolean
      billPayment: boolean
      overdueProject: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationPermissionClient"]>
    composites: {}
  }

  type NotificationPermissionClientGetPayload<S extends boolean | null | undefined | NotificationPermissionClientDefaultArgs> = $Result.GetResult<Prisma.$NotificationPermissionClientPayload, S>

  type NotificationPermissionClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationPermissionClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationPermissionClientCountAggregateInputType | true
    }

  export interface NotificationPermissionClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPermissionClient'], meta: { name: 'NotificationPermissionClient' } }
    /**
     * Find zero or one NotificationPermissionClient that matches the filter.
     * @param {NotificationPermissionClientFindUniqueArgs} args - Arguments to find a NotificationPermissionClient
     * @example
     * // Get one NotificationPermissionClient
     * const notificationPermissionClient = await prisma.notificationPermissionClient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPermissionClientFindUniqueArgs>(args: SelectSubset<T, NotificationPermissionClientFindUniqueArgs<ExtArgs>>): Prisma__NotificationPermissionClientClient<$Result.GetResult<Prisma.$NotificationPermissionClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationPermissionClient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationPermissionClientFindUniqueOrThrowArgs} args - Arguments to find a NotificationPermissionClient
     * @example
     * // Get one NotificationPermissionClient
     * const notificationPermissionClient = await prisma.notificationPermissionClient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPermissionClientFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPermissionClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPermissionClientClient<$Result.GetResult<Prisma.$NotificationPermissionClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPermissionClient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionClientFindFirstArgs} args - Arguments to find a NotificationPermissionClient
     * @example
     * // Get one NotificationPermissionClient
     * const notificationPermissionClient = await prisma.notificationPermissionClient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPermissionClientFindFirstArgs>(args?: SelectSubset<T, NotificationPermissionClientFindFirstArgs<ExtArgs>>): Prisma__NotificationPermissionClientClient<$Result.GetResult<Prisma.$NotificationPermissionClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPermissionClient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionClientFindFirstOrThrowArgs} args - Arguments to find a NotificationPermissionClient
     * @example
     * // Get one NotificationPermissionClient
     * const notificationPermissionClient = await prisma.notificationPermissionClient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPermissionClientFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPermissionClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPermissionClientClient<$Result.GetResult<Prisma.$NotificationPermissionClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationPermissionClients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPermissionClients
     * const notificationPermissionClients = await prisma.notificationPermissionClient.findMany()
     * 
     * // Get first 10 NotificationPermissionClients
     * const notificationPermissionClients = await prisma.notificationPermissionClient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPermissionClientWithIdOnly = await prisma.notificationPermissionClient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationPermissionClientFindManyArgs>(args?: SelectSubset<T, NotificationPermissionClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPermissionClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationPermissionClient.
     * @param {NotificationPermissionClientCreateArgs} args - Arguments to create a NotificationPermissionClient.
     * @example
     * // Create one NotificationPermissionClient
     * const NotificationPermissionClient = await prisma.notificationPermissionClient.create({
     *   data: {
     *     // ... data to create a NotificationPermissionClient
     *   }
     * })
     * 
     */
    create<T extends NotificationPermissionClientCreateArgs>(args: SelectSubset<T, NotificationPermissionClientCreateArgs<ExtArgs>>): Prisma__NotificationPermissionClientClient<$Result.GetResult<Prisma.$NotificationPermissionClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationPermissionClients.
     * @param {NotificationPermissionClientCreateManyArgs} args - Arguments to create many NotificationPermissionClients.
     * @example
     * // Create many NotificationPermissionClients
     * const notificationPermissionClient = await prisma.notificationPermissionClient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPermissionClientCreateManyArgs>(args?: SelectSubset<T, NotificationPermissionClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPermissionClients and returns the data saved in the database.
     * @param {NotificationPermissionClientCreateManyAndReturnArgs} args - Arguments to create many NotificationPermissionClients.
     * @example
     * // Create many NotificationPermissionClients
     * const notificationPermissionClient = await prisma.notificationPermissionClient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPermissionClients and only return the `id`
     * const notificationPermissionClientWithIdOnly = await prisma.notificationPermissionClient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationPermissionClientCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationPermissionClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPermissionClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationPermissionClient.
     * @param {NotificationPermissionClientDeleteArgs} args - Arguments to delete one NotificationPermissionClient.
     * @example
     * // Delete one NotificationPermissionClient
     * const NotificationPermissionClient = await prisma.notificationPermissionClient.delete({
     *   where: {
     *     // ... filter to delete one NotificationPermissionClient
     *   }
     * })
     * 
     */
    delete<T extends NotificationPermissionClientDeleteArgs>(args: SelectSubset<T, NotificationPermissionClientDeleteArgs<ExtArgs>>): Prisma__NotificationPermissionClientClient<$Result.GetResult<Prisma.$NotificationPermissionClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationPermissionClient.
     * @param {NotificationPermissionClientUpdateArgs} args - Arguments to update one NotificationPermissionClient.
     * @example
     * // Update one NotificationPermissionClient
     * const notificationPermissionClient = await prisma.notificationPermissionClient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPermissionClientUpdateArgs>(args: SelectSubset<T, NotificationPermissionClientUpdateArgs<ExtArgs>>): Prisma__NotificationPermissionClientClient<$Result.GetResult<Prisma.$NotificationPermissionClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationPermissionClients.
     * @param {NotificationPermissionClientDeleteManyArgs} args - Arguments to filter NotificationPermissionClients to delete.
     * @example
     * // Delete a few NotificationPermissionClients
     * const { count } = await prisma.notificationPermissionClient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPermissionClientDeleteManyArgs>(args?: SelectSubset<T, NotificationPermissionClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPermissionClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPermissionClients
     * const notificationPermissionClient = await prisma.notificationPermissionClient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPermissionClientUpdateManyArgs>(args: SelectSubset<T, NotificationPermissionClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPermissionClients and returns the data updated in the database.
     * @param {NotificationPermissionClientUpdateManyAndReturnArgs} args - Arguments to update many NotificationPermissionClients.
     * @example
     * // Update many NotificationPermissionClients
     * const notificationPermissionClient = await prisma.notificationPermissionClient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationPermissionClients and only return the `id`
     * const notificationPermissionClientWithIdOnly = await prisma.notificationPermissionClient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationPermissionClientUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationPermissionClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPermissionClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationPermissionClient.
     * @param {NotificationPermissionClientUpsertArgs} args - Arguments to update or create a NotificationPermissionClient.
     * @example
     * // Update or create a NotificationPermissionClient
     * const notificationPermissionClient = await prisma.notificationPermissionClient.upsert({
     *   create: {
     *     // ... data to create a NotificationPermissionClient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPermissionClient we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPermissionClientUpsertArgs>(args: SelectSubset<T, NotificationPermissionClientUpsertArgs<ExtArgs>>): Prisma__NotificationPermissionClientClient<$Result.GetResult<Prisma.$NotificationPermissionClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationPermissionClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionClientCountArgs} args - Arguments to filter NotificationPermissionClients to count.
     * @example
     * // Count the number of NotificationPermissionClients
     * const count = await prisma.notificationPermissionClient.count({
     *   where: {
     *     // ... the filter for the NotificationPermissionClients we want to count
     *   }
     * })
    **/
    count<T extends NotificationPermissionClientCountArgs>(
      args?: Subset<T, NotificationPermissionClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPermissionClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPermissionClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPermissionClientAggregateArgs>(args: Subset<T, NotificationPermissionClientAggregateArgs>): Prisma.PrismaPromise<GetNotificationPermissionClientAggregateType<T>>

    /**
     * Group by NotificationPermissionClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPermissionClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPermissionClientGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPermissionClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPermissionClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPermissionClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPermissionClient model
   */
  readonly fields: NotificationPermissionClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPermissionClient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPermissionClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPermissionClient model
   */
  interface NotificationPermissionClientFieldRefs {
    readonly id: FieldRef<"NotificationPermissionClient", 'String'>
    readonly userId: FieldRef<"NotificationPermissionClient", 'String'>
    readonly onProjectApproval: FieldRef<"NotificationPermissionClient", 'Boolean'>
    readonly onProjectRejection: FieldRef<"NotificationPermissionClient", 'Boolean'>
    readonly fileImportByEmployees: FieldRef<"NotificationPermissionClient", 'Boolean'>
    readonly weeklySummary: FieldRef<"NotificationPermissionClient", 'Boolean'>
    readonly storageLimit: FieldRef<"NotificationPermissionClient", 'Boolean'>
    readonly billPayment: FieldRef<"NotificationPermissionClient", 'Boolean'>
    readonly overdueProject: FieldRef<"NotificationPermissionClient", 'Boolean'>
    readonly createdAt: FieldRef<"NotificationPermissionClient", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationPermissionClient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPermissionClient findUnique
   */
  export type NotificationPermissionClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionClient
     */
    select?: NotificationPermissionClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionClient
     */
    omit?: NotificationPermissionClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionClientInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionClient to fetch.
     */
    where: NotificationPermissionClientWhereUniqueInput
  }

  /**
   * NotificationPermissionClient findUniqueOrThrow
   */
  export type NotificationPermissionClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionClient
     */
    select?: NotificationPermissionClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionClient
     */
    omit?: NotificationPermissionClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionClientInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionClient to fetch.
     */
    where: NotificationPermissionClientWhereUniqueInput
  }

  /**
   * NotificationPermissionClient findFirst
   */
  export type NotificationPermissionClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionClient
     */
    select?: NotificationPermissionClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionClient
     */
    omit?: NotificationPermissionClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionClientInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionClient to fetch.
     */
    where?: NotificationPermissionClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionClients to fetch.
     */
    orderBy?: NotificationPermissionClientOrderByWithRelationInput | NotificationPermissionClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPermissionClients.
     */
    cursor?: NotificationPermissionClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPermissionClients.
     */
    distinct?: NotificationPermissionClientScalarFieldEnum | NotificationPermissionClientScalarFieldEnum[]
  }

  /**
   * NotificationPermissionClient findFirstOrThrow
   */
  export type NotificationPermissionClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionClient
     */
    select?: NotificationPermissionClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionClient
     */
    omit?: NotificationPermissionClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionClientInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionClient to fetch.
     */
    where?: NotificationPermissionClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionClients to fetch.
     */
    orderBy?: NotificationPermissionClientOrderByWithRelationInput | NotificationPermissionClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPermissionClients.
     */
    cursor?: NotificationPermissionClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPermissionClients.
     */
    distinct?: NotificationPermissionClientScalarFieldEnum | NotificationPermissionClientScalarFieldEnum[]
  }

  /**
   * NotificationPermissionClient findMany
   */
  export type NotificationPermissionClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionClient
     */
    select?: NotificationPermissionClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionClient
     */
    omit?: NotificationPermissionClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionClientInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionClients to fetch.
     */
    where?: NotificationPermissionClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionClients to fetch.
     */
    orderBy?: NotificationPermissionClientOrderByWithRelationInput | NotificationPermissionClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPermissionClients.
     */
    cursor?: NotificationPermissionClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionClients.
     */
    skip?: number
    distinct?: NotificationPermissionClientScalarFieldEnum | NotificationPermissionClientScalarFieldEnum[]
  }

  /**
   * NotificationPermissionClient create
   */
  export type NotificationPermissionClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionClient
     */
    select?: NotificationPermissionClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionClient
     */
    omit?: NotificationPermissionClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionClientInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPermissionClient.
     */
    data: XOR<NotificationPermissionClientCreateInput, NotificationPermissionClientUncheckedCreateInput>
  }

  /**
   * NotificationPermissionClient createMany
   */
  export type NotificationPermissionClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPermissionClients.
     */
    data: NotificationPermissionClientCreateManyInput | NotificationPermissionClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationPermissionClient createManyAndReturn
   */
  export type NotificationPermissionClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionClient
     */
    select?: NotificationPermissionClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionClient
     */
    omit?: NotificationPermissionClientOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationPermissionClients.
     */
    data: NotificationPermissionClientCreateManyInput | NotificationPermissionClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPermissionClient update
   */
  export type NotificationPermissionClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionClient
     */
    select?: NotificationPermissionClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionClient
     */
    omit?: NotificationPermissionClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionClientInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPermissionClient.
     */
    data: XOR<NotificationPermissionClientUpdateInput, NotificationPermissionClientUncheckedUpdateInput>
    /**
     * Choose, which NotificationPermissionClient to update.
     */
    where: NotificationPermissionClientWhereUniqueInput
  }

  /**
   * NotificationPermissionClient updateMany
   */
  export type NotificationPermissionClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPermissionClients.
     */
    data: XOR<NotificationPermissionClientUpdateManyMutationInput, NotificationPermissionClientUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPermissionClients to update
     */
    where?: NotificationPermissionClientWhereInput
    /**
     * Limit how many NotificationPermissionClients to update.
     */
    limit?: number
  }

  /**
   * NotificationPermissionClient updateManyAndReturn
   */
  export type NotificationPermissionClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionClient
     */
    select?: NotificationPermissionClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionClient
     */
    omit?: NotificationPermissionClientOmit<ExtArgs> | null
    /**
     * The data used to update NotificationPermissionClients.
     */
    data: XOR<NotificationPermissionClientUpdateManyMutationInput, NotificationPermissionClientUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPermissionClients to update
     */
    where?: NotificationPermissionClientWhereInput
    /**
     * Limit how many NotificationPermissionClients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionClientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPermissionClient upsert
   */
  export type NotificationPermissionClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionClient
     */
    select?: NotificationPermissionClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionClient
     */
    omit?: NotificationPermissionClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionClientInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPermissionClient to update in case it exists.
     */
    where: NotificationPermissionClientWhereUniqueInput
    /**
     * In case the NotificationPermissionClient found by the `where` argument doesn't exist, create a new NotificationPermissionClient with this data.
     */
    create: XOR<NotificationPermissionClientCreateInput, NotificationPermissionClientUncheckedCreateInput>
    /**
     * In case the NotificationPermissionClient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPermissionClientUpdateInput, NotificationPermissionClientUncheckedUpdateInput>
  }

  /**
   * NotificationPermissionClient delete
   */
  export type NotificationPermissionClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionClient
     */
    select?: NotificationPermissionClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionClient
     */
    omit?: NotificationPermissionClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionClientInclude<ExtArgs> | null
    /**
     * Filter which NotificationPermissionClient to delete.
     */
    where: NotificationPermissionClientWhereUniqueInput
  }

  /**
   * NotificationPermissionClient deleteMany
   */
  export type NotificationPermissionClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPermissionClients to delete
     */
    where?: NotificationPermissionClientWhereInput
    /**
     * Limit how many NotificationPermissionClients to delete.
     */
    limit?: number
  }

  /**
   * NotificationPermissionClient without action
   */
  export type NotificationPermissionClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionClient
     */
    select?: NotificationPermissionClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionClient
     */
    omit?: NotificationPermissionClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionClientInclude<ExtArgs> | null
  }


  /**
   * Model NotificationPermissionSupporter
   */

  export type AggregateNotificationPermissionSupporter = {
    _count: NotificationPermissionSupporterCountAggregateOutputType | null
    _min: NotificationPermissionSupporterMinAggregateOutputType | null
    _max: NotificationPermissionSupporterMaxAggregateOutputType | null
  }

  export type NotificationPermissionSupporterMinAggregateOutputType = {
    id: string | null
    userId: string | null
    assignNewProject: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPermissionSupporterMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    assignNewProject: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPermissionSupporterCountAggregateOutputType = {
    id: number
    userId: number
    assignNewProject: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationPermissionSupporterMinAggregateInputType = {
    id?: true
    userId?: true
    assignNewProject?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPermissionSupporterMaxAggregateInputType = {
    id?: true
    userId?: true
    assignNewProject?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPermissionSupporterCountAggregateInputType = {
    id?: true
    userId?: true
    assignNewProject?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationPermissionSupporterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPermissionSupporter to aggregate.
     */
    where?: NotificationPermissionSupporterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionSupporters to fetch.
     */
    orderBy?: NotificationPermissionSupporterOrderByWithRelationInput | NotificationPermissionSupporterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPermissionSupporterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionSupporters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionSupporters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPermissionSupporters
    **/
    _count?: true | NotificationPermissionSupporterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPermissionSupporterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPermissionSupporterMaxAggregateInputType
  }

  export type GetNotificationPermissionSupporterAggregateType<T extends NotificationPermissionSupporterAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPermissionSupporter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPermissionSupporter[P]>
      : GetScalarType<T[P], AggregateNotificationPermissionSupporter[P]>
  }




  export type NotificationPermissionSupporterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPermissionSupporterWhereInput
    orderBy?: NotificationPermissionSupporterOrderByWithAggregationInput | NotificationPermissionSupporterOrderByWithAggregationInput[]
    by: NotificationPermissionSupporterScalarFieldEnum[] | NotificationPermissionSupporterScalarFieldEnum
    having?: NotificationPermissionSupporterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPermissionSupporterCountAggregateInputType | true
    _min?: NotificationPermissionSupporterMinAggregateInputType
    _max?: NotificationPermissionSupporterMaxAggregateInputType
  }

  export type NotificationPermissionSupporterGroupByOutputType = {
    id: string
    userId: string
    assignNewProject: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationPermissionSupporterCountAggregateOutputType | null
    _min: NotificationPermissionSupporterMinAggregateOutputType | null
    _max: NotificationPermissionSupporterMaxAggregateOutputType | null
  }

  type GetNotificationPermissionSupporterGroupByPayload<T extends NotificationPermissionSupporterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPermissionSupporterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPermissionSupporterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPermissionSupporterGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPermissionSupporterGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPermissionSupporterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assignNewProject?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPermissionSupporter"]>

  export type NotificationPermissionSupporterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assignNewProject?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPermissionSupporter"]>

  export type NotificationPermissionSupporterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assignNewProject?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPermissionSupporter"]>

  export type NotificationPermissionSupporterSelectScalar = {
    id?: boolean
    userId?: boolean
    assignNewProject?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationPermissionSupporterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "assignNewProject" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationPermissionSupporter"]>
  export type NotificationPermissionSupporterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPermissionSupporterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPermissionSupporterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPermissionSupporterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPermissionSupporter"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      assignNewProject: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationPermissionSupporter"]>
    composites: {}
  }

  type NotificationPermissionSupporterGetPayload<S extends boolean | null | undefined | NotificationPermissionSupporterDefaultArgs> = $Result.GetResult<Prisma.$NotificationPermissionSupporterPayload, S>

  type NotificationPermissionSupporterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationPermissionSupporterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationPermissionSupporterCountAggregateInputType | true
    }

  export interface NotificationPermissionSupporterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPermissionSupporter'], meta: { name: 'NotificationPermissionSupporter' } }
    /**
     * Find zero or one NotificationPermissionSupporter that matches the filter.
     * @param {NotificationPermissionSupporterFindUniqueArgs} args - Arguments to find a NotificationPermissionSupporter
     * @example
     * // Get one NotificationPermissionSupporter
     * const notificationPermissionSupporter = await prisma.notificationPermissionSupporter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPermissionSupporterFindUniqueArgs>(args: SelectSubset<T, NotificationPermissionSupporterFindUniqueArgs<ExtArgs>>): Prisma__NotificationPermissionSupporterClient<$Result.GetResult<Prisma.$NotificationPermissionSupporterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationPermissionSupporter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationPermissionSupporterFindUniqueOrThrowArgs} args - Arguments to find a NotificationPermissionSupporter
     * @example
     * // Get one NotificationPermissionSupporter
     * const notificationPermissionSupporter = await prisma.notificationPermissionSupporter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPermissionSupporterFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPermissionSupporterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPermissionSupporterClient<$Result.GetResult<Prisma.$NotificationPermissionSupporterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPermissionSupporter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionSupporterFindFirstArgs} args - Arguments to find a NotificationPermissionSupporter
     * @example
     * // Get one NotificationPermissionSupporter
     * const notificationPermissionSupporter = await prisma.notificationPermissionSupporter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPermissionSupporterFindFirstArgs>(args?: SelectSubset<T, NotificationPermissionSupporterFindFirstArgs<ExtArgs>>): Prisma__NotificationPermissionSupporterClient<$Result.GetResult<Prisma.$NotificationPermissionSupporterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPermissionSupporter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionSupporterFindFirstOrThrowArgs} args - Arguments to find a NotificationPermissionSupporter
     * @example
     * // Get one NotificationPermissionSupporter
     * const notificationPermissionSupporter = await prisma.notificationPermissionSupporter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPermissionSupporterFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPermissionSupporterFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPermissionSupporterClient<$Result.GetResult<Prisma.$NotificationPermissionSupporterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationPermissionSupporters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionSupporterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPermissionSupporters
     * const notificationPermissionSupporters = await prisma.notificationPermissionSupporter.findMany()
     * 
     * // Get first 10 NotificationPermissionSupporters
     * const notificationPermissionSupporters = await prisma.notificationPermissionSupporter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPermissionSupporterWithIdOnly = await prisma.notificationPermissionSupporter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationPermissionSupporterFindManyArgs>(args?: SelectSubset<T, NotificationPermissionSupporterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPermissionSupporterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationPermissionSupporter.
     * @param {NotificationPermissionSupporterCreateArgs} args - Arguments to create a NotificationPermissionSupporter.
     * @example
     * // Create one NotificationPermissionSupporter
     * const NotificationPermissionSupporter = await prisma.notificationPermissionSupporter.create({
     *   data: {
     *     // ... data to create a NotificationPermissionSupporter
     *   }
     * })
     * 
     */
    create<T extends NotificationPermissionSupporterCreateArgs>(args: SelectSubset<T, NotificationPermissionSupporterCreateArgs<ExtArgs>>): Prisma__NotificationPermissionSupporterClient<$Result.GetResult<Prisma.$NotificationPermissionSupporterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationPermissionSupporters.
     * @param {NotificationPermissionSupporterCreateManyArgs} args - Arguments to create many NotificationPermissionSupporters.
     * @example
     * // Create many NotificationPermissionSupporters
     * const notificationPermissionSupporter = await prisma.notificationPermissionSupporter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPermissionSupporterCreateManyArgs>(args?: SelectSubset<T, NotificationPermissionSupporterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPermissionSupporters and returns the data saved in the database.
     * @param {NotificationPermissionSupporterCreateManyAndReturnArgs} args - Arguments to create many NotificationPermissionSupporters.
     * @example
     * // Create many NotificationPermissionSupporters
     * const notificationPermissionSupporter = await prisma.notificationPermissionSupporter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPermissionSupporters and only return the `id`
     * const notificationPermissionSupporterWithIdOnly = await prisma.notificationPermissionSupporter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationPermissionSupporterCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationPermissionSupporterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPermissionSupporterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationPermissionSupporter.
     * @param {NotificationPermissionSupporterDeleteArgs} args - Arguments to delete one NotificationPermissionSupporter.
     * @example
     * // Delete one NotificationPermissionSupporter
     * const NotificationPermissionSupporter = await prisma.notificationPermissionSupporter.delete({
     *   where: {
     *     // ... filter to delete one NotificationPermissionSupporter
     *   }
     * })
     * 
     */
    delete<T extends NotificationPermissionSupporterDeleteArgs>(args: SelectSubset<T, NotificationPermissionSupporterDeleteArgs<ExtArgs>>): Prisma__NotificationPermissionSupporterClient<$Result.GetResult<Prisma.$NotificationPermissionSupporterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationPermissionSupporter.
     * @param {NotificationPermissionSupporterUpdateArgs} args - Arguments to update one NotificationPermissionSupporter.
     * @example
     * // Update one NotificationPermissionSupporter
     * const notificationPermissionSupporter = await prisma.notificationPermissionSupporter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPermissionSupporterUpdateArgs>(args: SelectSubset<T, NotificationPermissionSupporterUpdateArgs<ExtArgs>>): Prisma__NotificationPermissionSupporterClient<$Result.GetResult<Prisma.$NotificationPermissionSupporterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationPermissionSupporters.
     * @param {NotificationPermissionSupporterDeleteManyArgs} args - Arguments to filter NotificationPermissionSupporters to delete.
     * @example
     * // Delete a few NotificationPermissionSupporters
     * const { count } = await prisma.notificationPermissionSupporter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPermissionSupporterDeleteManyArgs>(args?: SelectSubset<T, NotificationPermissionSupporterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPermissionSupporters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionSupporterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPermissionSupporters
     * const notificationPermissionSupporter = await prisma.notificationPermissionSupporter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPermissionSupporterUpdateManyArgs>(args: SelectSubset<T, NotificationPermissionSupporterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPermissionSupporters and returns the data updated in the database.
     * @param {NotificationPermissionSupporterUpdateManyAndReturnArgs} args - Arguments to update many NotificationPermissionSupporters.
     * @example
     * // Update many NotificationPermissionSupporters
     * const notificationPermissionSupporter = await prisma.notificationPermissionSupporter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationPermissionSupporters and only return the `id`
     * const notificationPermissionSupporterWithIdOnly = await prisma.notificationPermissionSupporter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationPermissionSupporterUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationPermissionSupporterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPermissionSupporterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationPermissionSupporter.
     * @param {NotificationPermissionSupporterUpsertArgs} args - Arguments to update or create a NotificationPermissionSupporter.
     * @example
     * // Update or create a NotificationPermissionSupporter
     * const notificationPermissionSupporter = await prisma.notificationPermissionSupporter.upsert({
     *   create: {
     *     // ... data to create a NotificationPermissionSupporter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPermissionSupporter we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPermissionSupporterUpsertArgs>(args: SelectSubset<T, NotificationPermissionSupporterUpsertArgs<ExtArgs>>): Prisma__NotificationPermissionSupporterClient<$Result.GetResult<Prisma.$NotificationPermissionSupporterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationPermissionSupporters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionSupporterCountArgs} args - Arguments to filter NotificationPermissionSupporters to count.
     * @example
     * // Count the number of NotificationPermissionSupporters
     * const count = await prisma.notificationPermissionSupporter.count({
     *   where: {
     *     // ... the filter for the NotificationPermissionSupporters we want to count
     *   }
     * })
    **/
    count<T extends NotificationPermissionSupporterCountArgs>(
      args?: Subset<T, NotificationPermissionSupporterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPermissionSupporterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPermissionSupporter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionSupporterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPermissionSupporterAggregateArgs>(args: Subset<T, NotificationPermissionSupporterAggregateArgs>): Prisma.PrismaPromise<GetNotificationPermissionSupporterAggregateType<T>>

    /**
     * Group by NotificationPermissionSupporter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionSupporterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPermissionSupporterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPermissionSupporterGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPermissionSupporterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPermissionSupporterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPermissionSupporterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPermissionSupporter model
   */
  readonly fields: NotificationPermissionSupporterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPermissionSupporter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPermissionSupporterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPermissionSupporter model
   */
  interface NotificationPermissionSupporterFieldRefs {
    readonly id: FieldRef<"NotificationPermissionSupporter", 'String'>
    readonly userId: FieldRef<"NotificationPermissionSupporter", 'String'>
    readonly assignNewProject: FieldRef<"NotificationPermissionSupporter", 'Boolean'>
    readonly createdAt: FieldRef<"NotificationPermissionSupporter", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationPermissionSupporter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPermissionSupporter findUnique
   */
  export type NotificationPermissionSupporterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSupporter
     */
    select?: NotificationPermissionSupporterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSupporter
     */
    omit?: NotificationPermissionSupporterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSupporterInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionSupporter to fetch.
     */
    where: NotificationPermissionSupporterWhereUniqueInput
  }

  /**
   * NotificationPermissionSupporter findUniqueOrThrow
   */
  export type NotificationPermissionSupporterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSupporter
     */
    select?: NotificationPermissionSupporterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSupporter
     */
    omit?: NotificationPermissionSupporterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSupporterInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionSupporter to fetch.
     */
    where: NotificationPermissionSupporterWhereUniqueInput
  }

  /**
   * NotificationPermissionSupporter findFirst
   */
  export type NotificationPermissionSupporterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSupporter
     */
    select?: NotificationPermissionSupporterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSupporter
     */
    omit?: NotificationPermissionSupporterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSupporterInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionSupporter to fetch.
     */
    where?: NotificationPermissionSupporterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionSupporters to fetch.
     */
    orderBy?: NotificationPermissionSupporterOrderByWithRelationInput | NotificationPermissionSupporterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPermissionSupporters.
     */
    cursor?: NotificationPermissionSupporterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionSupporters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionSupporters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPermissionSupporters.
     */
    distinct?: NotificationPermissionSupporterScalarFieldEnum | NotificationPermissionSupporterScalarFieldEnum[]
  }

  /**
   * NotificationPermissionSupporter findFirstOrThrow
   */
  export type NotificationPermissionSupporterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSupporter
     */
    select?: NotificationPermissionSupporterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSupporter
     */
    omit?: NotificationPermissionSupporterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSupporterInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionSupporter to fetch.
     */
    where?: NotificationPermissionSupporterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionSupporters to fetch.
     */
    orderBy?: NotificationPermissionSupporterOrderByWithRelationInput | NotificationPermissionSupporterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPermissionSupporters.
     */
    cursor?: NotificationPermissionSupporterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionSupporters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionSupporters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPermissionSupporters.
     */
    distinct?: NotificationPermissionSupporterScalarFieldEnum | NotificationPermissionSupporterScalarFieldEnum[]
  }

  /**
   * NotificationPermissionSupporter findMany
   */
  export type NotificationPermissionSupporterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSupporter
     */
    select?: NotificationPermissionSupporterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSupporter
     */
    omit?: NotificationPermissionSupporterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSupporterInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionSupporters to fetch.
     */
    where?: NotificationPermissionSupporterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionSupporters to fetch.
     */
    orderBy?: NotificationPermissionSupporterOrderByWithRelationInput | NotificationPermissionSupporterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPermissionSupporters.
     */
    cursor?: NotificationPermissionSupporterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionSupporters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionSupporters.
     */
    skip?: number
    distinct?: NotificationPermissionSupporterScalarFieldEnum | NotificationPermissionSupporterScalarFieldEnum[]
  }

  /**
   * NotificationPermissionSupporter create
   */
  export type NotificationPermissionSupporterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSupporter
     */
    select?: NotificationPermissionSupporterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSupporter
     */
    omit?: NotificationPermissionSupporterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSupporterInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPermissionSupporter.
     */
    data: XOR<NotificationPermissionSupporterCreateInput, NotificationPermissionSupporterUncheckedCreateInput>
  }

  /**
   * NotificationPermissionSupporter createMany
   */
  export type NotificationPermissionSupporterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPermissionSupporters.
     */
    data: NotificationPermissionSupporterCreateManyInput | NotificationPermissionSupporterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationPermissionSupporter createManyAndReturn
   */
  export type NotificationPermissionSupporterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSupporter
     */
    select?: NotificationPermissionSupporterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSupporter
     */
    omit?: NotificationPermissionSupporterOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationPermissionSupporters.
     */
    data: NotificationPermissionSupporterCreateManyInput | NotificationPermissionSupporterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSupporterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPermissionSupporter update
   */
  export type NotificationPermissionSupporterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSupporter
     */
    select?: NotificationPermissionSupporterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSupporter
     */
    omit?: NotificationPermissionSupporterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSupporterInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPermissionSupporter.
     */
    data: XOR<NotificationPermissionSupporterUpdateInput, NotificationPermissionSupporterUncheckedUpdateInput>
    /**
     * Choose, which NotificationPermissionSupporter to update.
     */
    where: NotificationPermissionSupporterWhereUniqueInput
  }

  /**
   * NotificationPermissionSupporter updateMany
   */
  export type NotificationPermissionSupporterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPermissionSupporters.
     */
    data: XOR<NotificationPermissionSupporterUpdateManyMutationInput, NotificationPermissionSupporterUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPermissionSupporters to update
     */
    where?: NotificationPermissionSupporterWhereInput
    /**
     * Limit how many NotificationPermissionSupporters to update.
     */
    limit?: number
  }

  /**
   * NotificationPermissionSupporter updateManyAndReturn
   */
  export type NotificationPermissionSupporterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSupporter
     */
    select?: NotificationPermissionSupporterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSupporter
     */
    omit?: NotificationPermissionSupporterOmit<ExtArgs> | null
    /**
     * The data used to update NotificationPermissionSupporters.
     */
    data: XOR<NotificationPermissionSupporterUpdateManyMutationInput, NotificationPermissionSupporterUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPermissionSupporters to update
     */
    where?: NotificationPermissionSupporterWhereInput
    /**
     * Limit how many NotificationPermissionSupporters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSupporterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPermissionSupporter upsert
   */
  export type NotificationPermissionSupporterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSupporter
     */
    select?: NotificationPermissionSupporterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSupporter
     */
    omit?: NotificationPermissionSupporterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSupporterInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPermissionSupporter to update in case it exists.
     */
    where: NotificationPermissionSupporterWhereUniqueInput
    /**
     * In case the NotificationPermissionSupporter found by the `where` argument doesn't exist, create a new NotificationPermissionSupporter with this data.
     */
    create: XOR<NotificationPermissionSupporterCreateInput, NotificationPermissionSupporterUncheckedCreateInput>
    /**
     * In case the NotificationPermissionSupporter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPermissionSupporterUpdateInput, NotificationPermissionSupporterUncheckedUpdateInput>
  }

  /**
   * NotificationPermissionSupporter delete
   */
  export type NotificationPermissionSupporterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSupporter
     */
    select?: NotificationPermissionSupporterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSupporter
     */
    omit?: NotificationPermissionSupporterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSupporterInclude<ExtArgs> | null
    /**
     * Filter which NotificationPermissionSupporter to delete.
     */
    where: NotificationPermissionSupporterWhereUniqueInput
  }

  /**
   * NotificationPermissionSupporter deleteMany
   */
  export type NotificationPermissionSupporterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPermissionSupporters to delete
     */
    where?: NotificationPermissionSupporterWhereInput
    /**
     * Limit how many NotificationPermissionSupporters to delete.
     */
    limit?: number
  }

  /**
   * NotificationPermissionSupporter without action
   */
  export type NotificationPermissionSupporterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSupporter
     */
    select?: NotificationPermissionSupporterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSupporter
     */
    omit?: NotificationPermissionSupporterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSupporterInclude<ExtArgs> | null
  }


  /**
   * Model NotificationPermissionAdmin
   */

  export type AggregateNotificationPermissionAdmin = {
    _count: NotificationPermissionAdminCountAggregateOutputType | null
    _min: NotificationPermissionAdminMinAggregateOutputType | null
    _max: NotificationPermissionAdminMaxAggregateOutputType | null
  }

  export type NotificationPermissionAdminMinAggregateOutputType = {
    id: string | null
    userId: string | null
    storageLimit: boolean | null
    receivedPayment: boolean | null
    createClient: boolean | null
    createTicket: boolean | null
    paymentCycleChange: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPermissionAdminMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    storageLimit: boolean | null
    receivedPayment: boolean | null
    createClient: boolean | null
    createTicket: boolean | null
    paymentCycleChange: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPermissionAdminCountAggregateOutputType = {
    id: number
    userId: number
    storageLimit: number
    receivedPayment: number
    createClient: number
    createTicket: number
    paymentCycleChange: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationPermissionAdminMinAggregateInputType = {
    id?: true
    userId?: true
    storageLimit?: true
    receivedPayment?: true
    createClient?: true
    createTicket?: true
    paymentCycleChange?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPermissionAdminMaxAggregateInputType = {
    id?: true
    userId?: true
    storageLimit?: true
    receivedPayment?: true
    createClient?: true
    createTicket?: true
    paymentCycleChange?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPermissionAdminCountAggregateInputType = {
    id?: true
    userId?: true
    storageLimit?: true
    receivedPayment?: true
    createClient?: true
    createTicket?: true
    paymentCycleChange?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationPermissionAdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPermissionAdmin to aggregate.
     */
    where?: NotificationPermissionAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionAdmins to fetch.
     */
    orderBy?: NotificationPermissionAdminOrderByWithRelationInput | NotificationPermissionAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPermissionAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPermissionAdmins
    **/
    _count?: true | NotificationPermissionAdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPermissionAdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPermissionAdminMaxAggregateInputType
  }

  export type GetNotificationPermissionAdminAggregateType<T extends NotificationPermissionAdminAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPermissionAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPermissionAdmin[P]>
      : GetScalarType<T[P], AggregateNotificationPermissionAdmin[P]>
  }




  export type NotificationPermissionAdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPermissionAdminWhereInput
    orderBy?: NotificationPermissionAdminOrderByWithAggregationInput | NotificationPermissionAdminOrderByWithAggregationInput[]
    by: NotificationPermissionAdminScalarFieldEnum[] | NotificationPermissionAdminScalarFieldEnum
    having?: NotificationPermissionAdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPermissionAdminCountAggregateInputType | true
    _min?: NotificationPermissionAdminMinAggregateInputType
    _max?: NotificationPermissionAdminMaxAggregateInputType
  }

  export type NotificationPermissionAdminGroupByOutputType = {
    id: string
    userId: string
    storageLimit: boolean
    receivedPayment: boolean
    createClient: boolean
    createTicket: boolean
    paymentCycleChange: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationPermissionAdminCountAggregateOutputType | null
    _min: NotificationPermissionAdminMinAggregateOutputType | null
    _max: NotificationPermissionAdminMaxAggregateOutputType | null
  }

  type GetNotificationPermissionAdminGroupByPayload<T extends NotificationPermissionAdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPermissionAdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPermissionAdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPermissionAdminGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPermissionAdminGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPermissionAdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    storageLimit?: boolean
    receivedPayment?: boolean
    createClient?: boolean
    createTicket?: boolean
    paymentCycleChange?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPermissionAdmin"]>

  export type NotificationPermissionAdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    storageLimit?: boolean
    receivedPayment?: boolean
    createClient?: boolean
    createTicket?: boolean
    paymentCycleChange?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPermissionAdmin"]>

  export type NotificationPermissionAdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    storageLimit?: boolean
    receivedPayment?: boolean
    createClient?: boolean
    createTicket?: boolean
    paymentCycleChange?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPermissionAdmin"]>

  export type NotificationPermissionAdminSelectScalar = {
    id?: boolean
    userId?: boolean
    storageLimit?: boolean
    receivedPayment?: boolean
    createClient?: boolean
    createTicket?: boolean
    paymentCycleChange?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationPermissionAdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "storageLimit" | "receivedPayment" | "createClient" | "createTicket" | "paymentCycleChange" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationPermissionAdmin"]>
  export type NotificationPermissionAdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPermissionAdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPermissionAdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPermissionAdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPermissionAdmin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      storageLimit: boolean
      receivedPayment: boolean
      createClient: boolean
      createTicket: boolean
      paymentCycleChange: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationPermissionAdmin"]>
    composites: {}
  }

  type NotificationPermissionAdminGetPayload<S extends boolean | null | undefined | NotificationPermissionAdminDefaultArgs> = $Result.GetResult<Prisma.$NotificationPermissionAdminPayload, S>

  type NotificationPermissionAdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationPermissionAdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationPermissionAdminCountAggregateInputType | true
    }

  export interface NotificationPermissionAdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPermissionAdmin'], meta: { name: 'NotificationPermissionAdmin' } }
    /**
     * Find zero or one NotificationPermissionAdmin that matches the filter.
     * @param {NotificationPermissionAdminFindUniqueArgs} args - Arguments to find a NotificationPermissionAdmin
     * @example
     * // Get one NotificationPermissionAdmin
     * const notificationPermissionAdmin = await prisma.notificationPermissionAdmin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPermissionAdminFindUniqueArgs>(args: SelectSubset<T, NotificationPermissionAdminFindUniqueArgs<ExtArgs>>): Prisma__NotificationPermissionAdminClient<$Result.GetResult<Prisma.$NotificationPermissionAdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationPermissionAdmin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationPermissionAdminFindUniqueOrThrowArgs} args - Arguments to find a NotificationPermissionAdmin
     * @example
     * // Get one NotificationPermissionAdmin
     * const notificationPermissionAdmin = await prisma.notificationPermissionAdmin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPermissionAdminFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPermissionAdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPermissionAdminClient<$Result.GetResult<Prisma.$NotificationPermissionAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPermissionAdmin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionAdminFindFirstArgs} args - Arguments to find a NotificationPermissionAdmin
     * @example
     * // Get one NotificationPermissionAdmin
     * const notificationPermissionAdmin = await prisma.notificationPermissionAdmin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPermissionAdminFindFirstArgs>(args?: SelectSubset<T, NotificationPermissionAdminFindFirstArgs<ExtArgs>>): Prisma__NotificationPermissionAdminClient<$Result.GetResult<Prisma.$NotificationPermissionAdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPermissionAdmin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionAdminFindFirstOrThrowArgs} args - Arguments to find a NotificationPermissionAdmin
     * @example
     * // Get one NotificationPermissionAdmin
     * const notificationPermissionAdmin = await prisma.notificationPermissionAdmin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPermissionAdminFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPermissionAdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPermissionAdminClient<$Result.GetResult<Prisma.$NotificationPermissionAdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationPermissionAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionAdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPermissionAdmins
     * const notificationPermissionAdmins = await prisma.notificationPermissionAdmin.findMany()
     * 
     * // Get first 10 NotificationPermissionAdmins
     * const notificationPermissionAdmins = await prisma.notificationPermissionAdmin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPermissionAdminWithIdOnly = await prisma.notificationPermissionAdmin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationPermissionAdminFindManyArgs>(args?: SelectSubset<T, NotificationPermissionAdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPermissionAdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationPermissionAdmin.
     * @param {NotificationPermissionAdminCreateArgs} args - Arguments to create a NotificationPermissionAdmin.
     * @example
     * // Create one NotificationPermissionAdmin
     * const NotificationPermissionAdmin = await prisma.notificationPermissionAdmin.create({
     *   data: {
     *     // ... data to create a NotificationPermissionAdmin
     *   }
     * })
     * 
     */
    create<T extends NotificationPermissionAdminCreateArgs>(args: SelectSubset<T, NotificationPermissionAdminCreateArgs<ExtArgs>>): Prisma__NotificationPermissionAdminClient<$Result.GetResult<Prisma.$NotificationPermissionAdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationPermissionAdmins.
     * @param {NotificationPermissionAdminCreateManyArgs} args - Arguments to create many NotificationPermissionAdmins.
     * @example
     * // Create many NotificationPermissionAdmins
     * const notificationPermissionAdmin = await prisma.notificationPermissionAdmin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPermissionAdminCreateManyArgs>(args?: SelectSubset<T, NotificationPermissionAdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPermissionAdmins and returns the data saved in the database.
     * @param {NotificationPermissionAdminCreateManyAndReturnArgs} args - Arguments to create many NotificationPermissionAdmins.
     * @example
     * // Create many NotificationPermissionAdmins
     * const notificationPermissionAdmin = await prisma.notificationPermissionAdmin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPermissionAdmins and only return the `id`
     * const notificationPermissionAdminWithIdOnly = await prisma.notificationPermissionAdmin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationPermissionAdminCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationPermissionAdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPermissionAdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationPermissionAdmin.
     * @param {NotificationPermissionAdminDeleteArgs} args - Arguments to delete one NotificationPermissionAdmin.
     * @example
     * // Delete one NotificationPermissionAdmin
     * const NotificationPermissionAdmin = await prisma.notificationPermissionAdmin.delete({
     *   where: {
     *     // ... filter to delete one NotificationPermissionAdmin
     *   }
     * })
     * 
     */
    delete<T extends NotificationPermissionAdminDeleteArgs>(args: SelectSubset<T, NotificationPermissionAdminDeleteArgs<ExtArgs>>): Prisma__NotificationPermissionAdminClient<$Result.GetResult<Prisma.$NotificationPermissionAdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationPermissionAdmin.
     * @param {NotificationPermissionAdminUpdateArgs} args - Arguments to update one NotificationPermissionAdmin.
     * @example
     * // Update one NotificationPermissionAdmin
     * const notificationPermissionAdmin = await prisma.notificationPermissionAdmin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPermissionAdminUpdateArgs>(args: SelectSubset<T, NotificationPermissionAdminUpdateArgs<ExtArgs>>): Prisma__NotificationPermissionAdminClient<$Result.GetResult<Prisma.$NotificationPermissionAdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationPermissionAdmins.
     * @param {NotificationPermissionAdminDeleteManyArgs} args - Arguments to filter NotificationPermissionAdmins to delete.
     * @example
     * // Delete a few NotificationPermissionAdmins
     * const { count } = await prisma.notificationPermissionAdmin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPermissionAdminDeleteManyArgs>(args?: SelectSubset<T, NotificationPermissionAdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPermissionAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionAdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPermissionAdmins
     * const notificationPermissionAdmin = await prisma.notificationPermissionAdmin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPermissionAdminUpdateManyArgs>(args: SelectSubset<T, NotificationPermissionAdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPermissionAdmins and returns the data updated in the database.
     * @param {NotificationPermissionAdminUpdateManyAndReturnArgs} args - Arguments to update many NotificationPermissionAdmins.
     * @example
     * // Update many NotificationPermissionAdmins
     * const notificationPermissionAdmin = await prisma.notificationPermissionAdmin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationPermissionAdmins and only return the `id`
     * const notificationPermissionAdminWithIdOnly = await prisma.notificationPermissionAdmin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationPermissionAdminUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationPermissionAdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPermissionAdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationPermissionAdmin.
     * @param {NotificationPermissionAdminUpsertArgs} args - Arguments to update or create a NotificationPermissionAdmin.
     * @example
     * // Update or create a NotificationPermissionAdmin
     * const notificationPermissionAdmin = await prisma.notificationPermissionAdmin.upsert({
     *   create: {
     *     // ... data to create a NotificationPermissionAdmin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPermissionAdmin we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPermissionAdminUpsertArgs>(args: SelectSubset<T, NotificationPermissionAdminUpsertArgs<ExtArgs>>): Prisma__NotificationPermissionAdminClient<$Result.GetResult<Prisma.$NotificationPermissionAdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationPermissionAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionAdminCountArgs} args - Arguments to filter NotificationPermissionAdmins to count.
     * @example
     * // Count the number of NotificationPermissionAdmins
     * const count = await prisma.notificationPermissionAdmin.count({
     *   where: {
     *     // ... the filter for the NotificationPermissionAdmins we want to count
     *   }
     * })
    **/
    count<T extends NotificationPermissionAdminCountArgs>(
      args?: Subset<T, NotificationPermissionAdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPermissionAdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPermissionAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionAdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPermissionAdminAggregateArgs>(args: Subset<T, NotificationPermissionAdminAggregateArgs>): Prisma.PrismaPromise<GetNotificationPermissionAdminAggregateType<T>>

    /**
     * Group by NotificationPermissionAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionAdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPermissionAdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPermissionAdminGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPermissionAdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPermissionAdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPermissionAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPermissionAdmin model
   */
  readonly fields: NotificationPermissionAdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPermissionAdmin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPermissionAdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPermissionAdmin model
   */
  interface NotificationPermissionAdminFieldRefs {
    readonly id: FieldRef<"NotificationPermissionAdmin", 'String'>
    readonly userId: FieldRef<"NotificationPermissionAdmin", 'String'>
    readonly storageLimit: FieldRef<"NotificationPermissionAdmin", 'Boolean'>
    readonly receivedPayment: FieldRef<"NotificationPermissionAdmin", 'Boolean'>
    readonly createClient: FieldRef<"NotificationPermissionAdmin", 'Boolean'>
    readonly createTicket: FieldRef<"NotificationPermissionAdmin", 'Boolean'>
    readonly paymentCycleChange: FieldRef<"NotificationPermissionAdmin", 'Boolean'>
    readonly createdAt: FieldRef<"NotificationPermissionAdmin", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationPermissionAdmin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPermissionAdmin findUnique
   */
  export type NotificationPermissionAdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionAdmin
     */
    select?: NotificationPermissionAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionAdmin
     */
    omit?: NotificationPermissionAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionAdminInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionAdmin to fetch.
     */
    where: NotificationPermissionAdminWhereUniqueInput
  }

  /**
   * NotificationPermissionAdmin findUniqueOrThrow
   */
  export type NotificationPermissionAdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionAdmin
     */
    select?: NotificationPermissionAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionAdmin
     */
    omit?: NotificationPermissionAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionAdminInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionAdmin to fetch.
     */
    where: NotificationPermissionAdminWhereUniqueInput
  }

  /**
   * NotificationPermissionAdmin findFirst
   */
  export type NotificationPermissionAdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionAdmin
     */
    select?: NotificationPermissionAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionAdmin
     */
    omit?: NotificationPermissionAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionAdminInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionAdmin to fetch.
     */
    where?: NotificationPermissionAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionAdmins to fetch.
     */
    orderBy?: NotificationPermissionAdminOrderByWithRelationInput | NotificationPermissionAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPermissionAdmins.
     */
    cursor?: NotificationPermissionAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPermissionAdmins.
     */
    distinct?: NotificationPermissionAdminScalarFieldEnum | NotificationPermissionAdminScalarFieldEnum[]
  }

  /**
   * NotificationPermissionAdmin findFirstOrThrow
   */
  export type NotificationPermissionAdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionAdmin
     */
    select?: NotificationPermissionAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionAdmin
     */
    omit?: NotificationPermissionAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionAdminInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionAdmin to fetch.
     */
    where?: NotificationPermissionAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionAdmins to fetch.
     */
    orderBy?: NotificationPermissionAdminOrderByWithRelationInput | NotificationPermissionAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPermissionAdmins.
     */
    cursor?: NotificationPermissionAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPermissionAdmins.
     */
    distinct?: NotificationPermissionAdminScalarFieldEnum | NotificationPermissionAdminScalarFieldEnum[]
  }

  /**
   * NotificationPermissionAdmin findMany
   */
  export type NotificationPermissionAdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionAdmin
     */
    select?: NotificationPermissionAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionAdmin
     */
    omit?: NotificationPermissionAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionAdminInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionAdmins to fetch.
     */
    where?: NotificationPermissionAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionAdmins to fetch.
     */
    orderBy?: NotificationPermissionAdminOrderByWithRelationInput | NotificationPermissionAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPermissionAdmins.
     */
    cursor?: NotificationPermissionAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionAdmins.
     */
    skip?: number
    distinct?: NotificationPermissionAdminScalarFieldEnum | NotificationPermissionAdminScalarFieldEnum[]
  }

  /**
   * NotificationPermissionAdmin create
   */
  export type NotificationPermissionAdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionAdmin
     */
    select?: NotificationPermissionAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionAdmin
     */
    omit?: NotificationPermissionAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionAdminInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPermissionAdmin.
     */
    data: XOR<NotificationPermissionAdminCreateInput, NotificationPermissionAdminUncheckedCreateInput>
  }

  /**
   * NotificationPermissionAdmin createMany
   */
  export type NotificationPermissionAdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPermissionAdmins.
     */
    data: NotificationPermissionAdminCreateManyInput | NotificationPermissionAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationPermissionAdmin createManyAndReturn
   */
  export type NotificationPermissionAdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionAdmin
     */
    select?: NotificationPermissionAdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionAdmin
     */
    omit?: NotificationPermissionAdminOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationPermissionAdmins.
     */
    data: NotificationPermissionAdminCreateManyInput | NotificationPermissionAdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionAdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPermissionAdmin update
   */
  export type NotificationPermissionAdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionAdmin
     */
    select?: NotificationPermissionAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionAdmin
     */
    omit?: NotificationPermissionAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionAdminInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPermissionAdmin.
     */
    data: XOR<NotificationPermissionAdminUpdateInput, NotificationPermissionAdminUncheckedUpdateInput>
    /**
     * Choose, which NotificationPermissionAdmin to update.
     */
    where: NotificationPermissionAdminWhereUniqueInput
  }

  /**
   * NotificationPermissionAdmin updateMany
   */
  export type NotificationPermissionAdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPermissionAdmins.
     */
    data: XOR<NotificationPermissionAdminUpdateManyMutationInput, NotificationPermissionAdminUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPermissionAdmins to update
     */
    where?: NotificationPermissionAdminWhereInput
    /**
     * Limit how many NotificationPermissionAdmins to update.
     */
    limit?: number
  }

  /**
   * NotificationPermissionAdmin updateManyAndReturn
   */
  export type NotificationPermissionAdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionAdmin
     */
    select?: NotificationPermissionAdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionAdmin
     */
    omit?: NotificationPermissionAdminOmit<ExtArgs> | null
    /**
     * The data used to update NotificationPermissionAdmins.
     */
    data: XOR<NotificationPermissionAdminUpdateManyMutationInput, NotificationPermissionAdminUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPermissionAdmins to update
     */
    where?: NotificationPermissionAdminWhereInput
    /**
     * Limit how many NotificationPermissionAdmins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionAdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPermissionAdmin upsert
   */
  export type NotificationPermissionAdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionAdmin
     */
    select?: NotificationPermissionAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionAdmin
     */
    omit?: NotificationPermissionAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionAdminInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPermissionAdmin to update in case it exists.
     */
    where: NotificationPermissionAdminWhereUniqueInput
    /**
     * In case the NotificationPermissionAdmin found by the `where` argument doesn't exist, create a new NotificationPermissionAdmin with this data.
     */
    create: XOR<NotificationPermissionAdminCreateInput, NotificationPermissionAdminUncheckedCreateInput>
    /**
     * In case the NotificationPermissionAdmin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPermissionAdminUpdateInput, NotificationPermissionAdminUncheckedUpdateInput>
  }

  /**
   * NotificationPermissionAdmin delete
   */
  export type NotificationPermissionAdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionAdmin
     */
    select?: NotificationPermissionAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionAdmin
     */
    omit?: NotificationPermissionAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionAdminInclude<ExtArgs> | null
    /**
     * Filter which NotificationPermissionAdmin to delete.
     */
    where: NotificationPermissionAdminWhereUniqueInput
  }

  /**
   * NotificationPermissionAdmin deleteMany
   */
  export type NotificationPermissionAdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPermissionAdmins to delete
     */
    where?: NotificationPermissionAdminWhereInput
    /**
     * Limit how many NotificationPermissionAdmins to delete.
     */
    limit?: number
  }

  /**
   * NotificationPermissionAdmin without action
   */
  export type NotificationPermissionAdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionAdmin
     */
    select?: NotificationPermissionAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionAdmin
     */
    omit?: NotificationPermissionAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionAdminInclude<ExtArgs> | null
  }


  /**
   * Model NotificationPermissionSuperAdmin
   */

  export type AggregateNotificationPermissionSuperAdmin = {
    _count: NotificationPermissionSuperAdminCountAggregateOutputType | null
    _min: NotificationPermissionSuperAdminMinAggregateOutputType | null
    _max: NotificationPermissionSuperAdminMaxAggregateOutputType | null
  }

  export type NotificationPermissionSuperAdminMinAggregateOutputType = {
    id: string | null
    userId: string | null
    storageLimit: boolean | null
    receivedPayment: boolean | null
    createClient: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPermissionSuperAdminMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    storageLimit: boolean | null
    receivedPayment: boolean | null
    createClient: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPermissionSuperAdminCountAggregateOutputType = {
    id: number
    userId: number
    storageLimit: number
    receivedPayment: number
    createClient: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationPermissionSuperAdminMinAggregateInputType = {
    id?: true
    userId?: true
    storageLimit?: true
    receivedPayment?: true
    createClient?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPermissionSuperAdminMaxAggregateInputType = {
    id?: true
    userId?: true
    storageLimit?: true
    receivedPayment?: true
    createClient?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPermissionSuperAdminCountAggregateInputType = {
    id?: true
    userId?: true
    storageLimit?: true
    receivedPayment?: true
    createClient?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationPermissionSuperAdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPermissionSuperAdmin to aggregate.
     */
    where?: NotificationPermissionSuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionSuperAdmins to fetch.
     */
    orderBy?: NotificationPermissionSuperAdminOrderByWithRelationInput | NotificationPermissionSuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPermissionSuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionSuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionSuperAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPermissionSuperAdmins
    **/
    _count?: true | NotificationPermissionSuperAdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPermissionSuperAdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPermissionSuperAdminMaxAggregateInputType
  }

  export type GetNotificationPermissionSuperAdminAggregateType<T extends NotificationPermissionSuperAdminAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPermissionSuperAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPermissionSuperAdmin[P]>
      : GetScalarType<T[P], AggregateNotificationPermissionSuperAdmin[P]>
  }




  export type NotificationPermissionSuperAdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPermissionSuperAdminWhereInput
    orderBy?: NotificationPermissionSuperAdminOrderByWithAggregationInput | NotificationPermissionSuperAdminOrderByWithAggregationInput[]
    by: NotificationPermissionSuperAdminScalarFieldEnum[] | NotificationPermissionSuperAdminScalarFieldEnum
    having?: NotificationPermissionSuperAdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPermissionSuperAdminCountAggregateInputType | true
    _min?: NotificationPermissionSuperAdminMinAggregateInputType
    _max?: NotificationPermissionSuperAdminMaxAggregateInputType
  }

  export type NotificationPermissionSuperAdminGroupByOutputType = {
    id: string
    userId: string
    storageLimit: boolean
    receivedPayment: boolean
    createClient: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationPermissionSuperAdminCountAggregateOutputType | null
    _min: NotificationPermissionSuperAdminMinAggregateOutputType | null
    _max: NotificationPermissionSuperAdminMaxAggregateOutputType | null
  }

  type GetNotificationPermissionSuperAdminGroupByPayload<T extends NotificationPermissionSuperAdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPermissionSuperAdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPermissionSuperAdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPermissionSuperAdminGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPermissionSuperAdminGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPermissionSuperAdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    storageLimit?: boolean
    receivedPayment?: boolean
    createClient?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | SuperAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPermissionSuperAdmin"]>

  export type NotificationPermissionSuperAdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    storageLimit?: boolean
    receivedPayment?: boolean
    createClient?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | SuperAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPermissionSuperAdmin"]>

  export type NotificationPermissionSuperAdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    storageLimit?: boolean
    receivedPayment?: boolean
    createClient?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | SuperAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPermissionSuperAdmin"]>

  export type NotificationPermissionSuperAdminSelectScalar = {
    id?: boolean
    userId?: boolean
    storageLimit?: boolean
    receivedPayment?: boolean
    createClient?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationPermissionSuperAdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "storageLimit" | "receivedPayment" | "createClient" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationPermissionSuperAdmin"]>
  export type NotificationPermissionSuperAdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SuperAdminDefaultArgs<ExtArgs>
  }
  export type NotificationPermissionSuperAdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SuperAdminDefaultArgs<ExtArgs>
  }
  export type NotificationPermissionSuperAdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SuperAdminDefaultArgs<ExtArgs>
  }

  export type $NotificationPermissionSuperAdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPermissionSuperAdmin"
    objects: {
      user: Prisma.$SuperAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      storageLimit: boolean
      receivedPayment: boolean
      createClient: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationPermissionSuperAdmin"]>
    composites: {}
  }

  type NotificationPermissionSuperAdminGetPayload<S extends boolean | null | undefined | NotificationPermissionSuperAdminDefaultArgs> = $Result.GetResult<Prisma.$NotificationPermissionSuperAdminPayload, S>

  type NotificationPermissionSuperAdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationPermissionSuperAdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationPermissionSuperAdminCountAggregateInputType | true
    }

  export interface NotificationPermissionSuperAdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPermissionSuperAdmin'], meta: { name: 'NotificationPermissionSuperAdmin' } }
    /**
     * Find zero or one NotificationPermissionSuperAdmin that matches the filter.
     * @param {NotificationPermissionSuperAdminFindUniqueArgs} args - Arguments to find a NotificationPermissionSuperAdmin
     * @example
     * // Get one NotificationPermissionSuperAdmin
     * const notificationPermissionSuperAdmin = await prisma.notificationPermissionSuperAdmin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPermissionSuperAdminFindUniqueArgs>(args: SelectSubset<T, NotificationPermissionSuperAdminFindUniqueArgs<ExtArgs>>): Prisma__NotificationPermissionSuperAdminClient<$Result.GetResult<Prisma.$NotificationPermissionSuperAdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationPermissionSuperAdmin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationPermissionSuperAdminFindUniqueOrThrowArgs} args - Arguments to find a NotificationPermissionSuperAdmin
     * @example
     * // Get one NotificationPermissionSuperAdmin
     * const notificationPermissionSuperAdmin = await prisma.notificationPermissionSuperAdmin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPermissionSuperAdminFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPermissionSuperAdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPermissionSuperAdminClient<$Result.GetResult<Prisma.$NotificationPermissionSuperAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPermissionSuperAdmin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionSuperAdminFindFirstArgs} args - Arguments to find a NotificationPermissionSuperAdmin
     * @example
     * // Get one NotificationPermissionSuperAdmin
     * const notificationPermissionSuperAdmin = await prisma.notificationPermissionSuperAdmin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPermissionSuperAdminFindFirstArgs>(args?: SelectSubset<T, NotificationPermissionSuperAdminFindFirstArgs<ExtArgs>>): Prisma__NotificationPermissionSuperAdminClient<$Result.GetResult<Prisma.$NotificationPermissionSuperAdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPermissionSuperAdmin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionSuperAdminFindFirstOrThrowArgs} args - Arguments to find a NotificationPermissionSuperAdmin
     * @example
     * // Get one NotificationPermissionSuperAdmin
     * const notificationPermissionSuperAdmin = await prisma.notificationPermissionSuperAdmin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPermissionSuperAdminFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPermissionSuperAdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPermissionSuperAdminClient<$Result.GetResult<Prisma.$NotificationPermissionSuperAdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationPermissionSuperAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionSuperAdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPermissionSuperAdmins
     * const notificationPermissionSuperAdmins = await prisma.notificationPermissionSuperAdmin.findMany()
     * 
     * // Get first 10 NotificationPermissionSuperAdmins
     * const notificationPermissionSuperAdmins = await prisma.notificationPermissionSuperAdmin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPermissionSuperAdminWithIdOnly = await prisma.notificationPermissionSuperAdmin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationPermissionSuperAdminFindManyArgs>(args?: SelectSubset<T, NotificationPermissionSuperAdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPermissionSuperAdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationPermissionSuperAdmin.
     * @param {NotificationPermissionSuperAdminCreateArgs} args - Arguments to create a NotificationPermissionSuperAdmin.
     * @example
     * // Create one NotificationPermissionSuperAdmin
     * const NotificationPermissionSuperAdmin = await prisma.notificationPermissionSuperAdmin.create({
     *   data: {
     *     // ... data to create a NotificationPermissionSuperAdmin
     *   }
     * })
     * 
     */
    create<T extends NotificationPermissionSuperAdminCreateArgs>(args: SelectSubset<T, NotificationPermissionSuperAdminCreateArgs<ExtArgs>>): Prisma__NotificationPermissionSuperAdminClient<$Result.GetResult<Prisma.$NotificationPermissionSuperAdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationPermissionSuperAdmins.
     * @param {NotificationPermissionSuperAdminCreateManyArgs} args - Arguments to create many NotificationPermissionSuperAdmins.
     * @example
     * // Create many NotificationPermissionSuperAdmins
     * const notificationPermissionSuperAdmin = await prisma.notificationPermissionSuperAdmin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPermissionSuperAdminCreateManyArgs>(args?: SelectSubset<T, NotificationPermissionSuperAdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPermissionSuperAdmins and returns the data saved in the database.
     * @param {NotificationPermissionSuperAdminCreateManyAndReturnArgs} args - Arguments to create many NotificationPermissionSuperAdmins.
     * @example
     * // Create many NotificationPermissionSuperAdmins
     * const notificationPermissionSuperAdmin = await prisma.notificationPermissionSuperAdmin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPermissionSuperAdmins and only return the `id`
     * const notificationPermissionSuperAdminWithIdOnly = await prisma.notificationPermissionSuperAdmin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationPermissionSuperAdminCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationPermissionSuperAdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPermissionSuperAdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationPermissionSuperAdmin.
     * @param {NotificationPermissionSuperAdminDeleteArgs} args - Arguments to delete one NotificationPermissionSuperAdmin.
     * @example
     * // Delete one NotificationPermissionSuperAdmin
     * const NotificationPermissionSuperAdmin = await prisma.notificationPermissionSuperAdmin.delete({
     *   where: {
     *     // ... filter to delete one NotificationPermissionSuperAdmin
     *   }
     * })
     * 
     */
    delete<T extends NotificationPermissionSuperAdminDeleteArgs>(args: SelectSubset<T, NotificationPermissionSuperAdminDeleteArgs<ExtArgs>>): Prisma__NotificationPermissionSuperAdminClient<$Result.GetResult<Prisma.$NotificationPermissionSuperAdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationPermissionSuperAdmin.
     * @param {NotificationPermissionSuperAdminUpdateArgs} args - Arguments to update one NotificationPermissionSuperAdmin.
     * @example
     * // Update one NotificationPermissionSuperAdmin
     * const notificationPermissionSuperAdmin = await prisma.notificationPermissionSuperAdmin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPermissionSuperAdminUpdateArgs>(args: SelectSubset<T, NotificationPermissionSuperAdminUpdateArgs<ExtArgs>>): Prisma__NotificationPermissionSuperAdminClient<$Result.GetResult<Prisma.$NotificationPermissionSuperAdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationPermissionSuperAdmins.
     * @param {NotificationPermissionSuperAdminDeleteManyArgs} args - Arguments to filter NotificationPermissionSuperAdmins to delete.
     * @example
     * // Delete a few NotificationPermissionSuperAdmins
     * const { count } = await prisma.notificationPermissionSuperAdmin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPermissionSuperAdminDeleteManyArgs>(args?: SelectSubset<T, NotificationPermissionSuperAdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPermissionSuperAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionSuperAdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPermissionSuperAdmins
     * const notificationPermissionSuperAdmin = await prisma.notificationPermissionSuperAdmin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPermissionSuperAdminUpdateManyArgs>(args: SelectSubset<T, NotificationPermissionSuperAdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPermissionSuperAdmins and returns the data updated in the database.
     * @param {NotificationPermissionSuperAdminUpdateManyAndReturnArgs} args - Arguments to update many NotificationPermissionSuperAdmins.
     * @example
     * // Update many NotificationPermissionSuperAdmins
     * const notificationPermissionSuperAdmin = await prisma.notificationPermissionSuperAdmin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationPermissionSuperAdmins and only return the `id`
     * const notificationPermissionSuperAdminWithIdOnly = await prisma.notificationPermissionSuperAdmin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationPermissionSuperAdminUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationPermissionSuperAdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPermissionSuperAdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationPermissionSuperAdmin.
     * @param {NotificationPermissionSuperAdminUpsertArgs} args - Arguments to update or create a NotificationPermissionSuperAdmin.
     * @example
     * // Update or create a NotificationPermissionSuperAdmin
     * const notificationPermissionSuperAdmin = await prisma.notificationPermissionSuperAdmin.upsert({
     *   create: {
     *     // ... data to create a NotificationPermissionSuperAdmin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPermissionSuperAdmin we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPermissionSuperAdminUpsertArgs>(args: SelectSubset<T, NotificationPermissionSuperAdminUpsertArgs<ExtArgs>>): Prisma__NotificationPermissionSuperAdminClient<$Result.GetResult<Prisma.$NotificationPermissionSuperAdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationPermissionSuperAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionSuperAdminCountArgs} args - Arguments to filter NotificationPermissionSuperAdmins to count.
     * @example
     * // Count the number of NotificationPermissionSuperAdmins
     * const count = await prisma.notificationPermissionSuperAdmin.count({
     *   where: {
     *     // ... the filter for the NotificationPermissionSuperAdmins we want to count
     *   }
     * })
    **/
    count<T extends NotificationPermissionSuperAdminCountArgs>(
      args?: Subset<T, NotificationPermissionSuperAdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPermissionSuperAdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPermissionSuperAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionSuperAdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPermissionSuperAdminAggregateArgs>(args: Subset<T, NotificationPermissionSuperAdminAggregateArgs>): Prisma.PrismaPromise<GetNotificationPermissionSuperAdminAggregateType<T>>

    /**
     * Group by NotificationPermissionSuperAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPermissionSuperAdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPermissionSuperAdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPermissionSuperAdminGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPermissionSuperAdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPermissionSuperAdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPermissionSuperAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPermissionSuperAdmin model
   */
  readonly fields: NotificationPermissionSuperAdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPermissionSuperAdmin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPermissionSuperAdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends SuperAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SuperAdminDefaultArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPermissionSuperAdmin model
   */
  interface NotificationPermissionSuperAdminFieldRefs {
    readonly id: FieldRef<"NotificationPermissionSuperAdmin", 'String'>
    readonly userId: FieldRef<"NotificationPermissionSuperAdmin", 'String'>
    readonly storageLimit: FieldRef<"NotificationPermissionSuperAdmin", 'Boolean'>
    readonly receivedPayment: FieldRef<"NotificationPermissionSuperAdmin", 'Boolean'>
    readonly createClient: FieldRef<"NotificationPermissionSuperAdmin", 'Boolean'>
    readonly createdAt: FieldRef<"NotificationPermissionSuperAdmin", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationPermissionSuperAdmin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPermissionSuperAdmin findUnique
   */
  export type NotificationPermissionSuperAdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSuperAdmin
     */
    select?: NotificationPermissionSuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSuperAdmin
     */
    omit?: NotificationPermissionSuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionSuperAdmin to fetch.
     */
    where: NotificationPermissionSuperAdminWhereUniqueInput
  }

  /**
   * NotificationPermissionSuperAdmin findUniqueOrThrow
   */
  export type NotificationPermissionSuperAdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSuperAdmin
     */
    select?: NotificationPermissionSuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSuperAdmin
     */
    omit?: NotificationPermissionSuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionSuperAdmin to fetch.
     */
    where: NotificationPermissionSuperAdminWhereUniqueInput
  }

  /**
   * NotificationPermissionSuperAdmin findFirst
   */
  export type NotificationPermissionSuperAdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSuperAdmin
     */
    select?: NotificationPermissionSuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSuperAdmin
     */
    omit?: NotificationPermissionSuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionSuperAdmin to fetch.
     */
    where?: NotificationPermissionSuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionSuperAdmins to fetch.
     */
    orderBy?: NotificationPermissionSuperAdminOrderByWithRelationInput | NotificationPermissionSuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPermissionSuperAdmins.
     */
    cursor?: NotificationPermissionSuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionSuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionSuperAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPermissionSuperAdmins.
     */
    distinct?: NotificationPermissionSuperAdminScalarFieldEnum | NotificationPermissionSuperAdminScalarFieldEnum[]
  }

  /**
   * NotificationPermissionSuperAdmin findFirstOrThrow
   */
  export type NotificationPermissionSuperAdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSuperAdmin
     */
    select?: NotificationPermissionSuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSuperAdmin
     */
    omit?: NotificationPermissionSuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionSuperAdmin to fetch.
     */
    where?: NotificationPermissionSuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionSuperAdmins to fetch.
     */
    orderBy?: NotificationPermissionSuperAdminOrderByWithRelationInput | NotificationPermissionSuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPermissionSuperAdmins.
     */
    cursor?: NotificationPermissionSuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionSuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionSuperAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPermissionSuperAdmins.
     */
    distinct?: NotificationPermissionSuperAdminScalarFieldEnum | NotificationPermissionSuperAdminScalarFieldEnum[]
  }

  /**
   * NotificationPermissionSuperAdmin findMany
   */
  export type NotificationPermissionSuperAdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSuperAdmin
     */
    select?: NotificationPermissionSuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSuperAdmin
     */
    omit?: NotificationPermissionSuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPermissionSuperAdmins to fetch.
     */
    where?: NotificationPermissionSuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPermissionSuperAdmins to fetch.
     */
    orderBy?: NotificationPermissionSuperAdminOrderByWithRelationInput | NotificationPermissionSuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPermissionSuperAdmins.
     */
    cursor?: NotificationPermissionSuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPermissionSuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPermissionSuperAdmins.
     */
    skip?: number
    distinct?: NotificationPermissionSuperAdminScalarFieldEnum | NotificationPermissionSuperAdminScalarFieldEnum[]
  }

  /**
   * NotificationPermissionSuperAdmin create
   */
  export type NotificationPermissionSuperAdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSuperAdmin
     */
    select?: NotificationPermissionSuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSuperAdmin
     */
    omit?: NotificationPermissionSuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSuperAdminInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPermissionSuperAdmin.
     */
    data: XOR<NotificationPermissionSuperAdminCreateInput, NotificationPermissionSuperAdminUncheckedCreateInput>
  }

  /**
   * NotificationPermissionSuperAdmin createMany
   */
  export type NotificationPermissionSuperAdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPermissionSuperAdmins.
     */
    data: NotificationPermissionSuperAdminCreateManyInput | NotificationPermissionSuperAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationPermissionSuperAdmin createManyAndReturn
   */
  export type NotificationPermissionSuperAdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSuperAdmin
     */
    select?: NotificationPermissionSuperAdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSuperAdmin
     */
    omit?: NotificationPermissionSuperAdminOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationPermissionSuperAdmins.
     */
    data: NotificationPermissionSuperAdminCreateManyInput | NotificationPermissionSuperAdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSuperAdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPermissionSuperAdmin update
   */
  export type NotificationPermissionSuperAdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSuperAdmin
     */
    select?: NotificationPermissionSuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSuperAdmin
     */
    omit?: NotificationPermissionSuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSuperAdminInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPermissionSuperAdmin.
     */
    data: XOR<NotificationPermissionSuperAdminUpdateInput, NotificationPermissionSuperAdminUncheckedUpdateInput>
    /**
     * Choose, which NotificationPermissionSuperAdmin to update.
     */
    where: NotificationPermissionSuperAdminWhereUniqueInput
  }

  /**
   * NotificationPermissionSuperAdmin updateMany
   */
  export type NotificationPermissionSuperAdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPermissionSuperAdmins.
     */
    data: XOR<NotificationPermissionSuperAdminUpdateManyMutationInput, NotificationPermissionSuperAdminUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPermissionSuperAdmins to update
     */
    where?: NotificationPermissionSuperAdminWhereInput
    /**
     * Limit how many NotificationPermissionSuperAdmins to update.
     */
    limit?: number
  }

  /**
   * NotificationPermissionSuperAdmin updateManyAndReturn
   */
  export type NotificationPermissionSuperAdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSuperAdmin
     */
    select?: NotificationPermissionSuperAdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSuperAdmin
     */
    omit?: NotificationPermissionSuperAdminOmit<ExtArgs> | null
    /**
     * The data used to update NotificationPermissionSuperAdmins.
     */
    data: XOR<NotificationPermissionSuperAdminUpdateManyMutationInput, NotificationPermissionSuperAdminUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPermissionSuperAdmins to update
     */
    where?: NotificationPermissionSuperAdminWhereInput
    /**
     * Limit how many NotificationPermissionSuperAdmins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSuperAdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPermissionSuperAdmin upsert
   */
  export type NotificationPermissionSuperAdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSuperAdmin
     */
    select?: NotificationPermissionSuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSuperAdmin
     */
    omit?: NotificationPermissionSuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSuperAdminInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPermissionSuperAdmin to update in case it exists.
     */
    where: NotificationPermissionSuperAdminWhereUniqueInput
    /**
     * In case the NotificationPermissionSuperAdmin found by the `where` argument doesn't exist, create a new NotificationPermissionSuperAdmin with this data.
     */
    create: XOR<NotificationPermissionSuperAdminCreateInput, NotificationPermissionSuperAdminUncheckedCreateInput>
    /**
     * In case the NotificationPermissionSuperAdmin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPermissionSuperAdminUpdateInput, NotificationPermissionSuperAdminUncheckedUpdateInput>
  }

  /**
   * NotificationPermissionSuperAdmin delete
   */
  export type NotificationPermissionSuperAdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSuperAdmin
     */
    select?: NotificationPermissionSuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSuperAdmin
     */
    omit?: NotificationPermissionSuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSuperAdminInclude<ExtArgs> | null
    /**
     * Filter which NotificationPermissionSuperAdmin to delete.
     */
    where: NotificationPermissionSuperAdminWhereUniqueInput
  }

  /**
   * NotificationPermissionSuperAdmin deleteMany
   */
  export type NotificationPermissionSuperAdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPermissionSuperAdmins to delete
     */
    where?: NotificationPermissionSuperAdminWhereInput
    /**
     * Limit how many NotificationPermissionSuperAdmins to delete.
     */
    limit?: number
  }

  /**
   * NotificationPermissionSuperAdmin without action
   */
  export type NotificationPermissionSuperAdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSuperAdmin
     */
    select?: NotificationPermissionSuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSuperAdmin
     */
    omit?: NotificationPermissionSuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSuperAdminInclude<ExtArgs> | null
  }


  /**
   * Model Program
   */

  export type AggregateProgram = {
    _count: ProgramCountAggregateOutputType | null
    _avg: ProgramAvgAggregateOutputType | null
    _sum: ProgramSumAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  export type ProgramAvgAggregateOutputType = {
    progress: number | null
  }

  export type ProgramSumAggregateOutputType = {
    progress: number | null
  }

  export type ProgramMinAggregateOutputType = {
    id: string | null
    userId: string | null
    programName: string | null
    datetime: string | null
    programDescription: string | null
    priority: string | null
    deadline: string | null
    progress: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    programName: string | null
    datetime: string | null
    programDescription: string | null
    priority: string | null
    deadline: string | null
    progress: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramCountAggregateOutputType = {
    id: number
    userId: number
    programName: number
    datetime: number
    programDescription: number
    priority: number
    deadline: number
    progress: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProgramAvgAggregateInputType = {
    progress?: true
  }

  export type ProgramSumAggregateInputType = {
    progress?: true
  }

  export type ProgramMinAggregateInputType = {
    id?: true
    userId?: true
    programName?: true
    datetime?: true
    programDescription?: true
    priority?: true
    deadline?: true
    progress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramMaxAggregateInputType = {
    id?: true
    userId?: true
    programName?: true
    datetime?: true
    programDescription?: true
    priority?: true
    deadline?: true
    progress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramCountAggregateInputType = {
    id?: true
    userId?: true
    programName?: true
    datetime?: true
    programDescription?: true
    priority?: true
    deadline?: true
    progress?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Program to aggregate.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Programs
    **/
    _count?: true | ProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramMaxAggregateInputType
  }

  export type GetProgramAggregateType<T extends ProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgram[P]>
      : GetScalarType<T[P], AggregateProgram[P]>
  }




  export type ProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithAggregationInput | ProgramOrderByWithAggregationInput[]
    by: ProgramScalarFieldEnum[] | ProgramScalarFieldEnum
    having?: ProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramCountAggregateInputType | true
    _avg?: ProgramAvgAggregateInputType
    _sum?: ProgramSumAggregateInputType
    _min?: ProgramMinAggregateInputType
    _max?: ProgramMaxAggregateInputType
  }

  export type ProgramGroupByOutputType = {
    id: string
    userId: string
    programName: string
    datetime: string
    programDescription: string
    priority: string
    deadline: string
    progress: number | null
    createdAt: Date
    updatedAt: Date
    _count: ProgramCountAggregateOutputType | null
    _avg: ProgramAvgAggregateOutputType | null
    _sum: ProgramSumAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  type GetProgramGroupByPayload<T extends ProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramGroupByOutputType[P]>
        }
      >
    >


  export type ProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    programName?: boolean
    datetime?: boolean
    programDescription?: boolean
    priority?: boolean
    deadline?: boolean
    progress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    projects?: boolean | Program$projectsArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    programName?: boolean
    datetime?: boolean
    programDescription?: boolean
    priority?: boolean
    deadline?: boolean
    progress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    programName?: boolean
    datetime?: boolean
    programDescription?: boolean
    priority?: boolean
    deadline?: boolean
    progress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectScalar = {
    id?: boolean
    userId?: boolean
    programName?: boolean
    datetime?: boolean
    programDescription?: boolean
    priority?: boolean
    deadline?: boolean
    progress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "programName" | "datetime" | "programDescription" | "priority" | "deadline" | "progress" | "createdAt" | "updatedAt", ExtArgs["result"]["program"]>
  export type ProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    projects?: boolean | Program$projectsArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type ProgramIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $ProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Program"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      projects: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      programName: string
      datetime: string
      programDescription: string
      priority: string
      deadline: string
      progress: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["program"]>
    composites: {}
  }

  type ProgramGetPayload<S extends boolean | null | undefined | ProgramDefaultArgs> = $Result.GetResult<Prisma.$ProgramPayload, S>

  type ProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProgramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgramCountAggregateInputType | true
    }

  export interface ProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Program'], meta: { name: 'Program' } }
    /**
     * Find zero or one Program that matches the filter.
     * @param {ProgramFindUniqueArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramFindUniqueArgs>(args: SelectSubset<T, ProgramFindUniqueArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Program that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProgramFindUniqueOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Program that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramFindFirstArgs>(args?: SelectSubset<T, ProgramFindFirstArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Program that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Programs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Programs
     * const programs = await prisma.program.findMany()
     * 
     * // Get first 10 Programs
     * const programs = await prisma.program.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programWithIdOnly = await prisma.program.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramFindManyArgs>(args?: SelectSubset<T, ProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Program.
     * @param {ProgramCreateArgs} args - Arguments to create a Program.
     * @example
     * // Create one Program
     * const Program = await prisma.program.create({
     *   data: {
     *     // ... data to create a Program
     *   }
     * })
     * 
     */
    create<T extends ProgramCreateArgs>(args: SelectSubset<T, ProgramCreateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Programs.
     * @param {ProgramCreateManyArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const program = await prisma.program.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramCreateManyArgs>(args?: SelectSubset<T, ProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Programs and returns the data saved in the database.
     * @param {ProgramCreateManyAndReturnArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const program = await prisma.program.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Programs and only return the `id`
     * const programWithIdOnly = await prisma.program.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Program.
     * @param {ProgramDeleteArgs} args - Arguments to delete one Program.
     * @example
     * // Delete one Program
     * const Program = await prisma.program.delete({
     *   where: {
     *     // ... filter to delete one Program
     *   }
     * })
     * 
     */
    delete<T extends ProgramDeleteArgs>(args: SelectSubset<T, ProgramDeleteArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Program.
     * @param {ProgramUpdateArgs} args - Arguments to update one Program.
     * @example
     * // Update one Program
     * const program = await prisma.program.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramUpdateArgs>(args: SelectSubset<T, ProgramUpdateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Programs.
     * @param {ProgramDeleteManyArgs} args - Arguments to filter Programs to delete.
     * @example
     * // Delete a few Programs
     * const { count } = await prisma.program.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramDeleteManyArgs>(args?: SelectSubset<T, ProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Programs
     * const program = await prisma.program.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramUpdateManyArgs>(args: SelectSubset<T, ProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programs and returns the data updated in the database.
     * @param {ProgramUpdateManyAndReturnArgs} args - Arguments to update many Programs.
     * @example
     * // Update many Programs
     * const program = await prisma.program.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Programs and only return the `id`
     * const programWithIdOnly = await prisma.program.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProgramUpdateManyAndReturnArgs>(args: SelectSubset<T, ProgramUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Program.
     * @param {ProgramUpsertArgs} args - Arguments to update or create a Program.
     * @example
     * // Update or create a Program
     * const program = await prisma.program.upsert({
     *   create: {
     *     // ... data to create a Program
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Program we want to update
     *   }
     * })
     */
    upsert<T extends ProgramUpsertArgs>(args: SelectSubset<T, ProgramUpsertArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCountArgs} args - Arguments to filter Programs to count.
     * @example
     * // Count the number of Programs
     * const count = await prisma.program.count({
     *   where: {
     *     // ... the filter for the Programs we want to count
     *   }
     * })
    **/
    count<T extends ProgramCountArgs>(
      args?: Subset<T, ProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramAggregateArgs>(args: Subset<T, ProgramAggregateArgs>): Prisma.PrismaPromise<GetProgramAggregateType<T>>

    /**
     * Group by Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramGroupByArgs['orderBy'] }
        : { orderBy?: ProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Program model
   */
  readonly fields: ProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Program.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    projects<T extends Program$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Program$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Program model
   */
  interface ProgramFieldRefs {
    readonly id: FieldRef<"Program", 'String'>
    readonly userId: FieldRef<"Program", 'String'>
    readonly programName: FieldRef<"Program", 'String'>
    readonly datetime: FieldRef<"Program", 'String'>
    readonly programDescription: FieldRef<"Program", 'String'>
    readonly priority: FieldRef<"Program", 'String'>
    readonly deadline: FieldRef<"Program", 'String'>
    readonly progress: FieldRef<"Program", 'Int'>
    readonly createdAt: FieldRef<"Program", 'DateTime'>
    readonly updatedAt: FieldRef<"Program", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Program findUnique
   */
  export type ProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findUniqueOrThrow
   */
  export type ProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findFirst
   */
  export type ProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findFirstOrThrow
   */
  export type ProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findMany
   */
  export type ProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Programs to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program create
   */
  export type ProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a Program.
     */
    data: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
  }

  /**
   * Program createMany
   */
  export type ProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Program createManyAndReturn
   */
  export type ProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Program update
   */
  export type ProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a Program.
     */
    data: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
    /**
     * Choose, which Program to update.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program updateMany
   */
  export type ProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Programs.
     */
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>
    /**
     * Filter which Programs to update
     */
    where?: ProgramWhereInput
    /**
     * Limit how many Programs to update.
     */
    limit?: number
  }

  /**
   * Program updateManyAndReturn
   */
  export type ProgramUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * The data used to update Programs.
     */
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>
    /**
     * Filter which Programs to update
     */
    where?: ProgramWhereInput
    /**
     * Limit how many Programs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Program upsert
   */
  export type ProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the Program to update in case it exists.
     */
    where: ProgramWhereUniqueInput
    /**
     * In case the Program found by the `where` argument doesn't exist, create a new Program with this data.
     */
    create: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
    /**
     * In case the Program was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
  }

  /**
   * Program delete
   */
  export type ProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter which Program to delete.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program deleteMany
   */
  export type ProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programs to delete
     */
    where?: ProgramWhereInput
    /**
     * Limit how many Programs to delete.
     */
    limit?: number
  }

  /**
   * Program.projects
   */
  export type Program$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Program without action
   */
  export type ProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    beforeSubmitData: number | null
    progress: number | null
    latitude: number | null
    longitude: number | null
  }

  export type ProjectSumAggregateOutputType = {
    beforeSubmitData: number | null
    progress: number | null
    latitude: number | null
    longitude: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    programId: string | null
    name: string | null
    uploadbeforeday: string | null
    uploadCycle: $Enums.ProjectCycle | null
    description: string | null
    dataReceivedTime: string | null
    beforeSubmitData: number | null
    status: $Enums.ProjectStatus | null
    priority: $Enums.Priority | null
    deadline: Date | null
    managerId: string | null
    startDate: Date | null
    progress: number | null
    estimatedCompletedDate: Date | null
    currentRate: string | null
    budget: string | null
    createdAt: Date | null
    updatedAt: Date | null
    latitude: number | null
    longitude: number | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    programId: string | null
    name: string | null
    uploadbeforeday: string | null
    uploadCycle: $Enums.ProjectCycle | null
    description: string | null
    dataReceivedTime: string | null
    beforeSubmitData: number | null
    status: $Enums.ProjectStatus | null
    priority: $Enums.Priority | null
    deadline: Date | null
    managerId: string | null
    startDate: Date | null
    progress: number | null
    estimatedCompletedDate: Date | null
    currentRate: string | null
    budget: string | null
    createdAt: Date | null
    updatedAt: Date | null
    latitude: number | null
    longitude: number | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    programId: number
    name: number
    uploadbeforeday: number
    uploadCycle: number
    description: number
    dataReceivedTime: number
    beforeSubmitData: number
    weakuploadData: number
    monthlyuploadData: number
    status: number
    priority: number
    deadline: number
    managerId: number
    startDate: number
    progress: number
    chartList: number
    estimatedCompletedDate: number
    currentRate: number
    budget: number
    createdAt: number
    updatedAt: number
    latitude: number
    longitude: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    beforeSubmitData?: true
    progress?: true
    latitude?: true
    longitude?: true
  }

  export type ProjectSumAggregateInputType = {
    beforeSubmitData?: true
    progress?: true
    latitude?: true
    longitude?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    programId?: true
    name?: true
    uploadbeforeday?: true
    uploadCycle?: true
    description?: true
    dataReceivedTime?: true
    beforeSubmitData?: true
    status?: true
    priority?: true
    deadline?: true
    managerId?: true
    startDate?: true
    progress?: true
    estimatedCompletedDate?: true
    currentRate?: true
    budget?: true
    createdAt?: true
    updatedAt?: true
    latitude?: true
    longitude?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    programId?: true
    name?: true
    uploadbeforeday?: true
    uploadCycle?: true
    description?: true
    dataReceivedTime?: true
    beforeSubmitData?: true
    status?: true
    priority?: true
    deadline?: true
    managerId?: true
    startDate?: true
    progress?: true
    estimatedCompletedDate?: true
    currentRate?: true
    budget?: true
    createdAt?: true
    updatedAt?: true
    latitude?: true
    longitude?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    programId?: true
    name?: true
    uploadbeforeday?: true
    uploadCycle?: true
    description?: true
    dataReceivedTime?: true
    beforeSubmitData?: true
    weakuploadData?: true
    monthlyuploadData?: true
    status?: true
    priority?: true
    deadline?: true
    managerId?: true
    startDate?: true
    progress?: true
    chartList?: true
    estimatedCompletedDate?: true
    currentRate?: true
    budget?: true
    createdAt?: true
    updatedAt?: true
    latitude?: true
    longitude?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    programId: string
    name: string
    uploadbeforeday: string
    uploadCycle: $Enums.ProjectCycle
    description: string
    dataReceivedTime: string | null
    beforeSubmitData: number | null
    weakuploadData: string[]
    monthlyuploadData: string[]
    status: $Enums.ProjectStatus
    priority: $Enums.Priority
    deadline: Date
    managerId: string
    startDate: Date | null
    progress: number | null
    chartList: string[]
    estimatedCompletedDate: Date | null
    currentRate: string | null
    budget: string | null
    createdAt: Date
    updatedAt: Date
    latitude: number | null
    longitude: number | null
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    name?: boolean
    uploadbeforeday?: boolean
    uploadCycle?: boolean
    description?: boolean
    dataReceivedTime?: boolean
    beforeSubmitData?: boolean
    weakuploadData?: boolean
    monthlyuploadData?: boolean
    status?: boolean
    priority?: boolean
    deadline?: boolean
    managerId?: boolean
    startDate?: boolean
    progress?: boolean
    chartList?: boolean
    estimatedCompletedDate?: boolean
    currentRate?: boolean
    budget?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    latitude?: boolean
    longitude?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
    projectEmployees?: boolean | Project$projectEmployeesArgs<ExtArgs>
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    activities?: boolean | Project$activitiesArgs<ExtArgs>
    reviews?: boolean | Project$reviewsArgs<ExtArgs>
    requestsToAddProjectMember?: boolean | Project$requestsToAddProjectMemberArgs<ExtArgs>
    submitted?: boolean | Project$submittedArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    name?: boolean
    uploadbeforeday?: boolean
    uploadCycle?: boolean
    description?: boolean
    dataReceivedTime?: boolean
    beforeSubmitData?: boolean
    weakuploadData?: boolean
    monthlyuploadData?: boolean
    status?: boolean
    priority?: boolean
    deadline?: boolean
    managerId?: boolean
    startDate?: boolean
    progress?: boolean
    chartList?: boolean
    estimatedCompletedDate?: boolean
    currentRate?: boolean
    budget?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    latitude?: boolean
    longitude?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    name?: boolean
    uploadbeforeday?: boolean
    uploadCycle?: boolean
    description?: boolean
    dataReceivedTime?: boolean
    beforeSubmitData?: boolean
    weakuploadData?: boolean
    monthlyuploadData?: boolean
    status?: boolean
    priority?: boolean
    deadline?: boolean
    managerId?: boolean
    startDate?: boolean
    progress?: boolean
    chartList?: boolean
    estimatedCompletedDate?: boolean
    currentRate?: boolean
    budget?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    latitude?: boolean
    longitude?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    programId?: boolean
    name?: boolean
    uploadbeforeday?: boolean
    uploadCycle?: boolean
    description?: boolean
    dataReceivedTime?: boolean
    beforeSubmitData?: boolean
    weakuploadData?: boolean
    monthlyuploadData?: boolean
    status?: boolean
    priority?: boolean
    deadline?: boolean
    managerId?: boolean
    startDate?: boolean
    progress?: boolean
    chartList?: boolean
    estimatedCompletedDate?: boolean
    currentRate?: boolean
    budget?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    latitude?: boolean
    longitude?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "programId" | "name" | "uploadbeforeday" | "uploadCycle" | "description" | "dataReceivedTime" | "beforeSubmitData" | "weakuploadData" | "monthlyuploadData" | "status" | "priority" | "deadline" | "managerId" | "startDate" | "progress" | "chartList" | "estimatedCompletedDate" | "currentRate" | "budget" | "createdAt" | "updatedAt" | "latitude" | "longitude", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
    projectEmployees?: boolean | Project$projectEmployeesArgs<ExtArgs>
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    activities?: boolean | Project$activitiesArgs<ExtArgs>
    reviews?: boolean | Project$reviewsArgs<ExtArgs>
    requestsToAddProjectMember?: boolean | Project$requestsToAddProjectMemberArgs<ExtArgs>
    submitted?: boolean | Project$submittedArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs>
      manager: Prisma.$ManagerPayload<ExtArgs>
      projectEmployees: Prisma.$ProjectEmployeePayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      requestsToAddProjectMember: Prisma.$RequestToAddProjectMemberPayload<ExtArgs>[]
      submitted: Prisma.$SubmittedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      programId: string
      name: string
      uploadbeforeday: string
      uploadCycle: $Enums.ProjectCycle
      description: string
      dataReceivedTime: string | null
      beforeSubmitData: number | null
      weakuploadData: string[]
      monthlyuploadData: string[]
      status: $Enums.ProjectStatus
      priority: $Enums.Priority
      deadline: Date
      managerId: string
      startDate: Date | null
      progress: number | null
      chartList: string[]
      estimatedCompletedDate: Date | null
      currentRate: string | null
      budget: string | null
      createdAt: Date
      updatedAt: Date
      latitude: number | null
      longitude: number | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    manager<T extends ManagerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ManagerDefaultArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    projectEmployees<T extends Project$projectEmployeesArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectEmployeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectEmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends Project$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Project$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends Project$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Project$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Project$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Project$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requestsToAddProjectMember<T extends Project$requestsToAddProjectMemberArgs<ExtArgs> = {}>(args?: Subset<T, Project$requestsToAddProjectMemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestToAddProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    submitted<T extends Project$submittedArgs<ExtArgs> = {}>(args?: Subset<T, Project$submittedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmittedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly programId: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly uploadbeforeday: FieldRef<"Project", 'String'>
    readonly uploadCycle: FieldRef<"Project", 'ProjectCycle'>
    readonly description: FieldRef<"Project", 'String'>
    readonly dataReceivedTime: FieldRef<"Project", 'String'>
    readonly beforeSubmitData: FieldRef<"Project", 'Int'>
    readonly weakuploadData: FieldRef<"Project", 'String[]'>
    readonly monthlyuploadData: FieldRef<"Project", 'String[]'>
    readonly status: FieldRef<"Project", 'ProjectStatus'>
    readonly priority: FieldRef<"Project", 'Priority'>
    readonly deadline: FieldRef<"Project", 'DateTime'>
    readonly managerId: FieldRef<"Project", 'String'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly progress: FieldRef<"Project", 'Int'>
    readonly chartList: FieldRef<"Project", 'String[]'>
    readonly estimatedCompletedDate: FieldRef<"Project", 'DateTime'>
    readonly currentRate: FieldRef<"Project", 'String'>
    readonly budget: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly latitude: FieldRef<"Project", 'Float'>
    readonly longitude: FieldRef<"Project", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.projectEmployees
   */
  export type Project$projectEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEmployee
     */
    select?: ProjectEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEmployee
     */
    omit?: ProjectEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEmployeeInclude<ExtArgs> | null
    where?: ProjectEmployeeWhereInput
    orderBy?: ProjectEmployeeOrderByWithRelationInput | ProjectEmployeeOrderByWithRelationInput[]
    cursor?: ProjectEmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectEmployeeScalarFieldEnum | ProjectEmployeeScalarFieldEnum[]
  }

  /**
   * Project.tasks
   */
  export type Project$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Project.activities
   */
  export type Project$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Project.reviews
   */
  export type Project$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Project.requestsToAddProjectMember
   */
  export type Project$requestsToAddProjectMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestToAddProjectMember
     */
    select?: RequestToAddProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestToAddProjectMember
     */
    omit?: RequestToAddProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestToAddProjectMemberInclude<ExtArgs> | null
    where?: RequestToAddProjectMemberWhereInput
    orderBy?: RequestToAddProjectMemberOrderByWithRelationInput | RequestToAddProjectMemberOrderByWithRelationInput[]
    cursor?: RequestToAddProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestToAddProjectMemberScalarFieldEnum | RequestToAddProjectMemberScalarFieldEnum[]
  }

  /**
   * Project.submitted
   */
  export type Project$submittedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submitted
     */
    select?: SubmittedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submitted
     */
    omit?: SubmittedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmittedInclude<ExtArgs> | null
    where?: SubmittedWhereInput
    orderBy?: SubmittedOrderByWithRelationInput | SubmittedOrderByWithRelationInput[]
    cursor?: SubmittedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubmittedScalarFieldEnum | SubmittedScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectEmployee
   */

  export type AggregateProjectEmployee = {
    _count: ProjectEmployeeCountAggregateOutputType | null
    _min: ProjectEmployeeMinAggregateOutputType | null
    _max: ProjectEmployeeMaxAggregateOutputType | null
  }

  export type ProjectEmployeeMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    employeeId: string | null
    assignedAt: Date | null
  }

  export type ProjectEmployeeMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    employeeId: string | null
    assignedAt: Date | null
  }

  export type ProjectEmployeeCountAggregateOutputType = {
    id: number
    projectId: number
    employeeId: number
    assignedAt: number
    _all: number
  }


  export type ProjectEmployeeMinAggregateInputType = {
    id?: true
    projectId?: true
    employeeId?: true
    assignedAt?: true
  }

  export type ProjectEmployeeMaxAggregateInputType = {
    id?: true
    projectId?: true
    employeeId?: true
    assignedAt?: true
  }

  export type ProjectEmployeeCountAggregateInputType = {
    id?: true
    projectId?: true
    employeeId?: true
    assignedAt?: true
    _all?: true
  }

  export type ProjectEmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectEmployee to aggregate.
     */
    where?: ProjectEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectEmployees to fetch.
     */
    orderBy?: ProjectEmployeeOrderByWithRelationInput | ProjectEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectEmployees
    **/
    _count?: true | ProjectEmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectEmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectEmployeeMaxAggregateInputType
  }

  export type GetProjectEmployeeAggregateType<T extends ProjectEmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectEmployee[P]>
      : GetScalarType<T[P], AggregateProjectEmployee[P]>
  }




  export type ProjectEmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectEmployeeWhereInput
    orderBy?: ProjectEmployeeOrderByWithAggregationInput | ProjectEmployeeOrderByWithAggregationInput[]
    by: ProjectEmployeeScalarFieldEnum[] | ProjectEmployeeScalarFieldEnum
    having?: ProjectEmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectEmployeeCountAggregateInputType | true
    _min?: ProjectEmployeeMinAggregateInputType
    _max?: ProjectEmployeeMaxAggregateInputType
  }

  export type ProjectEmployeeGroupByOutputType = {
    id: string
    projectId: string
    employeeId: string
    assignedAt: Date
    _count: ProjectEmployeeCountAggregateOutputType | null
    _min: ProjectEmployeeMinAggregateOutputType | null
    _max: ProjectEmployeeMaxAggregateOutputType | null
  }

  type GetProjectEmployeeGroupByPayload<T extends ProjectEmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectEmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectEmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectEmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectEmployeeGroupByOutputType[P]>
        }
      >
    >


  export type ProjectEmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    employeeId?: boolean
    assignedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectEmployee"]>

  export type ProjectEmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    employeeId?: boolean
    assignedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectEmployee"]>

  export type ProjectEmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    employeeId?: boolean
    assignedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectEmployee"]>

  export type ProjectEmployeeSelectScalar = {
    id?: boolean
    projectId?: boolean
    employeeId?: boolean
    assignedAt?: boolean
  }

  export type ProjectEmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "employeeId" | "assignedAt", ExtArgs["result"]["projectEmployee"]>
  export type ProjectEmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type ProjectEmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type ProjectEmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $ProjectEmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectEmployee"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      employeeId: string
      assignedAt: Date
    }, ExtArgs["result"]["projectEmployee"]>
    composites: {}
  }

  type ProjectEmployeeGetPayload<S extends boolean | null | undefined | ProjectEmployeeDefaultArgs> = $Result.GetResult<Prisma.$ProjectEmployeePayload, S>

  type ProjectEmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectEmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectEmployeeCountAggregateInputType | true
    }

  export interface ProjectEmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectEmployee'], meta: { name: 'ProjectEmployee' } }
    /**
     * Find zero or one ProjectEmployee that matches the filter.
     * @param {ProjectEmployeeFindUniqueArgs} args - Arguments to find a ProjectEmployee
     * @example
     * // Get one ProjectEmployee
     * const projectEmployee = await prisma.projectEmployee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectEmployeeFindUniqueArgs>(args: SelectSubset<T, ProjectEmployeeFindUniqueArgs<ExtArgs>>): Prisma__ProjectEmployeeClient<$Result.GetResult<Prisma.$ProjectEmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectEmployee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectEmployeeFindUniqueOrThrowArgs} args - Arguments to find a ProjectEmployee
     * @example
     * // Get one ProjectEmployee
     * const projectEmployee = await prisma.projectEmployee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectEmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectEmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectEmployeeClient<$Result.GetResult<Prisma.$ProjectEmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectEmployee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectEmployeeFindFirstArgs} args - Arguments to find a ProjectEmployee
     * @example
     * // Get one ProjectEmployee
     * const projectEmployee = await prisma.projectEmployee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectEmployeeFindFirstArgs>(args?: SelectSubset<T, ProjectEmployeeFindFirstArgs<ExtArgs>>): Prisma__ProjectEmployeeClient<$Result.GetResult<Prisma.$ProjectEmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectEmployee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectEmployeeFindFirstOrThrowArgs} args - Arguments to find a ProjectEmployee
     * @example
     * // Get one ProjectEmployee
     * const projectEmployee = await prisma.projectEmployee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectEmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectEmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectEmployeeClient<$Result.GetResult<Prisma.$ProjectEmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectEmployees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectEmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectEmployees
     * const projectEmployees = await prisma.projectEmployee.findMany()
     * 
     * // Get first 10 ProjectEmployees
     * const projectEmployees = await prisma.projectEmployee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectEmployeeWithIdOnly = await prisma.projectEmployee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectEmployeeFindManyArgs>(args?: SelectSubset<T, ProjectEmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectEmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectEmployee.
     * @param {ProjectEmployeeCreateArgs} args - Arguments to create a ProjectEmployee.
     * @example
     * // Create one ProjectEmployee
     * const ProjectEmployee = await prisma.projectEmployee.create({
     *   data: {
     *     // ... data to create a ProjectEmployee
     *   }
     * })
     * 
     */
    create<T extends ProjectEmployeeCreateArgs>(args: SelectSubset<T, ProjectEmployeeCreateArgs<ExtArgs>>): Prisma__ProjectEmployeeClient<$Result.GetResult<Prisma.$ProjectEmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectEmployees.
     * @param {ProjectEmployeeCreateManyArgs} args - Arguments to create many ProjectEmployees.
     * @example
     * // Create many ProjectEmployees
     * const projectEmployee = await prisma.projectEmployee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectEmployeeCreateManyArgs>(args?: SelectSubset<T, ProjectEmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectEmployees and returns the data saved in the database.
     * @param {ProjectEmployeeCreateManyAndReturnArgs} args - Arguments to create many ProjectEmployees.
     * @example
     * // Create many ProjectEmployees
     * const projectEmployee = await prisma.projectEmployee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectEmployees and only return the `id`
     * const projectEmployeeWithIdOnly = await prisma.projectEmployee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectEmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectEmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectEmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectEmployee.
     * @param {ProjectEmployeeDeleteArgs} args - Arguments to delete one ProjectEmployee.
     * @example
     * // Delete one ProjectEmployee
     * const ProjectEmployee = await prisma.projectEmployee.delete({
     *   where: {
     *     // ... filter to delete one ProjectEmployee
     *   }
     * })
     * 
     */
    delete<T extends ProjectEmployeeDeleteArgs>(args: SelectSubset<T, ProjectEmployeeDeleteArgs<ExtArgs>>): Prisma__ProjectEmployeeClient<$Result.GetResult<Prisma.$ProjectEmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectEmployee.
     * @param {ProjectEmployeeUpdateArgs} args - Arguments to update one ProjectEmployee.
     * @example
     * // Update one ProjectEmployee
     * const projectEmployee = await prisma.projectEmployee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectEmployeeUpdateArgs>(args: SelectSubset<T, ProjectEmployeeUpdateArgs<ExtArgs>>): Prisma__ProjectEmployeeClient<$Result.GetResult<Prisma.$ProjectEmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectEmployees.
     * @param {ProjectEmployeeDeleteManyArgs} args - Arguments to filter ProjectEmployees to delete.
     * @example
     * // Delete a few ProjectEmployees
     * const { count } = await prisma.projectEmployee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectEmployeeDeleteManyArgs>(args?: SelectSubset<T, ProjectEmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectEmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectEmployees
     * const projectEmployee = await prisma.projectEmployee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectEmployeeUpdateManyArgs>(args: SelectSubset<T, ProjectEmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectEmployees and returns the data updated in the database.
     * @param {ProjectEmployeeUpdateManyAndReturnArgs} args - Arguments to update many ProjectEmployees.
     * @example
     * // Update many ProjectEmployees
     * const projectEmployee = await prisma.projectEmployee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectEmployees and only return the `id`
     * const projectEmployeeWithIdOnly = await prisma.projectEmployee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectEmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectEmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectEmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectEmployee.
     * @param {ProjectEmployeeUpsertArgs} args - Arguments to update or create a ProjectEmployee.
     * @example
     * // Update or create a ProjectEmployee
     * const projectEmployee = await prisma.projectEmployee.upsert({
     *   create: {
     *     // ... data to create a ProjectEmployee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectEmployee we want to update
     *   }
     * })
     */
    upsert<T extends ProjectEmployeeUpsertArgs>(args: SelectSubset<T, ProjectEmployeeUpsertArgs<ExtArgs>>): Prisma__ProjectEmployeeClient<$Result.GetResult<Prisma.$ProjectEmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectEmployeeCountArgs} args - Arguments to filter ProjectEmployees to count.
     * @example
     * // Count the number of ProjectEmployees
     * const count = await prisma.projectEmployee.count({
     *   where: {
     *     // ... the filter for the ProjectEmployees we want to count
     *   }
     * })
    **/
    count<T extends ProjectEmployeeCountArgs>(
      args?: Subset<T, ProjectEmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectEmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectEmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectEmployeeAggregateArgs>(args: Subset<T, ProjectEmployeeAggregateArgs>): Prisma.PrismaPromise<GetProjectEmployeeAggregateType<T>>

    /**
     * Group by ProjectEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectEmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectEmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectEmployeeGroupByArgs['orderBy'] }
        : { orderBy?: ProjectEmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectEmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectEmployee model
   */
  readonly fields: ProjectEmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectEmployee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectEmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectEmployee model
   */
  interface ProjectEmployeeFieldRefs {
    readonly id: FieldRef<"ProjectEmployee", 'String'>
    readonly projectId: FieldRef<"ProjectEmployee", 'String'>
    readonly employeeId: FieldRef<"ProjectEmployee", 'String'>
    readonly assignedAt: FieldRef<"ProjectEmployee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectEmployee findUnique
   */
  export type ProjectEmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEmployee
     */
    select?: ProjectEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEmployee
     */
    omit?: ProjectEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which ProjectEmployee to fetch.
     */
    where: ProjectEmployeeWhereUniqueInput
  }

  /**
   * ProjectEmployee findUniqueOrThrow
   */
  export type ProjectEmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEmployee
     */
    select?: ProjectEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEmployee
     */
    omit?: ProjectEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which ProjectEmployee to fetch.
     */
    where: ProjectEmployeeWhereUniqueInput
  }

  /**
   * ProjectEmployee findFirst
   */
  export type ProjectEmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEmployee
     */
    select?: ProjectEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEmployee
     */
    omit?: ProjectEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which ProjectEmployee to fetch.
     */
    where?: ProjectEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectEmployees to fetch.
     */
    orderBy?: ProjectEmployeeOrderByWithRelationInput | ProjectEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectEmployees.
     */
    cursor?: ProjectEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectEmployees.
     */
    distinct?: ProjectEmployeeScalarFieldEnum | ProjectEmployeeScalarFieldEnum[]
  }

  /**
   * ProjectEmployee findFirstOrThrow
   */
  export type ProjectEmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEmployee
     */
    select?: ProjectEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEmployee
     */
    omit?: ProjectEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which ProjectEmployee to fetch.
     */
    where?: ProjectEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectEmployees to fetch.
     */
    orderBy?: ProjectEmployeeOrderByWithRelationInput | ProjectEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectEmployees.
     */
    cursor?: ProjectEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectEmployees.
     */
    distinct?: ProjectEmployeeScalarFieldEnum | ProjectEmployeeScalarFieldEnum[]
  }

  /**
   * ProjectEmployee findMany
   */
  export type ProjectEmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEmployee
     */
    select?: ProjectEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEmployee
     */
    omit?: ProjectEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which ProjectEmployees to fetch.
     */
    where?: ProjectEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectEmployees to fetch.
     */
    orderBy?: ProjectEmployeeOrderByWithRelationInput | ProjectEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectEmployees.
     */
    cursor?: ProjectEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectEmployees.
     */
    skip?: number
    distinct?: ProjectEmployeeScalarFieldEnum | ProjectEmployeeScalarFieldEnum[]
  }

  /**
   * ProjectEmployee create
   */
  export type ProjectEmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEmployee
     */
    select?: ProjectEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEmployee
     */
    omit?: ProjectEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectEmployee.
     */
    data: XOR<ProjectEmployeeCreateInput, ProjectEmployeeUncheckedCreateInput>
  }

  /**
   * ProjectEmployee createMany
   */
  export type ProjectEmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectEmployees.
     */
    data: ProjectEmployeeCreateManyInput | ProjectEmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectEmployee createManyAndReturn
   */
  export type ProjectEmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEmployee
     */
    select?: ProjectEmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEmployee
     */
    omit?: ProjectEmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectEmployees.
     */
    data: ProjectEmployeeCreateManyInput | ProjectEmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectEmployee update
   */
  export type ProjectEmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEmployee
     */
    select?: ProjectEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEmployee
     */
    omit?: ProjectEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectEmployee.
     */
    data: XOR<ProjectEmployeeUpdateInput, ProjectEmployeeUncheckedUpdateInput>
    /**
     * Choose, which ProjectEmployee to update.
     */
    where: ProjectEmployeeWhereUniqueInput
  }

  /**
   * ProjectEmployee updateMany
   */
  export type ProjectEmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectEmployees.
     */
    data: XOR<ProjectEmployeeUpdateManyMutationInput, ProjectEmployeeUncheckedUpdateManyInput>
    /**
     * Filter which ProjectEmployees to update
     */
    where?: ProjectEmployeeWhereInput
    /**
     * Limit how many ProjectEmployees to update.
     */
    limit?: number
  }

  /**
   * ProjectEmployee updateManyAndReturn
   */
  export type ProjectEmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEmployee
     */
    select?: ProjectEmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEmployee
     */
    omit?: ProjectEmployeeOmit<ExtArgs> | null
    /**
     * The data used to update ProjectEmployees.
     */
    data: XOR<ProjectEmployeeUpdateManyMutationInput, ProjectEmployeeUncheckedUpdateManyInput>
    /**
     * Filter which ProjectEmployees to update
     */
    where?: ProjectEmployeeWhereInput
    /**
     * Limit how many ProjectEmployees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectEmployee upsert
   */
  export type ProjectEmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEmployee
     */
    select?: ProjectEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEmployee
     */
    omit?: ProjectEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectEmployee to update in case it exists.
     */
    where: ProjectEmployeeWhereUniqueInput
    /**
     * In case the ProjectEmployee found by the `where` argument doesn't exist, create a new ProjectEmployee with this data.
     */
    create: XOR<ProjectEmployeeCreateInput, ProjectEmployeeUncheckedCreateInput>
    /**
     * In case the ProjectEmployee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectEmployeeUpdateInput, ProjectEmployeeUncheckedUpdateInput>
  }

  /**
   * ProjectEmployee delete
   */
  export type ProjectEmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEmployee
     */
    select?: ProjectEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEmployee
     */
    omit?: ProjectEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEmployeeInclude<ExtArgs> | null
    /**
     * Filter which ProjectEmployee to delete.
     */
    where: ProjectEmployeeWhereUniqueInput
  }

  /**
   * ProjectEmployee deleteMany
   */
  export type ProjectEmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectEmployees to delete
     */
    where?: ProjectEmployeeWhereInput
    /**
     * Limit how many ProjectEmployees to delete.
     */
    limit?: number
  }

  /**
   * ProjectEmployee without action
   */
  export type ProjectEmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectEmployee
     */
    select?: ProjectEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectEmployee
     */
    omit?: ProjectEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectEmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    taskAssignId: string | null
    status: $Enums.ProjectStatus | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    taskAssignId: string | null
    status: $Enums.ProjectStatus | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    projectId: number
    taskAssignId: number
    status: number
    managerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewMinAggregateInputType = {
    id?: true
    projectId?: true
    taskAssignId?: true
    status?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    projectId?: true
    taskAssignId?: true
    status?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    projectId?: true
    taskAssignId?: true
    status?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    projectId: string
    taskAssignId: string | null
    status: $Enums.ProjectStatus
    managerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    taskAssignId?: boolean
    status?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    taskAssignId?: boolean
    status?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    taskAssignId?: boolean
    status?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    projectId?: boolean
    taskAssignId?: boolean
    status?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "taskAssignId" | "status" | "managerId" | "createdAt" | "updatedAt", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      taskAssignId: string | null
      status: $Enums.ProjectStatus
      managerId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly projectId: FieldRef<"Review", 'String'>
    readonly taskAssignId: FieldRef<"Review", 'String'>
    readonly status: FieldRef<"Review", 'ProjectStatus'>
    readonly managerId: FieldRef<"Review", 'String'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Sheet
   */

  export type AggregateSheet = {
    _count: SheetCountAggregateOutputType | null
    _min: SheetMinAggregateOutputType | null
    _max: SheetMaxAggregateOutputType | null
  }

  export type SheetMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SheetMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SheetCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SheetMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SheetMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SheetCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SheetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sheet to aggregate.
     */
    where?: SheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sheets to fetch.
     */
    orderBy?: SheetOrderByWithRelationInput | SheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sheets
    **/
    _count?: true | SheetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SheetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SheetMaxAggregateInputType
  }

  export type GetSheetAggregateType<T extends SheetAggregateArgs> = {
        [P in keyof T & keyof AggregateSheet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSheet[P]>
      : GetScalarType<T[P], AggregateSheet[P]>
  }




  export type SheetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SheetWhereInput
    orderBy?: SheetOrderByWithAggregationInput | SheetOrderByWithAggregationInput[]
    by: SheetScalarFieldEnum[] | SheetScalarFieldEnum
    having?: SheetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SheetCountAggregateInputType | true
    _min?: SheetMinAggregateInputType
    _max?: SheetMaxAggregateInputType
  }

  export type SheetGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: SheetCountAggregateOutputType | null
    _min: SheetMinAggregateOutputType | null
    _max: SheetMaxAggregateOutputType | null
  }

  type GetSheetGroupByPayload<T extends SheetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SheetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SheetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SheetGroupByOutputType[P]>
            : GetScalarType<T[P], SheetGroupByOutputType[P]>
        }
      >
    >


  export type SheetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    submitted?: boolean | Sheet$submittedArgs<ExtArgs>
    _count?: boolean | SheetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sheet"]>

  export type SheetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sheet"]>

  export type SheetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sheet"]>

  export type SheetSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SheetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["sheet"]>
  export type SheetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submitted?: boolean | Sheet$submittedArgs<ExtArgs>
    _count?: boolean | SheetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SheetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SheetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SheetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sheet"
    objects: {
      submitted: Prisma.$SubmittedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sheet"]>
    composites: {}
  }

  type SheetGetPayload<S extends boolean | null | undefined | SheetDefaultArgs> = $Result.GetResult<Prisma.$SheetPayload, S>

  type SheetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SheetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SheetCountAggregateInputType | true
    }

  export interface SheetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sheet'], meta: { name: 'Sheet' } }
    /**
     * Find zero or one Sheet that matches the filter.
     * @param {SheetFindUniqueArgs} args - Arguments to find a Sheet
     * @example
     * // Get one Sheet
     * const sheet = await prisma.sheet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SheetFindUniqueArgs>(args: SelectSubset<T, SheetFindUniqueArgs<ExtArgs>>): Prisma__SheetClient<$Result.GetResult<Prisma.$SheetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sheet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SheetFindUniqueOrThrowArgs} args - Arguments to find a Sheet
     * @example
     * // Get one Sheet
     * const sheet = await prisma.sheet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SheetFindUniqueOrThrowArgs>(args: SelectSubset<T, SheetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SheetClient<$Result.GetResult<Prisma.$SheetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sheet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SheetFindFirstArgs} args - Arguments to find a Sheet
     * @example
     * // Get one Sheet
     * const sheet = await prisma.sheet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SheetFindFirstArgs>(args?: SelectSubset<T, SheetFindFirstArgs<ExtArgs>>): Prisma__SheetClient<$Result.GetResult<Prisma.$SheetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sheet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SheetFindFirstOrThrowArgs} args - Arguments to find a Sheet
     * @example
     * // Get one Sheet
     * const sheet = await prisma.sheet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SheetFindFirstOrThrowArgs>(args?: SelectSubset<T, SheetFindFirstOrThrowArgs<ExtArgs>>): Prisma__SheetClient<$Result.GetResult<Prisma.$SheetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sheets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SheetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sheets
     * const sheets = await prisma.sheet.findMany()
     * 
     * // Get first 10 Sheets
     * const sheets = await prisma.sheet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sheetWithIdOnly = await prisma.sheet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SheetFindManyArgs>(args?: SelectSubset<T, SheetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SheetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sheet.
     * @param {SheetCreateArgs} args - Arguments to create a Sheet.
     * @example
     * // Create one Sheet
     * const Sheet = await prisma.sheet.create({
     *   data: {
     *     // ... data to create a Sheet
     *   }
     * })
     * 
     */
    create<T extends SheetCreateArgs>(args: SelectSubset<T, SheetCreateArgs<ExtArgs>>): Prisma__SheetClient<$Result.GetResult<Prisma.$SheetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sheets.
     * @param {SheetCreateManyArgs} args - Arguments to create many Sheets.
     * @example
     * // Create many Sheets
     * const sheet = await prisma.sheet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SheetCreateManyArgs>(args?: SelectSubset<T, SheetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sheets and returns the data saved in the database.
     * @param {SheetCreateManyAndReturnArgs} args - Arguments to create many Sheets.
     * @example
     * // Create many Sheets
     * const sheet = await prisma.sheet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sheets and only return the `id`
     * const sheetWithIdOnly = await prisma.sheet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SheetCreateManyAndReturnArgs>(args?: SelectSubset<T, SheetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SheetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sheet.
     * @param {SheetDeleteArgs} args - Arguments to delete one Sheet.
     * @example
     * // Delete one Sheet
     * const Sheet = await prisma.sheet.delete({
     *   where: {
     *     // ... filter to delete one Sheet
     *   }
     * })
     * 
     */
    delete<T extends SheetDeleteArgs>(args: SelectSubset<T, SheetDeleteArgs<ExtArgs>>): Prisma__SheetClient<$Result.GetResult<Prisma.$SheetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sheet.
     * @param {SheetUpdateArgs} args - Arguments to update one Sheet.
     * @example
     * // Update one Sheet
     * const sheet = await prisma.sheet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SheetUpdateArgs>(args: SelectSubset<T, SheetUpdateArgs<ExtArgs>>): Prisma__SheetClient<$Result.GetResult<Prisma.$SheetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sheets.
     * @param {SheetDeleteManyArgs} args - Arguments to filter Sheets to delete.
     * @example
     * // Delete a few Sheets
     * const { count } = await prisma.sheet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SheetDeleteManyArgs>(args?: SelectSubset<T, SheetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sheets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SheetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sheets
     * const sheet = await prisma.sheet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SheetUpdateManyArgs>(args: SelectSubset<T, SheetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sheets and returns the data updated in the database.
     * @param {SheetUpdateManyAndReturnArgs} args - Arguments to update many Sheets.
     * @example
     * // Update many Sheets
     * const sheet = await prisma.sheet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sheets and only return the `id`
     * const sheetWithIdOnly = await prisma.sheet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SheetUpdateManyAndReturnArgs>(args: SelectSubset<T, SheetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SheetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sheet.
     * @param {SheetUpsertArgs} args - Arguments to update or create a Sheet.
     * @example
     * // Update or create a Sheet
     * const sheet = await prisma.sheet.upsert({
     *   create: {
     *     // ... data to create a Sheet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sheet we want to update
     *   }
     * })
     */
    upsert<T extends SheetUpsertArgs>(args: SelectSubset<T, SheetUpsertArgs<ExtArgs>>): Prisma__SheetClient<$Result.GetResult<Prisma.$SheetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sheets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SheetCountArgs} args - Arguments to filter Sheets to count.
     * @example
     * // Count the number of Sheets
     * const count = await prisma.sheet.count({
     *   where: {
     *     // ... the filter for the Sheets we want to count
     *   }
     * })
    **/
    count<T extends SheetCountArgs>(
      args?: Subset<T, SheetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SheetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sheet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SheetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SheetAggregateArgs>(args: Subset<T, SheetAggregateArgs>): Prisma.PrismaPromise<GetSheetAggregateType<T>>

    /**
     * Group by Sheet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SheetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SheetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SheetGroupByArgs['orderBy'] }
        : { orderBy?: SheetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SheetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSheetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sheet model
   */
  readonly fields: SheetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sheet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SheetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    submitted<T extends Sheet$submittedArgs<ExtArgs> = {}>(args?: Subset<T, Sheet$submittedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmittedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sheet model
   */
  interface SheetFieldRefs {
    readonly id: FieldRef<"Sheet", 'String'>
    readonly name: FieldRef<"Sheet", 'String'>
    readonly createdAt: FieldRef<"Sheet", 'DateTime'>
    readonly updatedAt: FieldRef<"Sheet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sheet findUnique
   */
  export type SheetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sheet
     */
    select?: SheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sheet
     */
    omit?: SheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SheetInclude<ExtArgs> | null
    /**
     * Filter, which Sheet to fetch.
     */
    where: SheetWhereUniqueInput
  }

  /**
   * Sheet findUniqueOrThrow
   */
  export type SheetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sheet
     */
    select?: SheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sheet
     */
    omit?: SheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SheetInclude<ExtArgs> | null
    /**
     * Filter, which Sheet to fetch.
     */
    where: SheetWhereUniqueInput
  }

  /**
   * Sheet findFirst
   */
  export type SheetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sheet
     */
    select?: SheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sheet
     */
    omit?: SheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SheetInclude<ExtArgs> | null
    /**
     * Filter, which Sheet to fetch.
     */
    where?: SheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sheets to fetch.
     */
    orderBy?: SheetOrderByWithRelationInput | SheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sheets.
     */
    cursor?: SheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sheets.
     */
    distinct?: SheetScalarFieldEnum | SheetScalarFieldEnum[]
  }

  /**
   * Sheet findFirstOrThrow
   */
  export type SheetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sheet
     */
    select?: SheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sheet
     */
    omit?: SheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SheetInclude<ExtArgs> | null
    /**
     * Filter, which Sheet to fetch.
     */
    where?: SheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sheets to fetch.
     */
    orderBy?: SheetOrderByWithRelationInput | SheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sheets.
     */
    cursor?: SheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sheets.
     */
    distinct?: SheetScalarFieldEnum | SheetScalarFieldEnum[]
  }

  /**
   * Sheet findMany
   */
  export type SheetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sheet
     */
    select?: SheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sheet
     */
    omit?: SheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SheetInclude<ExtArgs> | null
    /**
     * Filter, which Sheets to fetch.
     */
    where?: SheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sheets to fetch.
     */
    orderBy?: SheetOrderByWithRelationInput | SheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sheets.
     */
    cursor?: SheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sheets.
     */
    skip?: number
    distinct?: SheetScalarFieldEnum | SheetScalarFieldEnum[]
  }

  /**
   * Sheet create
   */
  export type SheetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sheet
     */
    select?: SheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sheet
     */
    omit?: SheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SheetInclude<ExtArgs> | null
    /**
     * The data needed to create a Sheet.
     */
    data: XOR<SheetCreateInput, SheetUncheckedCreateInput>
  }

  /**
   * Sheet createMany
   */
  export type SheetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sheets.
     */
    data: SheetCreateManyInput | SheetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sheet createManyAndReturn
   */
  export type SheetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sheet
     */
    select?: SheetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sheet
     */
    omit?: SheetOmit<ExtArgs> | null
    /**
     * The data used to create many Sheets.
     */
    data: SheetCreateManyInput | SheetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sheet update
   */
  export type SheetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sheet
     */
    select?: SheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sheet
     */
    omit?: SheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SheetInclude<ExtArgs> | null
    /**
     * The data needed to update a Sheet.
     */
    data: XOR<SheetUpdateInput, SheetUncheckedUpdateInput>
    /**
     * Choose, which Sheet to update.
     */
    where: SheetWhereUniqueInput
  }

  /**
   * Sheet updateMany
   */
  export type SheetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sheets.
     */
    data: XOR<SheetUpdateManyMutationInput, SheetUncheckedUpdateManyInput>
    /**
     * Filter which Sheets to update
     */
    where?: SheetWhereInput
    /**
     * Limit how many Sheets to update.
     */
    limit?: number
  }

  /**
   * Sheet updateManyAndReturn
   */
  export type SheetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sheet
     */
    select?: SheetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sheet
     */
    omit?: SheetOmit<ExtArgs> | null
    /**
     * The data used to update Sheets.
     */
    data: XOR<SheetUpdateManyMutationInput, SheetUncheckedUpdateManyInput>
    /**
     * Filter which Sheets to update
     */
    where?: SheetWhereInput
    /**
     * Limit how many Sheets to update.
     */
    limit?: number
  }

  /**
   * Sheet upsert
   */
  export type SheetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sheet
     */
    select?: SheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sheet
     */
    omit?: SheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SheetInclude<ExtArgs> | null
    /**
     * The filter to search for the Sheet to update in case it exists.
     */
    where: SheetWhereUniqueInput
    /**
     * In case the Sheet found by the `where` argument doesn't exist, create a new Sheet with this data.
     */
    create: XOR<SheetCreateInput, SheetUncheckedCreateInput>
    /**
     * In case the Sheet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SheetUpdateInput, SheetUncheckedUpdateInput>
  }

  /**
   * Sheet delete
   */
  export type SheetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sheet
     */
    select?: SheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sheet
     */
    omit?: SheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SheetInclude<ExtArgs> | null
    /**
     * Filter which Sheet to delete.
     */
    where: SheetWhereUniqueInput
  }

  /**
   * Sheet deleteMany
   */
  export type SheetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sheets to delete
     */
    where?: SheetWhereInput
    /**
     * Limit how many Sheets to delete.
     */
    limit?: number
  }

  /**
   * Sheet.submitted
   */
  export type Sheet$submittedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submitted
     */
    select?: SubmittedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submitted
     */
    omit?: SubmittedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmittedInclude<ExtArgs> | null
    where?: SubmittedWhereInput
    orderBy?: SubmittedOrderByWithRelationInput | SubmittedOrderByWithRelationInput[]
    cursor?: SubmittedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubmittedScalarFieldEnum | SubmittedScalarFieldEnum[]
  }

  /**
   * Sheet without action
   */
  export type SheetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sheet
     */
    select?: SheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sheet
     */
    omit?: SheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SheetInclude<ExtArgs> | null
  }


  /**
   * Model SubmissionReturn
   */

  export type AggregateSubmissionReturn = {
    _count: SubmissionReturnCountAggregateOutputType | null
    _min: SubmissionReturnMinAggregateOutputType | null
    _max: SubmissionReturnMaxAggregateOutputType | null
  }

  export type SubmissionReturnMinAggregateOutputType = {
    id: string | null
    submittedId: string | null
    returnedAt: Date | null
  }

  export type SubmissionReturnMaxAggregateOutputType = {
    id: string | null
    submittedId: string | null
    returnedAt: Date | null
  }

  export type SubmissionReturnCountAggregateOutputType = {
    id: number
    submittedId: number
    returnedAt: number
    _all: number
  }


  export type SubmissionReturnMinAggregateInputType = {
    id?: true
    submittedId?: true
    returnedAt?: true
  }

  export type SubmissionReturnMaxAggregateInputType = {
    id?: true
    submittedId?: true
    returnedAt?: true
  }

  export type SubmissionReturnCountAggregateInputType = {
    id?: true
    submittedId?: true
    returnedAt?: true
    _all?: true
  }

  export type SubmissionReturnAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubmissionReturn to aggregate.
     */
    where?: SubmissionReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubmissionReturns to fetch.
     */
    orderBy?: SubmissionReturnOrderByWithRelationInput | SubmissionReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubmissionReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubmissionReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubmissionReturns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubmissionReturns
    **/
    _count?: true | SubmissionReturnCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubmissionReturnMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubmissionReturnMaxAggregateInputType
  }

  export type GetSubmissionReturnAggregateType<T extends SubmissionReturnAggregateArgs> = {
        [P in keyof T & keyof AggregateSubmissionReturn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubmissionReturn[P]>
      : GetScalarType<T[P], AggregateSubmissionReturn[P]>
  }




  export type SubmissionReturnGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmissionReturnWhereInput
    orderBy?: SubmissionReturnOrderByWithAggregationInput | SubmissionReturnOrderByWithAggregationInput[]
    by: SubmissionReturnScalarFieldEnum[] | SubmissionReturnScalarFieldEnum
    having?: SubmissionReturnScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubmissionReturnCountAggregateInputType | true
    _min?: SubmissionReturnMinAggregateInputType
    _max?: SubmissionReturnMaxAggregateInputType
  }

  export type SubmissionReturnGroupByOutputType = {
    id: string
    submittedId: string
    returnedAt: Date
    _count: SubmissionReturnCountAggregateOutputType | null
    _min: SubmissionReturnMinAggregateOutputType | null
    _max: SubmissionReturnMaxAggregateOutputType | null
  }

  type GetSubmissionReturnGroupByPayload<T extends SubmissionReturnGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubmissionReturnGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubmissionReturnGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubmissionReturnGroupByOutputType[P]>
            : GetScalarType<T[P], SubmissionReturnGroupByOutputType[P]>
        }
      >
    >


  export type SubmissionReturnSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    submittedId?: boolean
    returnedAt?: boolean
    submitted?: boolean | SubmittedDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["submissionReturn"]>

  export type SubmissionReturnSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    submittedId?: boolean
    returnedAt?: boolean
    submitted?: boolean | SubmittedDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["submissionReturn"]>

  export type SubmissionReturnSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    submittedId?: boolean
    returnedAt?: boolean
    submitted?: boolean | SubmittedDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["submissionReturn"]>

  export type SubmissionReturnSelectScalar = {
    id?: boolean
    submittedId?: boolean
    returnedAt?: boolean
  }

  export type SubmissionReturnOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "submittedId" | "returnedAt", ExtArgs["result"]["submissionReturn"]>
  export type SubmissionReturnInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submitted?: boolean | SubmittedDefaultArgs<ExtArgs>
  }
  export type SubmissionReturnIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submitted?: boolean | SubmittedDefaultArgs<ExtArgs>
  }
  export type SubmissionReturnIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submitted?: boolean | SubmittedDefaultArgs<ExtArgs>
  }

  export type $SubmissionReturnPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubmissionReturn"
    objects: {
      submitted: Prisma.$SubmittedPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      submittedId: string
      returnedAt: Date
    }, ExtArgs["result"]["submissionReturn"]>
    composites: {}
  }

  type SubmissionReturnGetPayload<S extends boolean | null | undefined | SubmissionReturnDefaultArgs> = $Result.GetResult<Prisma.$SubmissionReturnPayload, S>

  type SubmissionReturnCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubmissionReturnFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubmissionReturnCountAggregateInputType | true
    }

  export interface SubmissionReturnDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubmissionReturn'], meta: { name: 'SubmissionReturn' } }
    /**
     * Find zero or one SubmissionReturn that matches the filter.
     * @param {SubmissionReturnFindUniqueArgs} args - Arguments to find a SubmissionReturn
     * @example
     * // Get one SubmissionReturn
     * const submissionReturn = await prisma.submissionReturn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubmissionReturnFindUniqueArgs>(args: SelectSubset<T, SubmissionReturnFindUniqueArgs<ExtArgs>>): Prisma__SubmissionReturnClient<$Result.GetResult<Prisma.$SubmissionReturnPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubmissionReturn that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubmissionReturnFindUniqueOrThrowArgs} args - Arguments to find a SubmissionReturn
     * @example
     * // Get one SubmissionReturn
     * const submissionReturn = await prisma.submissionReturn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubmissionReturnFindUniqueOrThrowArgs>(args: SelectSubset<T, SubmissionReturnFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubmissionReturnClient<$Result.GetResult<Prisma.$SubmissionReturnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubmissionReturn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionReturnFindFirstArgs} args - Arguments to find a SubmissionReturn
     * @example
     * // Get one SubmissionReturn
     * const submissionReturn = await prisma.submissionReturn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubmissionReturnFindFirstArgs>(args?: SelectSubset<T, SubmissionReturnFindFirstArgs<ExtArgs>>): Prisma__SubmissionReturnClient<$Result.GetResult<Prisma.$SubmissionReturnPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubmissionReturn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionReturnFindFirstOrThrowArgs} args - Arguments to find a SubmissionReturn
     * @example
     * // Get one SubmissionReturn
     * const submissionReturn = await prisma.submissionReturn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubmissionReturnFindFirstOrThrowArgs>(args?: SelectSubset<T, SubmissionReturnFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubmissionReturnClient<$Result.GetResult<Prisma.$SubmissionReturnPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubmissionReturns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionReturnFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubmissionReturns
     * const submissionReturns = await prisma.submissionReturn.findMany()
     * 
     * // Get first 10 SubmissionReturns
     * const submissionReturns = await prisma.submissionReturn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const submissionReturnWithIdOnly = await prisma.submissionReturn.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubmissionReturnFindManyArgs>(args?: SelectSubset<T, SubmissionReturnFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionReturnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubmissionReturn.
     * @param {SubmissionReturnCreateArgs} args - Arguments to create a SubmissionReturn.
     * @example
     * // Create one SubmissionReturn
     * const SubmissionReturn = await prisma.submissionReturn.create({
     *   data: {
     *     // ... data to create a SubmissionReturn
     *   }
     * })
     * 
     */
    create<T extends SubmissionReturnCreateArgs>(args: SelectSubset<T, SubmissionReturnCreateArgs<ExtArgs>>): Prisma__SubmissionReturnClient<$Result.GetResult<Prisma.$SubmissionReturnPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubmissionReturns.
     * @param {SubmissionReturnCreateManyArgs} args - Arguments to create many SubmissionReturns.
     * @example
     * // Create many SubmissionReturns
     * const submissionReturn = await prisma.submissionReturn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubmissionReturnCreateManyArgs>(args?: SelectSubset<T, SubmissionReturnCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubmissionReturns and returns the data saved in the database.
     * @param {SubmissionReturnCreateManyAndReturnArgs} args - Arguments to create many SubmissionReturns.
     * @example
     * // Create many SubmissionReturns
     * const submissionReturn = await prisma.submissionReturn.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubmissionReturns and only return the `id`
     * const submissionReturnWithIdOnly = await prisma.submissionReturn.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubmissionReturnCreateManyAndReturnArgs>(args?: SelectSubset<T, SubmissionReturnCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionReturnPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubmissionReturn.
     * @param {SubmissionReturnDeleteArgs} args - Arguments to delete one SubmissionReturn.
     * @example
     * // Delete one SubmissionReturn
     * const SubmissionReturn = await prisma.submissionReturn.delete({
     *   where: {
     *     // ... filter to delete one SubmissionReturn
     *   }
     * })
     * 
     */
    delete<T extends SubmissionReturnDeleteArgs>(args: SelectSubset<T, SubmissionReturnDeleteArgs<ExtArgs>>): Prisma__SubmissionReturnClient<$Result.GetResult<Prisma.$SubmissionReturnPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubmissionReturn.
     * @param {SubmissionReturnUpdateArgs} args - Arguments to update one SubmissionReturn.
     * @example
     * // Update one SubmissionReturn
     * const submissionReturn = await prisma.submissionReturn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubmissionReturnUpdateArgs>(args: SelectSubset<T, SubmissionReturnUpdateArgs<ExtArgs>>): Prisma__SubmissionReturnClient<$Result.GetResult<Prisma.$SubmissionReturnPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubmissionReturns.
     * @param {SubmissionReturnDeleteManyArgs} args - Arguments to filter SubmissionReturns to delete.
     * @example
     * // Delete a few SubmissionReturns
     * const { count } = await prisma.submissionReturn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubmissionReturnDeleteManyArgs>(args?: SelectSubset<T, SubmissionReturnDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubmissionReturns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionReturnUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubmissionReturns
     * const submissionReturn = await prisma.submissionReturn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubmissionReturnUpdateManyArgs>(args: SelectSubset<T, SubmissionReturnUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubmissionReturns and returns the data updated in the database.
     * @param {SubmissionReturnUpdateManyAndReturnArgs} args - Arguments to update many SubmissionReturns.
     * @example
     * // Update many SubmissionReturns
     * const submissionReturn = await prisma.submissionReturn.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubmissionReturns and only return the `id`
     * const submissionReturnWithIdOnly = await prisma.submissionReturn.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubmissionReturnUpdateManyAndReturnArgs>(args: SelectSubset<T, SubmissionReturnUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionReturnPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubmissionReturn.
     * @param {SubmissionReturnUpsertArgs} args - Arguments to update or create a SubmissionReturn.
     * @example
     * // Update or create a SubmissionReturn
     * const submissionReturn = await prisma.submissionReturn.upsert({
     *   create: {
     *     // ... data to create a SubmissionReturn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubmissionReturn we want to update
     *   }
     * })
     */
    upsert<T extends SubmissionReturnUpsertArgs>(args: SelectSubset<T, SubmissionReturnUpsertArgs<ExtArgs>>): Prisma__SubmissionReturnClient<$Result.GetResult<Prisma.$SubmissionReturnPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubmissionReturns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionReturnCountArgs} args - Arguments to filter SubmissionReturns to count.
     * @example
     * // Count the number of SubmissionReturns
     * const count = await prisma.submissionReturn.count({
     *   where: {
     *     // ... the filter for the SubmissionReturns we want to count
     *   }
     * })
    **/
    count<T extends SubmissionReturnCountArgs>(
      args?: Subset<T, SubmissionReturnCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubmissionReturnCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubmissionReturn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionReturnAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubmissionReturnAggregateArgs>(args: Subset<T, SubmissionReturnAggregateArgs>): Prisma.PrismaPromise<GetSubmissionReturnAggregateType<T>>

    /**
     * Group by SubmissionReturn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionReturnGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubmissionReturnGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubmissionReturnGroupByArgs['orderBy'] }
        : { orderBy?: SubmissionReturnGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubmissionReturnGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubmissionReturnGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubmissionReturn model
   */
  readonly fields: SubmissionReturnFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubmissionReturn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubmissionReturnClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    submitted<T extends SubmittedDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubmittedDefaultArgs<ExtArgs>>): Prisma__SubmittedClient<$Result.GetResult<Prisma.$SubmittedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubmissionReturn model
   */
  interface SubmissionReturnFieldRefs {
    readonly id: FieldRef<"SubmissionReturn", 'String'>
    readonly submittedId: FieldRef<"SubmissionReturn", 'String'>
    readonly returnedAt: FieldRef<"SubmissionReturn", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubmissionReturn findUnique
   */
  export type SubmissionReturnFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionReturn
     */
    select?: SubmissionReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionReturn
     */
    omit?: SubmissionReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionReturnInclude<ExtArgs> | null
    /**
     * Filter, which SubmissionReturn to fetch.
     */
    where: SubmissionReturnWhereUniqueInput
  }

  /**
   * SubmissionReturn findUniqueOrThrow
   */
  export type SubmissionReturnFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionReturn
     */
    select?: SubmissionReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionReturn
     */
    omit?: SubmissionReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionReturnInclude<ExtArgs> | null
    /**
     * Filter, which SubmissionReturn to fetch.
     */
    where: SubmissionReturnWhereUniqueInput
  }

  /**
   * SubmissionReturn findFirst
   */
  export type SubmissionReturnFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionReturn
     */
    select?: SubmissionReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionReturn
     */
    omit?: SubmissionReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionReturnInclude<ExtArgs> | null
    /**
     * Filter, which SubmissionReturn to fetch.
     */
    where?: SubmissionReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubmissionReturns to fetch.
     */
    orderBy?: SubmissionReturnOrderByWithRelationInput | SubmissionReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubmissionReturns.
     */
    cursor?: SubmissionReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubmissionReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubmissionReturns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubmissionReturns.
     */
    distinct?: SubmissionReturnScalarFieldEnum | SubmissionReturnScalarFieldEnum[]
  }

  /**
   * SubmissionReturn findFirstOrThrow
   */
  export type SubmissionReturnFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionReturn
     */
    select?: SubmissionReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionReturn
     */
    omit?: SubmissionReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionReturnInclude<ExtArgs> | null
    /**
     * Filter, which SubmissionReturn to fetch.
     */
    where?: SubmissionReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubmissionReturns to fetch.
     */
    orderBy?: SubmissionReturnOrderByWithRelationInput | SubmissionReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubmissionReturns.
     */
    cursor?: SubmissionReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubmissionReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubmissionReturns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubmissionReturns.
     */
    distinct?: SubmissionReturnScalarFieldEnum | SubmissionReturnScalarFieldEnum[]
  }

  /**
   * SubmissionReturn findMany
   */
  export type SubmissionReturnFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionReturn
     */
    select?: SubmissionReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionReturn
     */
    omit?: SubmissionReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionReturnInclude<ExtArgs> | null
    /**
     * Filter, which SubmissionReturns to fetch.
     */
    where?: SubmissionReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubmissionReturns to fetch.
     */
    orderBy?: SubmissionReturnOrderByWithRelationInput | SubmissionReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubmissionReturns.
     */
    cursor?: SubmissionReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubmissionReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubmissionReturns.
     */
    skip?: number
    distinct?: SubmissionReturnScalarFieldEnum | SubmissionReturnScalarFieldEnum[]
  }

  /**
   * SubmissionReturn create
   */
  export type SubmissionReturnCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionReturn
     */
    select?: SubmissionReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionReturn
     */
    omit?: SubmissionReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionReturnInclude<ExtArgs> | null
    /**
     * The data needed to create a SubmissionReturn.
     */
    data: XOR<SubmissionReturnCreateInput, SubmissionReturnUncheckedCreateInput>
  }

  /**
   * SubmissionReturn createMany
   */
  export type SubmissionReturnCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubmissionReturns.
     */
    data: SubmissionReturnCreateManyInput | SubmissionReturnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubmissionReturn createManyAndReturn
   */
  export type SubmissionReturnCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionReturn
     */
    select?: SubmissionReturnSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionReturn
     */
    omit?: SubmissionReturnOmit<ExtArgs> | null
    /**
     * The data used to create many SubmissionReturns.
     */
    data: SubmissionReturnCreateManyInput | SubmissionReturnCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionReturnIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubmissionReturn update
   */
  export type SubmissionReturnUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionReturn
     */
    select?: SubmissionReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionReturn
     */
    omit?: SubmissionReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionReturnInclude<ExtArgs> | null
    /**
     * The data needed to update a SubmissionReturn.
     */
    data: XOR<SubmissionReturnUpdateInput, SubmissionReturnUncheckedUpdateInput>
    /**
     * Choose, which SubmissionReturn to update.
     */
    where: SubmissionReturnWhereUniqueInput
  }

  /**
   * SubmissionReturn updateMany
   */
  export type SubmissionReturnUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubmissionReturns.
     */
    data: XOR<SubmissionReturnUpdateManyMutationInput, SubmissionReturnUncheckedUpdateManyInput>
    /**
     * Filter which SubmissionReturns to update
     */
    where?: SubmissionReturnWhereInput
    /**
     * Limit how many SubmissionReturns to update.
     */
    limit?: number
  }

  /**
   * SubmissionReturn updateManyAndReturn
   */
  export type SubmissionReturnUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionReturn
     */
    select?: SubmissionReturnSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionReturn
     */
    omit?: SubmissionReturnOmit<ExtArgs> | null
    /**
     * The data used to update SubmissionReturns.
     */
    data: XOR<SubmissionReturnUpdateManyMutationInput, SubmissionReturnUncheckedUpdateManyInput>
    /**
     * Filter which SubmissionReturns to update
     */
    where?: SubmissionReturnWhereInput
    /**
     * Limit how many SubmissionReturns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionReturnIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubmissionReturn upsert
   */
  export type SubmissionReturnUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionReturn
     */
    select?: SubmissionReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionReturn
     */
    omit?: SubmissionReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionReturnInclude<ExtArgs> | null
    /**
     * The filter to search for the SubmissionReturn to update in case it exists.
     */
    where: SubmissionReturnWhereUniqueInput
    /**
     * In case the SubmissionReturn found by the `where` argument doesn't exist, create a new SubmissionReturn with this data.
     */
    create: XOR<SubmissionReturnCreateInput, SubmissionReturnUncheckedCreateInput>
    /**
     * In case the SubmissionReturn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubmissionReturnUpdateInput, SubmissionReturnUncheckedUpdateInput>
  }

  /**
   * SubmissionReturn delete
   */
  export type SubmissionReturnDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionReturn
     */
    select?: SubmissionReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionReturn
     */
    omit?: SubmissionReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionReturnInclude<ExtArgs> | null
    /**
     * Filter which SubmissionReturn to delete.
     */
    where: SubmissionReturnWhereUniqueInput
  }

  /**
   * SubmissionReturn deleteMany
   */
  export type SubmissionReturnDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubmissionReturns to delete
     */
    where?: SubmissionReturnWhereInput
    /**
     * Limit how many SubmissionReturns to delete.
     */
    limit?: number
  }

  /**
   * SubmissionReturn without action
   */
  export type SubmissionReturnDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionReturn
     */
    select?: SubmissionReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionReturn
     */
    omit?: SubmissionReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionReturnInclude<ExtArgs> | null
  }


  /**
   * Model Submitted
   */

  export type AggregateSubmitted = {
    _count: SubmittedCountAggregateOutputType | null
    _min: SubmittedMinAggregateOutputType | null
    _max: SubmittedMaxAggregateOutputType | null
  }

  export type SubmittedMinAggregateOutputType = {
    id: string | null
    information: string | null
    submission: string | null
    status: $Enums.SubmittedStatus | null
    employeeId: string | null
    projectId: string | null
    sheetId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubmittedMaxAggregateOutputType = {
    id: string | null
    information: string | null
    submission: string | null
    status: $Enums.SubmittedStatus | null
    employeeId: string | null
    projectId: string | null
    sheetId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubmittedCountAggregateOutputType = {
    id: number
    information: number
    submission: number
    status: number
    employeeId: number
    projectId: number
    sheetId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubmittedMinAggregateInputType = {
    id?: true
    information?: true
    submission?: true
    status?: true
    employeeId?: true
    projectId?: true
    sheetId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubmittedMaxAggregateInputType = {
    id?: true
    information?: true
    submission?: true
    status?: true
    employeeId?: true
    projectId?: true
    sheetId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubmittedCountAggregateInputType = {
    id?: true
    information?: true
    submission?: true
    status?: true
    employeeId?: true
    projectId?: true
    sheetId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubmittedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Submitted to aggregate.
     */
    where?: SubmittedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submitteds to fetch.
     */
    orderBy?: SubmittedOrderByWithRelationInput | SubmittedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubmittedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submitteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submitteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Submitteds
    **/
    _count?: true | SubmittedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubmittedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubmittedMaxAggregateInputType
  }

  export type GetSubmittedAggregateType<T extends SubmittedAggregateArgs> = {
        [P in keyof T & keyof AggregateSubmitted]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubmitted[P]>
      : GetScalarType<T[P], AggregateSubmitted[P]>
  }




  export type SubmittedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmittedWhereInput
    orderBy?: SubmittedOrderByWithAggregationInput | SubmittedOrderByWithAggregationInput[]
    by: SubmittedScalarFieldEnum[] | SubmittedScalarFieldEnum
    having?: SubmittedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubmittedCountAggregateInputType | true
    _min?: SubmittedMinAggregateInputType
    _max?: SubmittedMaxAggregateInputType
  }

  export type SubmittedGroupByOutputType = {
    id: string
    information: string
    submission: string
    status: $Enums.SubmittedStatus
    employeeId: string
    projectId: string
    sheetId: string
    createdAt: Date
    updatedAt: Date
    _count: SubmittedCountAggregateOutputType | null
    _min: SubmittedMinAggregateOutputType | null
    _max: SubmittedMaxAggregateOutputType | null
  }

  type GetSubmittedGroupByPayload<T extends SubmittedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubmittedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubmittedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubmittedGroupByOutputType[P]>
            : GetScalarType<T[P], SubmittedGroupByOutputType[P]>
        }
      >
    >


  export type SubmittedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    information?: boolean
    submission?: boolean
    status?: boolean
    employeeId?: boolean
    projectId?: boolean
    sheetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sheet?: boolean | SheetDefaultArgs<ExtArgs>
    submissionReturn?: boolean | Submitted$submissionReturnArgs<ExtArgs>
  }, ExtArgs["result"]["submitted"]>

  export type SubmittedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    information?: boolean
    submission?: boolean
    status?: boolean
    employeeId?: boolean
    projectId?: boolean
    sheetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sheet?: boolean | SheetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["submitted"]>

  export type SubmittedSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    information?: boolean
    submission?: boolean
    status?: boolean
    employeeId?: boolean
    projectId?: boolean
    sheetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sheet?: boolean | SheetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["submitted"]>

  export type SubmittedSelectScalar = {
    id?: boolean
    information?: boolean
    submission?: boolean
    status?: boolean
    employeeId?: boolean
    projectId?: boolean
    sheetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubmittedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "information" | "submission" | "status" | "employeeId" | "projectId" | "sheetId" | "createdAt" | "updatedAt", ExtArgs["result"]["submitted"]>
  export type SubmittedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sheet?: boolean | SheetDefaultArgs<ExtArgs>
    submissionReturn?: boolean | Submitted$submissionReturnArgs<ExtArgs>
  }
  export type SubmittedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sheet?: boolean | SheetDefaultArgs<ExtArgs>
  }
  export type SubmittedIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sheet?: boolean | SheetDefaultArgs<ExtArgs>
  }

  export type $SubmittedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Submitted"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
      sheet: Prisma.$SheetPayload<ExtArgs>
      submissionReturn: Prisma.$SubmissionReturnPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      information: string
      submission: string
      status: $Enums.SubmittedStatus
      employeeId: string
      projectId: string
      sheetId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["submitted"]>
    composites: {}
  }

  type SubmittedGetPayload<S extends boolean | null | undefined | SubmittedDefaultArgs> = $Result.GetResult<Prisma.$SubmittedPayload, S>

  type SubmittedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubmittedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubmittedCountAggregateInputType | true
    }

  export interface SubmittedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Submitted'], meta: { name: 'Submitted' } }
    /**
     * Find zero or one Submitted that matches the filter.
     * @param {SubmittedFindUniqueArgs} args - Arguments to find a Submitted
     * @example
     * // Get one Submitted
     * const submitted = await prisma.submitted.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubmittedFindUniqueArgs>(args: SelectSubset<T, SubmittedFindUniqueArgs<ExtArgs>>): Prisma__SubmittedClient<$Result.GetResult<Prisma.$SubmittedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Submitted that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubmittedFindUniqueOrThrowArgs} args - Arguments to find a Submitted
     * @example
     * // Get one Submitted
     * const submitted = await prisma.submitted.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubmittedFindUniqueOrThrowArgs>(args: SelectSubset<T, SubmittedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubmittedClient<$Result.GetResult<Prisma.$SubmittedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Submitted that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmittedFindFirstArgs} args - Arguments to find a Submitted
     * @example
     * // Get one Submitted
     * const submitted = await prisma.submitted.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubmittedFindFirstArgs>(args?: SelectSubset<T, SubmittedFindFirstArgs<ExtArgs>>): Prisma__SubmittedClient<$Result.GetResult<Prisma.$SubmittedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Submitted that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmittedFindFirstOrThrowArgs} args - Arguments to find a Submitted
     * @example
     * // Get one Submitted
     * const submitted = await prisma.submitted.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubmittedFindFirstOrThrowArgs>(args?: SelectSubset<T, SubmittedFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubmittedClient<$Result.GetResult<Prisma.$SubmittedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Submitteds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmittedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Submitteds
     * const submitteds = await prisma.submitted.findMany()
     * 
     * // Get first 10 Submitteds
     * const submitteds = await prisma.submitted.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const submittedWithIdOnly = await prisma.submitted.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubmittedFindManyArgs>(args?: SelectSubset<T, SubmittedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmittedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Submitted.
     * @param {SubmittedCreateArgs} args - Arguments to create a Submitted.
     * @example
     * // Create one Submitted
     * const Submitted = await prisma.submitted.create({
     *   data: {
     *     // ... data to create a Submitted
     *   }
     * })
     * 
     */
    create<T extends SubmittedCreateArgs>(args: SelectSubset<T, SubmittedCreateArgs<ExtArgs>>): Prisma__SubmittedClient<$Result.GetResult<Prisma.$SubmittedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Submitteds.
     * @param {SubmittedCreateManyArgs} args - Arguments to create many Submitteds.
     * @example
     * // Create many Submitteds
     * const submitted = await prisma.submitted.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubmittedCreateManyArgs>(args?: SelectSubset<T, SubmittedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Submitteds and returns the data saved in the database.
     * @param {SubmittedCreateManyAndReturnArgs} args - Arguments to create many Submitteds.
     * @example
     * // Create many Submitteds
     * const submitted = await prisma.submitted.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Submitteds and only return the `id`
     * const submittedWithIdOnly = await prisma.submitted.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubmittedCreateManyAndReturnArgs>(args?: SelectSubset<T, SubmittedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmittedPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Submitted.
     * @param {SubmittedDeleteArgs} args - Arguments to delete one Submitted.
     * @example
     * // Delete one Submitted
     * const Submitted = await prisma.submitted.delete({
     *   where: {
     *     // ... filter to delete one Submitted
     *   }
     * })
     * 
     */
    delete<T extends SubmittedDeleteArgs>(args: SelectSubset<T, SubmittedDeleteArgs<ExtArgs>>): Prisma__SubmittedClient<$Result.GetResult<Prisma.$SubmittedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Submitted.
     * @param {SubmittedUpdateArgs} args - Arguments to update one Submitted.
     * @example
     * // Update one Submitted
     * const submitted = await prisma.submitted.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubmittedUpdateArgs>(args: SelectSubset<T, SubmittedUpdateArgs<ExtArgs>>): Prisma__SubmittedClient<$Result.GetResult<Prisma.$SubmittedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Submitteds.
     * @param {SubmittedDeleteManyArgs} args - Arguments to filter Submitteds to delete.
     * @example
     * // Delete a few Submitteds
     * const { count } = await prisma.submitted.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubmittedDeleteManyArgs>(args?: SelectSubset<T, SubmittedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Submitteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmittedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Submitteds
     * const submitted = await prisma.submitted.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubmittedUpdateManyArgs>(args: SelectSubset<T, SubmittedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Submitteds and returns the data updated in the database.
     * @param {SubmittedUpdateManyAndReturnArgs} args - Arguments to update many Submitteds.
     * @example
     * // Update many Submitteds
     * const submitted = await prisma.submitted.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Submitteds and only return the `id`
     * const submittedWithIdOnly = await prisma.submitted.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubmittedUpdateManyAndReturnArgs>(args: SelectSubset<T, SubmittedUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmittedPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Submitted.
     * @param {SubmittedUpsertArgs} args - Arguments to update or create a Submitted.
     * @example
     * // Update or create a Submitted
     * const submitted = await prisma.submitted.upsert({
     *   create: {
     *     // ... data to create a Submitted
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Submitted we want to update
     *   }
     * })
     */
    upsert<T extends SubmittedUpsertArgs>(args: SelectSubset<T, SubmittedUpsertArgs<ExtArgs>>): Prisma__SubmittedClient<$Result.GetResult<Prisma.$SubmittedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Submitteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmittedCountArgs} args - Arguments to filter Submitteds to count.
     * @example
     * // Count the number of Submitteds
     * const count = await prisma.submitted.count({
     *   where: {
     *     // ... the filter for the Submitteds we want to count
     *   }
     * })
    **/
    count<T extends SubmittedCountArgs>(
      args?: Subset<T, SubmittedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubmittedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Submitted.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmittedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubmittedAggregateArgs>(args: Subset<T, SubmittedAggregateArgs>): Prisma.PrismaPromise<GetSubmittedAggregateType<T>>

    /**
     * Group by Submitted.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmittedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubmittedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubmittedGroupByArgs['orderBy'] }
        : { orderBy?: SubmittedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubmittedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubmittedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Submitted model
   */
  readonly fields: SubmittedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Submitted.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubmittedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sheet<T extends SheetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SheetDefaultArgs<ExtArgs>>): Prisma__SheetClient<$Result.GetResult<Prisma.$SheetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    submissionReturn<T extends Submitted$submissionReturnArgs<ExtArgs> = {}>(args?: Subset<T, Submitted$submissionReturnArgs<ExtArgs>>): Prisma__SubmissionReturnClient<$Result.GetResult<Prisma.$SubmissionReturnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Submitted model
   */
  interface SubmittedFieldRefs {
    readonly id: FieldRef<"Submitted", 'String'>
    readonly information: FieldRef<"Submitted", 'String'>
    readonly submission: FieldRef<"Submitted", 'String'>
    readonly status: FieldRef<"Submitted", 'SubmittedStatus'>
    readonly employeeId: FieldRef<"Submitted", 'String'>
    readonly projectId: FieldRef<"Submitted", 'String'>
    readonly sheetId: FieldRef<"Submitted", 'String'>
    readonly createdAt: FieldRef<"Submitted", 'DateTime'>
    readonly updatedAt: FieldRef<"Submitted", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Submitted findUnique
   */
  export type SubmittedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submitted
     */
    select?: SubmittedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submitted
     */
    omit?: SubmittedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmittedInclude<ExtArgs> | null
    /**
     * Filter, which Submitted to fetch.
     */
    where: SubmittedWhereUniqueInput
  }

  /**
   * Submitted findUniqueOrThrow
   */
  export type SubmittedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submitted
     */
    select?: SubmittedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submitted
     */
    omit?: SubmittedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmittedInclude<ExtArgs> | null
    /**
     * Filter, which Submitted to fetch.
     */
    where: SubmittedWhereUniqueInput
  }

  /**
   * Submitted findFirst
   */
  export type SubmittedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submitted
     */
    select?: SubmittedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submitted
     */
    omit?: SubmittedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmittedInclude<ExtArgs> | null
    /**
     * Filter, which Submitted to fetch.
     */
    where?: SubmittedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submitteds to fetch.
     */
    orderBy?: SubmittedOrderByWithRelationInput | SubmittedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Submitteds.
     */
    cursor?: SubmittedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submitteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submitteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Submitteds.
     */
    distinct?: SubmittedScalarFieldEnum | SubmittedScalarFieldEnum[]
  }

  /**
   * Submitted findFirstOrThrow
   */
  export type SubmittedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submitted
     */
    select?: SubmittedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submitted
     */
    omit?: SubmittedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmittedInclude<ExtArgs> | null
    /**
     * Filter, which Submitted to fetch.
     */
    where?: SubmittedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submitteds to fetch.
     */
    orderBy?: SubmittedOrderByWithRelationInput | SubmittedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Submitteds.
     */
    cursor?: SubmittedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submitteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submitteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Submitteds.
     */
    distinct?: SubmittedScalarFieldEnum | SubmittedScalarFieldEnum[]
  }

  /**
   * Submitted findMany
   */
  export type SubmittedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submitted
     */
    select?: SubmittedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submitted
     */
    omit?: SubmittedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmittedInclude<ExtArgs> | null
    /**
     * Filter, which Submitteds to fetch.
     */
    where?: SubmittedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submitteds to fetch.
     */
    orderBy?: SubmittedOrderByWithRelationInput | SubmittedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Submitteds.
     */
    cursor?: SubmittedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submitteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submitteds.
     */
    skip?: number
    distinct?: SubmittedScalarFieldEnum | SubmittedScalarFieldEnum[]
  }

  /**
   * Submitted create
   */
  export type SubmittedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submitted
     */
    select?: SubmittedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submitted
     */
    omit?: SubmittedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmittedInclude<ExtArgs> | null
    /**
     * The data needed to create a Submitted.
     */
    data: XOR<SubmittedCreateInput, SubmittedUncheckedCreateInput>
  }

  /**
   * Submitted createMany
   */
  export type SubmittedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Submitteds.
     */
    data: SubmittedCreateManyInput | SubmittedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Submitted createManyAndReturn
   */
  export type SubmittedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submitted
     */
    select?: SubmittedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Submitted
     */
    omit?: SubmittedOmit<ExtArgs> | null
    /**
     * The data used to create many Submitteds.
     */
    data: SubmittedCreateManyInput | SubmittedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmittedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Submitted update
   */
  export type SubmittedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submitted
     */
    select?: SubmittedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submitted
     */
    omit?: SubmittedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmittedInclude<ExtArgs> | null
    /**
     * The data needed to update a Submitted.
     */
    data: XOR<SubmittedUpdateInput, SubmittedUncheckedUpdateInput>
    /**
     * Choose, which Submitted to update.
     */
    where: SubmittedWhereUniqueInput
  }

  /**
   * Submitted updateMany
   */
  export type SubmittedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Submitteds.
     */
    data: XOR<SubmittedUpdateManyMutationInput, SubmittedUncheckedUpdateManyInput>
    /**
     * Filter which Submitteds to update
     */
    where?: SubmittedWhereInput
    /**
     * Limit how many Submitteds to update.
     */
    limit?: number
  }

  /**
   * Submitted updateManyAndReturn
   */
  export type SubmittedUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submitted
     */
    select?: SubmittedSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Submitted
     */
    omit?: SubmittedOmit<ExtArgs> | null
    /**
     * The data used to update Submitteds.
     */
    data: XOR<SubmittedUpdateManyMutationInput, SubmittedUncheckedUpdateManyInput>
    /**
     * Filter which Submitteds to update
     */
    where?: SubmittedWhereInput
    /**
     * Limit how many Submitteds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmittedIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Submitted upsert
   */
  export type SubmittedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submitted
     */
    select?: SubmittedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submitted
     */
    omit?: SubmittedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmittedInclude<ExtArgs> | null
    /**
     * The filter to search for the Submitted to update in case it exists.
     */
    where: SubmittedWhereUniqueInput
    /**
     * In case the Submitted found by the `where` argument doesn't exist, create a new Submitted with this data.
     */
    create: XOR<SubmittedCreateInput, SubmittedUncheckedCreateInput>
    /**
     * In case the Submitted was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubmittedUpdateInput, SubmittedUncheckedUpdateInput>
  }

  /**
   * Submitted delete
   */
  export type SubmittedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submitted
     */
    select?: SubmittedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submitted
     */
    omit?: SubmittedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmittedInclude<ExtArgs> | null
    /**
     * Filter which Submitted to delete.
     */
    where: SubmittedWhereUniqueInput
  }

  /**
   * Submitted deleteMany
   */
  export type SubmittedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Submitteds to delete
     */
    where?: SubmittedWhereInput
    /**
     * Limit how many Submitteds to delete.
     */
    limit?: number
  }

  /**
   * Submitted.submissionReturn
   */
  export type Submitted$submissionReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionReturn
     */
    select?: SubmissionReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionReturn
     */
    omit?: SubmissionReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionReturnInclude<ExtArgs> | null
    where?: SubmissionReturnWhereInput
  }

  /**
   * Submitted without action
   */
  export type SubmittedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submitted
     */
    select?: SubmittedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submitted
     */
    omit?: SubmittedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmittedInclude<ExtArgs> | null
  }


  /**
   * Model SuperAdmin
   */

  export type AggregateSuperAdmin = {
    _count: SuperAdminCountAggregateOutputType | null
    _min: SuperAdminMinAggregateOutputType | null
    _max: SuperAdminMaxAggregateOutputType | null
  }

  export type SuperAdminMinAggregateOutputType = {
    id: string | null
    userId: string | null
    clientLogo: string | null
    favicon: string | null
    primaryColor: string | null
    secondaryColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SuperAdminMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    clientLogo: string | null
    favicon: string | null
    primaryColor: string | null
    secondaryColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SuperAdminCountAggregateOutputType = {
    id: number
    userId: number
    clientLogo: number
    favicon: number
    primaryColor: number
    secondaryColor: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SuperAdminMinAggregateInputType = {
    id?: true
    userId?: true
    clientLogo?: true
    favicon?: true
    primaryColor?: true
    secondaryColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SuperAdminMaxAggregateInputType = {
    id?: true
    userId?: true
    clientLogo?: true
    favicon?: true
    primaryColor?: true
    secondaryColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SuperAdminCountAggregateInputType = {
    id?: true
    userId?: true
    clientLogo?: true
    favicon?: true
    primaryColor?: true
    secondaryColor?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SuperAdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuperAdmin to aggregate.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SuperAdmins
    **/
    _count?: true | SuperAdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuperAdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuperAdminMaxAggregateInputType
  }

  export type GetSuperAdminAggregateType<T extends SuperAdminAggregateArgs> = {
        [P in keyof T & keyof AggregateSuperAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuperAdmin[P]>
      : GetScalarType<T[P], AggregateSuperAdmin[P]>
  }




  export type SuperAdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuperAdminWhereInput
    orderBy?: SuperAdminOrderByWithAggregationInput | SuperAdminOrderByWithAggregationInput[]
    by: SuperAdminScalarFieldEnum[] | SuperAdminScalarFieldEnum
    having?: SuperAdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuperAdminCountAggregateInputType | true
    _min?: SuperAdminMinAggregateInputType
    _max?: SuperAdminMaxAggregateInputType
  }

  export type SuperAdminGroupByOutputType = {
    id: string
    userId: string
    clientLogo: string | null
    favicon: string | null
    primaryColor: string | null
    secondaryColor: string | null
    createdAt: Date
    updatedAt: Date
    _count: SuperAdminCountAggregateOutputType | null
    _min: SuperAdminMinAggregateOutputType | null
    _max: SuperAdminMaxAggregateOutputType | null
  }

  type GetSuperAdminGroupByPayload<T extends SuperAdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuperAdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuperAdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuperAdminGroupByOutputType[P]>
            : GetScalarType<T[P], SuperAdminGroupByOutputType[P]>
        }
      >
    >


  export type SuperAdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    clientLogo?: boolean
    favicon?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    notificationPermissionSuperAdmin?: boolean | SuperAdmin$notificationPermissionSuperAdminArgs<ExtArgs>
  }, ExtArgs["result"]["superAdmin"]>

  export type SuperAdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    clientLogo?: boolean
    favicon?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["superAdmin"]>

  export type SuperAdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    clientLogo?: boolean
    favicon?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["superAdmin"]>

  export type SuperAdminSelectScalar = {
    id?: boolean
    userId?: boolean
    clientLogo?: boolean
    favicon?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SuperAdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "clientLogo" | "favicon" | "primaryColor" | "secondaryColor" | "createdAt" | "updatedAt", ExtArgs["result"]["superAdmin"]>
  export type SuperAdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    notificationPermissionSuperAdmin?: boolean | SuperAdmin$notificationPermissionSuperAdminArgs<ExtArgs>
  }
  export type SuperAdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SuperAdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SuperAdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SuperAdmin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      notificationPermissionSuperAdmin: Prisma.$NotificationPermissionSuperAdminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      clientLogo: string | null
      favicon: string | null
      primaryColor: string | null
      secondaryColor: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["superAdmin"]>
    composites: {}
  }

  type SuperAdminGetPayload<S extends boolean | null | undefined | SuperAdminDefaultArgs> = $Result.GetResult<Prisma.$SuperAdminPayload, S>

  type SuperAdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SuperAdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SuperAdminCountAggregateInputType | true
    }

  export interface SuperAdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SuperAdmin'], meta: { name: 'SuperAdmin' } }
    /**
     * Find zero or one SuperAdmin that matches the filter.
     * @param {SuperAdminFindUniqueArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SuperAdminFindUniqueArgs>(args: SelectSubset<T, SuperAdminFindUniqueArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SuperAdmin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SuperAdminFindUniqueOrThrowArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SuperAdminFindUniqueOrThrowArgs>(args: SelectSubset<T, SuperAdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuperAdmin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminFindFirstArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SuperAdminFindFirstArgs>(args?: SelectSubset<T, SuperAdminFindFirstArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuperAdmin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminFindFirstOrThrowArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SuperAdminFindFirstOrThrowArgs>(args?: SelectSubset<T, SuperAdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SuperAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SuperAdmins
     * const superAdmins = await prisma.superAdmin.findMany()
     * 
     * // Get first 10 SuperAdmins
     * const superAdmins = await prisma.superAdmin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const superAdminWithIdOnly = await prisma.superAdmin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SuperAdminFindManyArgs>(args?: SelectSubset<T, SuperAdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SuperAdmin.
     * @param {SuperAdminCreateArgs} args - Arguments to create a SuperAdmin.
     * @example
     * // Create one SuperAdmin
     * const SuperAdmin = await prisma.superAdmin.create({
     *   data: {
     *     // ... data to create a SuperAdmin
     *   }
     * })
     * 
     */
    create<T extends SuperAdminCreateArgs>(args: SelectSubset<T, SuperAdminCreateArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SuperAdmins.
     * @param {SuperAdminCreateManyArgs} args - Arguments to create many SuperAdmins.
     * @example
     * // Create many SuperAdmins
     * const superAdmin = await prisma.superAdmin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SuperAdminCreateManyArgs>(args?: SelectSubset<T, SuperAdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SuperAdmins and returns the data saved in the database.
     * @param {SuperAdminCreateManyAndReturnArgs} args - Arguments to create many SuperAdmins.
     * @example
     * // Create many SuperAdmins
     * const superAdmin = await prisma.superAdmin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SuperAdmins and only return the `id`
     * const superAdminWithIdOnly = await prisma.superAdmin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SuperAdminCreateManyAndReturnArgs>(args?: SelectSubset<T, SuperAdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SuperAdmin.
     * @param {SuperAdminDeleteArgs} args - Arguments to delete one SuperAdmin.
     * @example
     * // Delete one SuperAdmin
     * const SuperAdmin = await prisma.superAdmin.delete({
     *   where: {
     *     // ... filter to delete one SuperAdmin
     *   }
     * })
     * 
     */
    delete<T extends SuperAdminDeleteArgs>(args: SelectSubset<T, SuperAdminDeleteArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SuperAdmin.
     * @param {SuperAdminUpdateArgs} args - Arguments to update one SuperAdmin.
     * @example
     * // Update one SuperAdmin
     * const superAdmin = await prisma.superAdmin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SuperAdminUpdateArgs>(args: SelectSubset<T, SuperAdminUpdateArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SuperAdmins.
     * @param {SuperAdminDeleteManyArgs} args - Arguments to filter SuperAdmins to delete.
     * @example
     * // Delete a few SuperAdmins
     * const { count } = await prisma.superAdmin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SuperAdminDeleteManyArgs>(args?: SelectSubset<T, SuperAdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuperAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SuperAdmins
     * const superAdmin = await prisma.superAdmin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SuperAdminUpdateManyArgs>(args: SelectSubset<T, SuperAdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuperAdmins and returns the data updated in the database.
     * @param {SuperAdminUpdateManyAndReturnArgs} args - Arguments to update many SuperAdmins.
     * @example
     * // Update many SuperAdmins
     * const superAdmin = await prisma.superAdmin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SuperAdmins and only return the `id`
     * const superAdminWithIdOnly = await prisma.superAdmin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SuperAdminUpdateManyAndReturnArgs>(args: SelectSubset<T, SuperAdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SuperAdmin.
     * @param {SuperAdminUpsertArgs} args - Arguments to update or create a SuperAdmin.
     * @example
     * // Update or create a SuperAdmin
     * const superAdmin = await prisma.superAdmin.upsert({
     *   create: {
     *     // ... data to create a SuperAdmin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SuperAdmin we want to update
     *   }
     * })
     */
    upsert<T extends SuperAdminUpsertArgs>(args: SelectSubset<T, SuperAdminUpsertArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SuperAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminCountArgs} args - Arguments to filter SuperAdmins to count.
     * @example
     * // Count the number of SuperAdmins
     * const count = await prisma.superAdmin.count({
     *   where: {
     *     // ... the filter for the SuperAdmins we want to count
     *   }
     * })
    **/
    count<T extends SuperAdminCountArgs>(
      args?: Subset<T, SuperAdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuperAdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SuperAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuperAdminAggregateArgs>(args: Subset<T, SuperAdminAggregateArgs>): Prisma.PrismaPromise<GetSuperAdminAggregateType<T>>

    /**
     * Group by SuperAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuperAdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuperAdminGroupByArgs['orderBy'] }
        : { orderBy?: SuperAdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuperAdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuperAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SuperAdmin model
   */
  readonly fields: SuperAdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SuperAdmin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SuperAdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notificationPermissionSuperAdmin<T extends SuperAdmin$notificationPermissionSuperAdminArgs<ExtArgs> = {}>(args?: Subset<T, SuperAdmin$notificationPermissionSuperAdminArgs<ExtArgs>>): Prisma__NotificationPermissionSuperAdminClient<$Result.GetResult<Prisma.$NotificationPermissionSuperAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SuperAdmin model
   */
  interface SuperAdminFieldRefs {
    readonly id: FieldRef<"SuperAdmin", 'String'>
    readonly userId: FieldRef<"SuperAdmin", 'String'>
    readonly clientLogo: FieldRef<"SuperAdmin", 'String'>
    readonly favicon: FieldRef<"SuperAdmin", 'String'>
    readonly primaryColor: FieldRef<"SuperAdmin", 'String'>
    readonly secondaryColor: FieldRef<"SuperAdmin", 'String'>
    readonly createdAt: FieldRef<"SuperAdmin", 'DateTime'>
    readonly updatedAt: FieldRef<"SuperAdmin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SuperAdmin findUnique
   */
  export type SuperAdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin findUniqueOrThrow
   */
  export type SuperAdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin findFirst
   */
  export type SuperAdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuperAdmins.
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuperAdmins.
     */
    distinct?: SuperAdminScalarFieldEnum | SuperAdminScalarFieldEnum[]
  }

  /**
   * SuperAdmin findFirstOrThrow
   */
  export type SuperAdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuperAdmins.
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuperAdmins.
     */
    distinct?: SuperAdminScalarFieldEnum | SuperAdminScalarFieldEnum[]
  }

  /**
   * SuperAdmin findMany
   */
  export type SuperAdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmins to fetch.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SuperAdmins.
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    distinct?: SuperAdminScalarFieldEnum | SuperAdminScalarFieldEnum[]
  }

  /**
   * SuperAdmin create
   */
  export type SuperAdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * The data needed to create a SuperAdmin.
     */
    data: XOR<SuperAdminCreateInput, SuperAdminUncheckedCreateInput>
  }

  /**
   * SuperAdmin createMany
   */
  export type SuperAdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SuperAdmins.
     */
    data: SuperAdminCreateManyInput | SuperAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SuperAdmin createManyAndReturn
   */
  export type SuperAdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * The data used to create many SuperAdmins.
     */
    data: SuperAdminCreateManyInput | SuperAdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SuperAdmin update
   */
  export type SuperAdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * The data needed to update a SuperAdmin.
     */
    data: XOR<SuperAdminUpdateInput, SuperAdminUncheckedUpdateInput>
    /**
     * Choose, which SuperAdmin to update.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin updateMany
   */
  export type SuperAdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SuperAdmins.
     */
    data: XOR<SuperAdminUpdateManyMutationInput, SuperAdminUncheckedUpdateManyInput>
    /**
     * Filter which SuperAdmins to update
     */
    where?: SuperAdminWhereInput
    /**
     * Limit how many SuperAdmins to update.
     */
    limit?: number
  }

  /**
   * SuperAdmin updateManyAndReturn
   */
  export type SuperAdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * The data used to update SuperAdmins.
     */
    data: XOR<SuperAdminUpdateManyMutationInput, SuperAdminUncheckedUpdateManyInput>
    /**
     * Filter which SuperAdmins to update
     */
    where?: SuperAdminWhereInput
    /**
     * Limit how many SuperAdmins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SuperAdmin upsert
   */
  export type SuperAdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * The filter to search for the SuperAdmin to update in case it exists.
     */
    where: SuperAdminWhereUniqueInput
    /**
     * In case the SuperAdmin found by the `where` argument doesn't exist, create a new SuperAdmin with this data.
     */
    create: XOR<SuperAdminCreateInput, SuperAdminUncheckedCreateInput>
    /**
     * In case the SuperAdmin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SuperAdminUpdateInput, SuperAdminUncheckedUpdateInput>
  }

  /**
   * SuperAdmin delete
   */
  export type SuperAdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter which SuperAdmin to delete.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin deleteMany
   */
  export type SuperAdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuperAdmins to delete
     */
    where?: SuperAdminWhereInput
    /**
     * Limit how many SuperAdmins to delete.
     */
    limit?: number
  }

  /**
   * SuperAdmin.notificationPermissionSuperAdmin
   */
  export type SuperAdmin$notificationPermissionSuperAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSuperAdmin
     */
    select?: NotificationPermissionSuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSuperAdmin
     */
    omit?: NotificationPermissionSuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSuperAdminInclude<ExtArgs> | null
    where?: NotificationPermissionSuperAdminWhereInput
  }

  /**
   * SuperAdmin without action
   */
  export type SuperAdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
  }


  /**
   * Model Supporter
   */

  export type AggregateSupporter = {
    _count: SupporterCountAggregateOutputType | null
    _avg: SupporterAvgAggregateOutputType | null
    _sum: SupporterSumAggregateOutputType | null
    _min: SupporterMinAggregateOutputType | null
    _max: SupporterMaxAggregateOutputType | null
  }

  export type SupporterAvgAggregateOutputType = {
    workload: number | null
  }

  export type SupporterSumAggregateOutputType = {
    workload: number | null
  }

  export type SupporterMinAggregateOutputType = {
    id: string | null
    userId: string | null
    supporterRole: $Enums.SupporterRole | null
    workload: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupporterMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    supporterRole: $Enums.SupporterRole | null
    workload: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupporterCountAggregateOutputType = {
    id: number
    userId: number
    supporterRole: number
    skills: number
    workload: number
    workItems: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupporterAvgAggregateInputType = {
    workload?: true
  }

  export type SupporterSumAggregateInputType = {
    workload?: true
  }

  export type SupporterMinAggregateInputType = {
    id?: true
    userId?: true
    supporterRole?: true
    workload?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupporterMaxAggregateInputType = {
    id?: true
    userId?: true
    supporterRole?: true
    workload?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupporterCountAggregateInputType = {
    id?: true
    userId?: true
    supporterRole?: true
    skills?: true
    workload?: true
    workItems?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupporterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supporter to aggregate.
     */
    where?: SupporterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Supporters to fetch.
     */
    orderBy?: SupporterOrderByWithRelationInput | SupporterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupporterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Supporters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Supporters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Supporters
    **/
    _count?: true | SupporterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupporterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupporterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupporterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupporterMaxAggregateInputType
  }

  export type GetSupporterAggregateType<T extends SupporterAggregateArgs> = {
        [P in keyof T & keyof AggregateSupporter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupporter[P]>
      : GetScalarType<T[P], AggregateSupporter[P]>
  }




  export type SupporterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupporterWhereInput
    orderBy?: SupporterOrderByWithAggregationInput | SupporterOrderByWithAggregationInput[]
    by: SupporterScalarFieldEnum[] | SupporterScalarFieldEnum
    having?: SupporterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupporterCountAggregateInputType | true
    _avg?: SupporterAvgAggregateInputType
    _sum?: SupporterSumAggregateInputType
    _min?: SupporterMinAggregateInputType
    _max?: SupporterMaxAggregateInputType
  }

  export type SupporterGroupByOutputType = {
    id: string
    userId: string
    supporterRole: $Enums.SupporterRole
    skills: string[]
    workload: number | null
    workItems: string[]
    createdAt: Date
    updatedAt: Date
    _count: SupporterCountAggregateOutputType | null
    _avg: SupporterAvgAggregateOutputType | null
    _sum: SupporterSumAggregateOutputType | null
    _min: SupporterMinAggregateOutputType | null
    _max: SupporterMaxAggregateOutputType | null
  }

  type GetSupporterGroupByPayload<T extends SupporterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupporterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupporterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupporterGroupByOutputType[P]>
            : GetScalarType<T[P], SupporterGroupByOutputType[P]>
        }
      >
    >


  export type SupporterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    supporterRole?: boolean
    skills?: boolean
    workload?: boolean
    workItems?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supporter"]>

  export type SupporterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    supporterRole?: boolean
    skills?: boolean
    workload?: boolean
    workItems?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supporter"]>

  export type SupporterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    supporterRole?: boolean
    skills?: boolean
    workload?: boolean
    workItems?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supporter"]>

  export type SupporterSelectScalar = {
    id?: boolean
    userId?: boolean
    supporterRole?: boolean
    skills?: boolean
    workload?: boolean
    workItems?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupporterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "supporterRole" | "skills" | "workload" | "workItems" | "createdAt" | "updatedAt", ExtArgs["result"]["supporter"]>
  export type SupporterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SupporterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SupporterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SupporterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supporter"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      supporterRole: $Enums.SupporterRole
      skills: string[]
      workload: number | null
      workItems: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supporter"]>
    composites: {}
  }

  type SupporterGetPayload<S extends boolean | null | undefined | SupporterDefaultArgs> = $Result.GetResult<Prisma.$SupporterPayload, S>

  type SupporterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupporterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupporterCountAggregateInputType | true
    }

  export interface SupporterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supporter'], meta: { name: 'Supporter' } }
    /**
     * Find zero or one Supporter that matches the filter.
     * @param {SupporterFindUniqueArgs} args - Arguments to find a Supporter
     * @example
     * // Get one Supporter
     * const supporter = await prisma.supporter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupporterFindUniqueArgs>(args: SelectSubset<T, SupporterFindUniqueArgs<ExtArgs>>): Prisma__SupporterClient<$Result.GetResult<Prisma.$SupporterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Supporter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupporterFindUniqueOrThrowArgs} args - Arguments to find a Supporter
     * @example
     * // Get one Supporter
     * const supporter = await prisma.supporter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupporterFindUniqueOrThrowArgs>(args: SelectSubset<T, SupporterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupporterClient<$Result.GetResult<Prisma.$SupporterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supporter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupporterFindFirstArgs} args - Arguments to find a Supporter
     * @example
     * // Get one Supporter
     * const supporter = await prisma.supporter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupporterFindFirstArgs>(args?: SelectSubset<T, SupporterFindFirstArgs<ExtArgs>>): Prisma__SupporterClient<$Result.GetResult<Prisma.$SupporterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supporter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupporterFindFirstOrThrowArgs} args - Arguments to find a Supporter
     * @example
     * // Get one Supporter
     * const supporter = await prisma.supporter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupporterFindFirstOrThrowArgs>(args?: SelectSubset<T, SupporterFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupporterClient<$Result.GetResult<Prisma.$SupporterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Supporters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupporterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Supporters
     * const supporters = await prisma.supporter.findMany()
     * 
     * // Get first 10 Supporters
     * const supporters = await prisma.supporter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supporterWithIdOnly = await prisma.supporter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupporterFindManyArgs>(args?: SelectSubset<T, SupporterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupporterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Supporter.
     * @param {SupporterCreateArgs} args - Arguments to create a Supporter.
     * @example
     * // Create one Supporter
     * const Supporter = await prisma.supporter.create({
     *   data: {
     *     // ... data to create a Supporter
     *   }
     * })
     * 
     */
    create<T extends SupporterCreateArgs>(args: SelectSubset<T, SupporterCreateArgs<ExtArgs>>): Prisma__SupporterClient<$Result.GetResult<Prisma.$SupporterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Supporters.
     * @param {SupporterCreateManyArgs} args - Arguments to create many Supporters.
     * @example
     * // Create many Supporters
     * const supporter = await prisma.supporter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupporterCreateManyArgs>(args?: SelectSubset<T, SupporterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Supporters and returns the data saved in the database.
     * @param {SupporterCreateManyAndReturnArgs} args - Arguments to create many Supporters.
     * @example
     * // Create many Supporters
     * const supporter = await prisma.supporter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Supporters and only return the `id`
     * const supporterWithIdOnly = await prisma.supporter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupporterCreateManyAndReturnArgs>(args?: SelectSubset<T, SupporterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupporterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Supporter.
     * @param {SupporterDeleteArgs} args - Arguments to delete one Supporter.
     * @example
     * // Delete one Supporter
     * const Supporter = await prisma.supporter.delete({
     *   where: {
     *     // ... filter to delete one Supporter
     *   }
     * })
     * 
     */
    delete<T extends SupporterDeleteArgs>(args: SelectSubset<T, SupporterDeleteArgs<ExtArgs>>): Prisma__SupporterClient<$Result.GetResult<Prisma.$SupporterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Supporter.
     * @param {SupporterUpdateArgs} args - Arguments to update one Supporter.
     * @example
     * // Update one Supporter
     * const supporter = await prisma.supporter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupporterUpdateArgs>(args: SelectSubset<T, SupporterUpdateArgs<ExtArgs>>): Prisma__SupporterClient<$Result.GetResult<Prisma.$SupporterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Supporters.
     * @param {SupporterDeleteManyArgs} args - Arguments to filter Supporters to delete.
     * @example
     * // Delete a few Supporters
     * const { count } = await prisma.supporter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupporterDeleteManyArgs>(args?: SelectSubset<T, SupporterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Supporters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupporterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Supporters
     * const supporter = await prisma.supporter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupporterUpdateManyArgs>(args: SelectSubset<T, SupporterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Supporters and returns the data updated in the database.
     * @param {SupporterUpdateManyAndReturnArgs} args - Arguments to update many Supporters.
     * @example
     * // Update many Supporters
     * const supporter = await prisma.supporter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Supporters and only return the `id`
     * const supporterWithIdOnly = await prisma.supporter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupporterUpdateManyAndReturnArgs>(args: SelectSubset<T, SupporterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupporterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Supporter.
     * @param {SupporterUpsertArgs} args - Arguments to update or create a Supporter.
     * @example
     * // Update or create a Supporter
     * const supporter = await prisma.supporter.upsert({
     *   create: {
     *     // ... data to create a Supporter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supporter we want to update
     *   }
     * })
     */
    upsert<T extends SupporterUpsertArgs>(args: SelectSubset<T, SupporterUpsertArgs<ExtArgs>>): Prisma__SupporterClient<$Result.GetResult<Prisma.$SupporterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Supporters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupporterCountArgs} args - Arguments to filter Supporters to count.
     * @example
     * // Count the number of Supporters
     * const count = await prisma.supporter.count({
     *   where: {
     *     // ... the filter for the Supporters we want to count
     *   }
     * })
    **/
    count<T extends SupporterCountArgs>(
      args?: Subset<T, SupporterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupporterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supporter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupporterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupporterAggregateArgs>(args: Subset<T, SupporterAggregateArgs>): Prisma.PrismaPromise<GetSupporterAggregateType<T>>

    /**
     * Group by Supporter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupporterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupporterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupporterGroupByArgs['orderBy'] }
        : { orderBy?: SupporterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupporterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupporterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supporter model
   */
  readonly fields: SupporterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supporter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupporterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supporter model
   */
  interface SupporterFieldRefs {
    readonly id: FieldRef<"Supporter", 'String'>
    readonly userId: FieldRef<"Supporter", 'String'>
    readonly supporterRole: FieldRef<"Supporter", 'SupporterRole'>
    readonly skills: FieldRef<"Supporter", 'String[]'>
    readonly workload: FieldRef<"Supporter", 'Int'>
    readonly workItems: FieldRef<"Supporter", 'String[]'>
    readonly createdAt: FieldRef<"Supporter", 'DateTime'>
    readonly updatedAt: FieldRef<"Supporter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Supporter findUnique
   */
  export type SupporterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supporter
     */
    omit?: SupporterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupporterInclude<ExtArgs> | null
    /**
     * Filter, which Supporter to fetch.
     */
    where: SupporterWhereUniqueInput
  }

  /**
   * Supporter findUniqueOrThrow
   */
  export type SupporterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supporter
     */
    omit?: SupporterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupporterInclude<ExtArgs> | null
    /**
     * Filter, which Supporter to fetch.
     */
    where: SupporterWhereUniqueInput
  }

  /**
   * Supporter findFirst
   */
  export type SupporterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supporter
     */
    omit?: SupporterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupporterInclude<ExtArgs> | null
    /**
     * Filter, which Supporter to fetch.
     */
    where?: SupporterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Supporters to fetch.
     */
    orderBy?: SupporterOrderByWithRelationInput | SupporterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Supporters.
     */
    cursor?: SupporterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Supporters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Supporters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Supporters.
     */
    distinct?: SupporterScalarFieldEnum | SupporterScalarFieldEnum[]
  }

  /**
   * Supporter findFirstOrThrow
   */
  export type SupporterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supporter
     */
    omit?: SupporterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupporterInclude<ExtArgs> | null
    /**
     * Filter, which Supporter to fetch.
     */
    where?: SupporterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Supporters to fetch.
     */
    orderBy?: SupporterOrderByWithRelationInput | SupporterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Supporters.
     */
    cursor?: SupporterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Supporters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Supporters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Supporters.
     */
    distinct?: SupporterScalarFieldEnum | SupporterScalarFieldEnum[]
  }

  /**
   * Supporter findMany
   */
  export type SupporterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supporter
     */
    omit?: SupporterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupporterInclude<ExtArgs> | null
    /**
     * Filter, which Supporters to fetch.
     */
    where?: SupporterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Supporters to fetch.
     */
    orderBy?: SupporterOrderByWithRelationInput | SupporterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Supporters.
     */
    cursor?: SupporterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Supporters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Supporters.
     */
    skip?: number
    distinct?: SupporterScalarFieldEnum | SupporterScalarFieldEnum[]
  }

  /**
   * Supporter create
   */
  export type SupporterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supporter
     */
    omit?: SupporterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupporterInclude<ExtArgs> | null
    /**
     * The data needed to create a Supporter.
     */
    data: XOR<SupporterCreateInput, SupporterUncheckedCreateInput>
  }

  /**
   * Supporter createMany
   */
  export type SupporterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Supporters.
     */
    data: SupporterCreateManyInput | SupporterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supporter createManyAndReturn
   */
  export type SupporterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supporter
     */
    omit?: SupporterOmit<ExtArgs> | null
    /**
     * The data used to create many Supporters.
     */
    data: SupporterCreateManyInput | SupporterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupporterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supporter update
   */
  export type SupporterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supporter
     */
    omit?: SupporterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupporterInclude<ExtArgs> | null
    /**
     * The data needed to update a Supporter.
     */
    data: XOR<SupporterUpdateInput, SupporterUncheckedUpdateInput>
    /**
     * Choose, which Supporter to update.
     */
    where: SupporterWhereUniqueInput
  }

  /**
   * Supporter updateMany
   */
  export type SupporterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Supporters.
     */
    data: XOR<SupporterUpdateManyMutationInput, SupporterUncheckedUpdateManyInput>
    /**
     * Filter which Supporters to update
     */
    where?: SupporterWhereInput
    /**
     * Limit how many Supporters to update.
     */
    limit?: number
  }

  /**
   * Supporter updateManyAndReturn
   */
  export type SupporterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supporter
     */
    omit?: SupporterOmit<ExtArgs> | null
    /**
     * The data used to update Supporters.
     */
    data: XOR<SupporterUpdateManyMutationInput, SupporterUncheckedUpdateManyInput>
    /**
     * Filter which Supporters to update
     */
    where?: SupporterWhereInput
    /**
     * Limit how many Supporters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupporterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supporter upsert
   */
  export type SupporterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supporter
     */
    omit?: SupporterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupporterInclude<ExtArgs> | null
    /**
     * The filter to search for the Supporter to update in case it exists.
     */
    where: SupporterWhereUniqueInput
    /**
     * In case the Supporter found by the `where` argument doesn't exist, create a new Supporter with this data.
     */
    create: XOR<SupporterCreateInput, SupporterUncheckedCreateInput>
    /**
     * In case the Supporter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupporterUpdateInput, SupporterUncheckedUpdateInput>
  }

  /**
   * Supporter delete
   */
  export type SupporterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supporter
     */
    omit?: SupporterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupporterInclude<ExtArgs> | null
    /**
     * Filter which Supporter to delete.
     */
    where: SupporterWhereUniqueInput
  }

  /**
   * Supporter deleteMany
   */
  export type SupporterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supporters to delete
     */
    where?: SupporterWhereInput
    /**
     * Limit how many Supporters to delete.
     */
    limit?: number
  }

  /**
   * Supporter without action
   */
  export type SupporterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supporter
     */
    omit?: SupporterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupporterInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    progress: number | null
  }

  export type TaskSumAggregateOutputType = {
    progress: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    status: $Enums.TaskStatus | null
    name: string | null
    projectId: string | null
    progress: number | null
    dueDate: string | null
    assignedTo: string | null
    assigneeType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    status: $Enums.TaskStatus | null
    name: string | null
    projectId: string | null
    progress: number | null
    dueDate: string | null
    assignedTo: string | null
    assigneeType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    status: number
    name: number
    projectId: number
    progress: number
    dueDate: number
    assignedTo: number
    assigneeType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    progress?: true
  }

  export type TaskSumAggregateInputType = {
    progress?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    status?: true
    name?: true
    projectId?: true
    progress?: true
    dueDate?: true
    assignedTo?: true
    assigneeType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    status?: true
    name?: true
    projectId?: true
    progress?: true
    dueDate?: true
    assignedTo?: true
    assigneeType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    status?: true
    name?: true
    projectId?: true
    progress?: true
    dueDate?: true
    assignedTo?: true
    assigneeType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    status: $Enums.TaskStatus | null
    name: string
    projectId: string
    progress: number | null
    dueDate: string | null
    assignedTo: string
    assigneeType: string
    createdAt: Date
    updatedAt: Date
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    name?: boolean
    projectId?: boolean
    progress?: boolean
    dueDate?: boolean
    assignedTo?: boolean
    assigneeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    name?: boolean
    projectId?: boolean
    progress?: boolean
    dueDate?: boolean
    assignedTo?: boolean
    assigneeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    name?: boolean
    projectId?: boolean
    progress?: boolean
    dueDate?: boolean
    assignedTo?: boolean
    assigneeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    status?: boolean
    name?: boolean
    projectId?: boolean
    progress?: boolean
    dueDate?: boolean
    assignedTo?: boolean
    assigneeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "name" | "projectId" | "progress" | "dueDate" | "assignedTo" | "assigneeType" | "createdAt" | "updatedAt", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.TaskStatus | null
      name: string
      projectId: string
      progress: number | null
      dueDate: string | null
      assignedTo: string
      assigneeType: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'TaskStatus'>
    readonly name: FieldRef<"Task", 'String'>
    readonly projectId: FieldRef<"Task", 'String'>
    readonly progress: FieldRef<"Task", 'Int'>
    readonly dueDate: FieldRef<"Task", 'String'>
    readonly assignedTo: FieldRef<"Task", 'String'>
    readonly assigneeType: FieldRef<"Task", 'String'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model Ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    companyName: string | null
    subject: string | null
    status: $Enums.TicketStatus | null
    priority: $Enums.Priority | null
    issue: string | null
    adminNote: string | null
    attachFile: string | null
    issueType: $Enums.IssueType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    companyName: string | null
    subject: string | null
    status: $Enums.TicketStatus | null
    priority: $Enums.Priority | null
    issue: string | null
    adminNote: string | null
    attachFile: string | null
    issueType: $Enums.IssueType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketCountAggregateOutputType = {
    id: number
    clientId: number
    supporterIds: number
    adminIds: number
    companyName: number
    subject: number
    status: number
    priority: number
    issue: number
    adminNote: number
    attachFile: number
    issueType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TicketMinAggregateInputType = {
    id?: true
    clientId?: true
    companyName?: true
    subject?: true
    status?: true
    priority?: true
    issue?: true
    adminNote?: true
    attachFile?: true
    issueType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketMaxAggregateInputType = {
    id?: true
    clientId?: true
    companyName?: true
    subject?: true
    status?: true
    priority?: true
    issue?: true
    adminNote?: true
    attachFile?: true
    issueType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketCountAggregateInputType = {
    id?: true
    clientId?: true
    supporterIds?: true
    adminIds?: true
    companyName?: true
    subject?: true
    status?: true
    priority?: true
    issue?: true
    adminNote?: true
    attachFile?: true
    issueType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticket to aggregate.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type TicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithAggregationInput | TicketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: TicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    id: string
    clientId: string
    supporterIds: string[]
    adminIds: string[]
    companyName: string | null
    subject: string
    status: $Enums.TicketStatus
    priority: $Enums.Priority
    issue: string
    adminNote: string | null
    attachFile: string | null
    issueType: $Enums.IssueType
    createdAt: Date
    updatedAt: Date
    _count: TicketCountAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends TicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type TicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    supporterIds?: boolean
    adminIds?: boolean
    companyName?: boolean
    subject?: boolean
    status?: boolean
    priority?: boolean
    issue?: boolean
    adminNote?: boolean
    attachFile?: boolean
    issueType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    supporterIds?: boolean
    adminIds?: boolean
    companyName?: boolean
    subject?: boolean
    status?: boolean
    priority?: boolean
    issue?: boolean
    adminNote?: boolean
    attachFile?: boolean
    issueType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    supporterIds?: boolean
    adminIds?: boolean
    companyName?: boolean
    subject?: boolean
    status?: boolean
    priority?: boolean
    issue?: boolean
    adminNote?: boolean
    attachFile?: boolean
    issueType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectScalar = {
    id?: boolean
    clientId?: boolean
    supporterIds?: boolean
    adminIds?: boolean
    companyName?: boolean
    subject?: boolean
    status?: boolean
    priority?: boolean
    issue?: boolean
    adminNote?: boolean
    attachFile?: boolean
    issueType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "supporterIds" | "adminIds" | "companyName" | "subject" | "status" | "priority" | "issue" | "adminNote" | "attachFile" | "issueType" | "createdAt" | "updatedAt", ExtArgs["result"]["ticket"]>
  export type TicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type TicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type TicketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $TicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticket"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      supporterIds: string[]
      adminIds: string[]
      companyName: string | null
      subject: string
      status: $Enums.TicketStatus
      priority: $Enums.Priority
      issue: string
      adminNote: string | null
      attachFile: string | null
      issueType: $Enums.IssueType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type TicketGetPayload<S extends boolean | null | undefined | TicketDefaultArgs> = $Result.GetResult<Prisma.$TicketPayload, S>

  type TicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface TicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticket'], meta: { name: 'Ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {TicketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFindUniqueArgs>(args: SelectSubset<T, TicketFindUniqueArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFindFirstArgs>(args?: SelectSubset<T, TicketFindFirstArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketWithIdOnly = await prisma.ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFindManyArgs>(args?: SelectSubset<T, TicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ticket.
     * @param {TicketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends TicketCreateArgs>(args: SelectSubset<T, TicketCreateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tickets.
     * @param {TicketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCreateManyArgs>(args?: SelectSubset<T, TicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tickets and returns the data saved in the database.
     * @param {TicketCreateManyAndReturnArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ticket.
     * @param {TicketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends TicketDeleteArgs>(args: SelectSubset<T, TicketDeleteArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ticket.
     * @param {TicketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketUpdateArgs>(args: SelectSubset<T, TicketUpdateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tickets.
     * @param {TicketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketDeleteManyArgs>(args?: SelectSubset<T, TicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketUpdateManyArgs>(args: SelectSubset<T, TicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets and returns the data updated in the database.
     * @param {TicketUpdateManyAndReturnArgs} args - Arguments to update many Tickets.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ticket.
     * @param {TicketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends TicketUpsertArgs>(args: SelectSubset<T, TicketUpsertArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketCountArgs>(
      args?: Subset<T, TicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketGroupByArgs['orderBy'] }
        : { orderBy?: TicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticket model
   */
  readonly fields: TicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticket model
   */
  interface TicketFieldRefs {
    readonly id: FieldRef<"Ticket", 'String'>
    readonly clientId: FieldRef<"Ticket", 'String'>
    readonly supporterIds: FieldRef<"Ticket", 'String[]'>
    readonly adminIds: FieldRef<"Ticket", 'String[]'>
    readonly companyName: FieldRef<"Ticket", 'String'>
    readonly subject: FieldRef<"Ticket", 'String'>
    readonly status: FieldRef<"Ticket", 'TicketStatus'>
    readonly priority: FieldRef<"Ticket", 'Priority'>
    readonly issue: FieldRef<"Ticket", 'String'>
    readonly adminNote: FieldRef<"Ticket", 'String'>
    readonly attachFile: FieldRef<"Ticket", 'String'>
    readonly issueType: FieldRef<"Ticket", 'IssueType'>
    readonly createdAt: FieldRef<"Ticket", 'DateTime'>
    readonly updatedAt: FieldRef<"Ticket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ticket findUnique
   */
  export type TicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findUniqueOrThrow
   */
  export type TicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findFirst
   */
  export type TicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findFirstOrThrow
   */
  export type TicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findMany
   */
  export type TicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket create
   */
  export type TicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to create a Ticket.
     */
    data: XOR<TicketCreateInput, TicketUncheckedCreateInput>
  }

  /**
   * Ticket createMany
   */
  export type TicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ticket createManyAndReturn
   */
  export type TicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket update
   */
  export type TicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to update a Ticket.
     */
    data: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    /**
     * Choose, which Ticket to update.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket updateMany
   */
  export type TicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
  }

  /**
   * Ticket updateManyAndReturn
   */
  export type TicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket upsert
   */
  export type TicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The filter to search for the Ticket to update in case it exists.
     */
    where: TicketWhereUniqueInput
    /**
     * In case the Ticket found by the `where` argument doesn't exist, create a new Ticket with this data.
     */
    create: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    /**
     * In case the Ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
  }

  /**
   * Ticket delete
   */
  export type TicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter which Ticket to delete.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket deleteMany
   */
  export type TicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to delete.
     */
    limit?: number
  }

  /**
   * Ticket without action
   */
  export type TicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    phoneNumber: string | null
    password: string | null
    name: string | null
    role: $Enums.Role | null
    profileImage: string | null
    language: $Enums.Language | null
    timezone: Date | null
    verification2FA: boolean | null
    status: boolean | null
    lastActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    userStatus: $Enums.UserStatus | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    phoneNumber: string | null
    password: string | null
    name: string | null
    role: $Enums.Role | null
    profileImage: string | null
    language: $Enums.Language | null
    timezone: Date | null
    verification2FA: boolean | null
    status: boolean | null
    lastActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    userStatus: $Enums.UserStatus | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    phoneNumber: number
    password: number
    name: number
    role: number
    profileImage: number
    language: number
    timezone: number
    verification2FA: number
    status: number
    lastActive: number
    createdAt: number
    updatedAt: number
    userStatus: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    phoneNumber?: true
    password?: true
    name?: true
    role?: true
    profileImage?: true
    language?: true
    timezone?: true
    verification2FA?: true
    status?: true
    lastActive?: true
    createdAt?: true
    updatedAt?: true
    userStatus?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    phoneNumber?: true
    password?: true
    name?: true
    role?: true
    profileImage?: true
    language?: true
    timezone?: true
    verification2FA?: true
    status?: true
    lastActive?: true
    createdAt?: true
    updatedAt?: true
    userStatus?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    phoneNumber?: true
    password?: true
    name?: true
    role?: true
    profileImage?: true
    language?: true
    timezone?: true
    verification2FA?: true
    status?: true
    lastActive?: true
    createdAt?: true
    updatedAt?: true
    userStatus?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role: $Enums.Role
    profileImage: string | null
    language: $Enums.Language
    timezone: Date | null
    verification2FA: boolean
    status: boolean
    lastActive: boolean
    createdAt: Date
    updatedAt: Date
    userStatus: $Enums.UserStatus
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phoneNumber?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    profileImage?: boolean
    language?: boolean
    timezone?: boolean
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userStatus?: boolean
    client?: boolean | User$clientArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
    employee?: boolean | User$employeeArgs<ExtArgs>
    viewer?: boolean | User$viewerArgs<ExtArgs>
    supporter?: boolean | User$supporterArgs<ExtArgs>
    superAdmin?: boolean | User$superAdminArgs<ExtArgs>
    notificationEmployee?: boolean | User$notificationEmployeeArgs<ExtArgs>
    notificationManager?: boolean | User$notificationManagerArgs<ExtArgs>
    notificationClient?: boolean | User$notificationClientArgs<ExtArgs>
    notificationSupporter?: boolean | User$notificationSupporterArgs<ExtArgs>
    notificationAdmin?: boolean | User$notificationAdminArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    otpVerification?: boolean | User$otpVerificationArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phoneNumber?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    profileImage?: boolean
    language?: boolean
    timezone?: boolean
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userStatus?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phoneNumber?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    profileImage?: boolean
    language?: boolean
    timezone?: boolean
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userStatus?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    phoneNumber?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    profileImage?: boolean
    language?: boolean
    timezone?: boolean
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userStatus?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "phoneNumber" | "password" | "name" | "role" | "profileImage" | "language" | "timezone" | "verification2FA" | "status" | "lastActive" | "createdAt" | "updatedAt" | "userStatus", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | User$clientArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
    employee?: boolean | User$employeeArgs<ExtArgs>
    viewer?: boolean | User$viewerArgs<ExtArgs>
    supporter?: boolean | User$supporterArgs<ExtArgs>
    superAdmin?: boolean | User$superAdminArgs<ExtArgs>
    notificationEmployee?: boolean | User$notificationEmployeeArgs<ExtArgs>
    notificationManager?: boolean | User$notificationManagerArgs<ExtArgs>
    notificationClient?: boolean | User$notificationClientArgs<ExtArgs>
    notificationSupporter?: boolean | User$notificationSupporterArgs<ExtArgs>
    notificationAdmin?: boolean | User$notificationAdminArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    otpVerification?: boolean | User$otpVerificationArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
      manager: Prisma.$ManagerPayload<ExtArgs> | null
      employee: Prisma.$EmployeePayload<ExtArgs> | null
      viewer: Prisma.$ViewerPayload<ExtArgs> | null
      supporter: Prisma.$SupporterPayload<ExtArgs> | null
      superAdmin: Prisma.$SuperAdminPayload<ExtArgs> | null
      notificationEmployee: Prisma.$NotificationPermissionEmployeePayload<ExtArgs> | null
      notificationManager: Prisma.$NotificationPermissionManagerPayload<ExtArgs> | null
      notificationClient: Prisma.$NotificationPermissionClientPayload<ExtArgs> | null
      notificationSupporter: Prisma.$NotificationPermissionSupporterPayload<ExtArgs> | null
      notificationAdmin: Prisma.$NotificationPermissionAdminPayload<ExtArgs> | null
      notifications: Prisma.$NotificationProvisionPayload<ExtArgs>[]
      otpVerification: Prisma.$OtpVerificationPayload<ExtArgs> | null
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      phoneNumber: string
      password: string
      name: string
      role: $Enums.Role
      profileImage: string | null
      language: $Enums.Language
      timezone: Date | null
      verification2FA: boolean
      status: boolean
      lastActive: boolean
      createdAt: Date
      updatedAt: Date
      userStatus: $Enums.UserStatus
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends User$clientArgs<ExtArgs> = {}>(args?: Subset<T, User$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    manager<T extends User$managerArgs<ExtArgs> = {}>(args?: Subset<T, User$managerArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    employee<T extends User$employeeArgs<ExtArgs> = {}>(args?: Subset<T, User$employeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    viewer<T extends User$viewerArgs<ExtArgs> = {}>(args?: Subset<T, User$viewerArgs<ExtArgs>>): Prisma__ViewerClient<$Result.GetResult<Prisma.$ViewerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    supporter<T extends User$supporterArgs<ExtArgs> = {}>(args?: Subset<T, User$supporterArgs<ExtArgs>>): Prisma__SupporterClient<$Result.GetResult<Prisma.$SupporterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    superAdmin<T extends User$superAdminArgs<ExtArgs> = {}>(args?: Subset<T, User$superAdminArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notificationEmployee<T extends User$notificationEmployeeArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationEmployeeArgs<ExtArgs>>): Prisma__NotificationPermissionEmployeeClient<$Result.GetResult<Prisma.$NotificationPermissionEmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notificationManager<T extends User$notificationManagerArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationManagerArgs<ExtArgs>>): Prisma__NotificationPermissionManagerClient<$Result.GetResult<Prisma.$NotificationPermissionManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notificationClient<T extends User$notificationClientArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationClientArgs<ExtArgs>>): Prisma__NotificationPermissionClientClient<$Result.GetResult<Prisma.$NotificationPermissionClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notificationSupporter<T extends User$notificationSupporterArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationSupporterArgs<ExtArgs>>): Prisma__NotificationPermissionSupporterClient<$Result.GetResult<Prisma.$NotificationPermissionSupporterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notificationAdmin<T extends User$notificationAdminArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationAdminArgs<ExtArgs>>): Prisma__NotificationPermissionAdminClient<$Result.GetResult<Prisma.$NotificationPermissionAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationProvisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    otpVerification<T extends User$otpVerificationArgs<ExtArgs> = {}>(args?: Subset<T, User$otpVerificationArgs<ExtArgs>>): Prisma__OtpVerificationClient<$Result.GetResult<Prisma.$OtpVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends User$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly profileImage: FieldRef<"User", 'String'>
    readonly language: FieldRef<"User", 'Language'>
    readonly timezone: FieldRef<"User", 'DateTime'>
    readonly verification2FA: FieldRef<"User", 'Boolean'>
    readonly status: FieldRef<"User", 'Boolean'>
    readonly lastActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly userStatus: FieldRef<"User", 'UserStatus'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.client
   */
  export type User$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * User.manager
   */
  export type User$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    where?: ManagerWhereInput
  }

  /**
   * User.employee
   */
  export type User$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * User.viewer
   */
  export type User$viewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viewer
     */
    select?: ViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Viewer
     */
    omit?: ViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerInclude<ExtArgs> | null
    where?: ViewerWhereInput
  }

  /**
   * User.supporter
   */
  export type User$supporterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supporter
     */
    omit?: SupporterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupporterInclude<ExtArgs> | null
    where?: SupporterWhereInput
  }

  /**
   * User.superAdmin
   */
  export type User$superAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    where?: SuperAdminWhereInput
  }

  /**
   * User.notificationEmployee
   */
  export type User$notificationEmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionEmployee
     */
    select?: NotificationPermissionEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionEmployee
     */
    omit?: NotificationPermissionEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionEmployeeInclude<ExtArgs> | null
    where?: NotificationPermissionEmployeeWhereInput
  }

  /**
   * User.notificationManager
   */
  export type User$notificationManagerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionManager
     */
    select?: NotificationPermissionManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionManager
     */
    omit?: NotificationPermissionManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionManagerInclude<ExtArgs> | null
    where?: NotificationPermissionManagerWhereInput
  }

  /**
   * User.notificationClient
   */
  export type User$notificationClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionClient
     */
    select?: NotificationPermissionClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionClient
     */
    omit?: NotificationPermissionClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionClientInclude<ExtArgs> | null
    where?: NotificationPermissionClientWhereInput
  }

  /**
   * User.notificationSupporter
   */
  export type User$notificationSupporterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionSupporter
     */
    select?: NotificationPermissionSupporterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionSupporter
     */
    omit?: NotificationPermissionSupporterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionSupporterInclude<ExtArgs> | null
    where?: NotificationPermissionSupporterWhereInput
  }

  /**
   * User.notificationAdmin
   */
  export type User$notificationAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPermissionAdmin
     */
    select?: NotificationPermissionAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPermissionAdmin
     */
    omit?: NotificationPermissionAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPermissionAdminInclude<ExtArgs> | null
    where?: NotificationPermissionAdminWhereInput
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationProvision
     */
    select?: NotificationProvisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationProvision
     */
    omit?: NotificationProvisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationProvisionInclude<ExtArgs> | null
    where?: NotificationProvisionWhereInput
    orderBy?: NotificationProvisionOrderByWithRelationInput | NotificationProvisionOrderByWithRelationInput[]
    cursor?: NotificationProvisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationProvisionScalarFieldEnum | NotificationProvisionScalarFieldEnum[]
  }

  /**
   * User.otpVerification
   */
  export type User$otpVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpVerification
     */
    omit?: OtpVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpVerificationInclude<ExtArgs> | null
    where?: OtpVerificationWhereInput
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.activities
   */
  export type User$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    clientId: number
    tags: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    clientId?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    clientId: string
    tags: string[]
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    clientId?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    clientId?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    clientId?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    clientId?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"clientId" | "tags" | "createdAt" | "updatedAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      clientId: string
      tags: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `clientId`
     * const tagWithClientIdOnly = await prisma.tag.findMany({ select: { clientId: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `clientId`
     * const tagWithClientIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { clientId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `clientId`
     * const tagWithClientIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { clientId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly clientId: FieldRef<"Tag", 'String'>
    readonly tags: FieldRef<"Tag", 'String[]'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model ReferredPerson
   */

  export type AggregateReferredPerson = {
    _count: ReferredPersonCountAggregateOutputType | null
    _avg: ReferredPersonAvgAggregateOutputType | null
    _sum: ReferredPersonSumAggregateOutputType | null
    _min: ReferredPersonMinAggregateOutputType | null
    _max: ReferredPersonMaxAggregateOutputType | null
  }

  export type ReferredPersonAvgAggregateOutputType = {
    phoneNumber: number | null
  }

  export type ReferredPersonSumAggregateOutputType = {
    phoneNumber: number | null
  }

  export type ReferredPersonMinAggregateOutputType = {
    id: string | null
    name: string | null
    userId: string | null
    email: string | null
    phoneNumber: number | null
    aboutThere: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferredPersonMaxAggregateOutputType = {
    id: string | null
    name: string | null
    userId: string | null
    email: string | null
    phoneNumber: number | null
    aboutThere: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferredPersonCountAggregateOutputType = {
    id: number
    name: number
    userId: number
    email: number
    phoneNumber: number
    aboutThere: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReferredPersonAvgAggregateInputType = {
    phoneNumber?: true
  }

  export type ReferredPersonSumAggregateInputType = {
    phoneNumber?: true
  }

  export type ReferredPersonMinAggregateInputType = {
    id?: true
    name?: true
    userId?: true
    email?: true
    phoneNumber?: true
    aboutThere?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferredPersonMaxAggregateInputType = {
    id?: true
    name?: true
    userId?: true
    email?: true
    phoneNumber?: true
    aboutThere?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferredPersonCountAggregateInputType = {
    id?: true
    name?: true
    userId?: true
    email?: true
    phoneNumber?: true
    aboutThere?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReferredPersonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferredPerson to aggregate.
     */
    where?: ReferredPersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferredPeople to fetch.
     */
    orderBy?: ReferredPersonOrderByWithRelationInput | ReferredPersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferredPersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferredPeople from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferredPeople.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReferredPeople
    **/
    _count?: true | ReferredPersonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferredPersonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferredPersonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferredPersonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferredPersonMaxAggregateInputType
  }

  export type GetReferredPersonAggregateType<T extends ReferredPersonAggregateArgs> = {
        [P in keyof T & keyof AggregateReferredPerson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferredPerson[P]>
      : GetScalarType<T[P], AggregateReferredPerson[P]>
  }




  export type ReferredPersonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferredPersonWhereInput
    orderBy?: ReferredPersonOrderByWithAggregationInput | ReferredPersonOrderByWithAggregationInput[]
    by: ReferredPersonScalarFieldEnum[] | ReferredPersonScalarFieldEnum
    having?: ReferredPersonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferredPersonCountAggregateInputType | true
    _avg?: ReferredPersonAvgAggregateInputType
    _sum?: ReferredPersonSumAggregateInputType
    _min?: ReferredPersonMinAggregateInputType
    _max?: ReferredPersonMaxAggregateInputType
  }

  export type ReferredPersonGroupByOutputType = {
    id: string
    name: string
    userId: string
    email: string | null
    phoneNumber: number | null
    aboutThere: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReferredPersonCountAggregateOutputType | null
    _avg: ReferredPersonAvgAggregateOutputType | null
    _sum: ReferredPersonSumAggregateOutputType | null
    _min: ReferredPersonMinAggregateOutputType | null
    _max: ReferredPersonMaxAggregateOutputType | null
  }

  type GetReferredPersonGroupByPayload<T extends ReferredPersonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferredPersonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferredPersonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferredPersonGroupByOutputType[P]>
            : GetScalarType<T[P], ReferredPersonGroupByOutputType[P]>
        }
      >
    >


  export type ReferredPersonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    userId?: boolean
    email?: boolean
    phoneNumber?: boolean
    aboutThere?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referredPerson"]>

  export type ReferredPersonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    userId?: boolean
    email?: boolean
    phoneNumber?: boolean
    aboutThere?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referredPerson"]>

  export type ReferredPersonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    userId?: boolean
    email?: boolean
    phoneNumber?: boolean
    aboutThere?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referredPerson"]>

  export type ReferredPersonSelectScalar = {
    id?: boolean
    name?: boolean
    userId?: boolean
    email?: boolean
    phoneNumber?: boolean
    aboutThere?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReferredPersonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "userId" | "email" | "phoneNumber" | "aboutThere" | "createdAt" | "updatedAt", ExtArgs["result"]["referredPerson"]>
  export type ReferredPersonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type ReferredPersonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type ReferredPersonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $ReferredPersonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReferredPerson"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      userId: string
      email: string | null
      phoneNumber: number | null
      aboutThere: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["referredPerson"]>
    composites: {}
  }

  type ReferredPersonGetPayload<S extends boolean | null | undefined | ReferredPersonDefaultArgs> = $Result.GetResult<Prisma.$ReferredPersonPayload, S>

  type ReferredPersonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferredPersonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferredPersonCountAggregateInputType | true
    }

  export interface ReferredPersonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReferredPerson'], meta: { name: 'ReferredPerson' } }
    /**
     * Find zero or one ReferredPerson that matches the filter.
     * @param {ReferredPersonFindUniqueArgs} args - Arguments to find a ReferredPerson
     * @example
     * // Get one ReferredPerson
     * const referredPerson = await prisma.referredPerson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferredPersonFindUniqueArgs>(args: SelectSubset<T, ReferredPersonFindUniqueArgs<ExtArgs>>): Prisma__ReferredPersonClient<$Result.GetResult<Prisma.$ReferredPersonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReferredPerson that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferredPersonFindUniqueOrThrowArgs} args - Arguments to find a ReferredPerson
     * @example
     * // Get one ReferredPerson
     * const referredPerson = await prisma.referredPerson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferredPersonFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferredPersonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferredPersonClient<$Result.GetResult<Prisma.$ReferredPersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReferredPerson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferredPersonFindFirstArgs} args - Arguments to find a ReferredPerson
     * @example
     * // Get one ReferredPerson
     * const referredPerson = await prisma.referredPerson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferredPersonFindFirstArgs>(args?: SelectSubset<T, ReferredPersonFindFirstArgs<ExtArgs>>): Prisma__ReferredPersonClient<$Result.GetResult<Prisma.$ReferredPersonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReferredPerson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferredPersonFindFirstOrThrowArgs} args - Arguments to find a ReferredPerson
     * @example
     * // Get one ReferredPerson
     * const referredPerson = await prisma.referredPerson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferredPersonFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferredPersonFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferredPersonClient<$Result.GetResult<Prisma.$ReferredPersonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReferredPeople that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferredPersonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReferredPeople
     * const referredPeople = await prisma.referredPerson.findMany()
     * 
     * // Get first 10 ReferredPeople
     * const referredPeople = await prisma.referredPerson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referredPersonWithIdOnly = await prisma.referredPerson.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferredPersonFindManyArgs>(args?: SelectSubset<T, ReferredPersonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferredPersonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReferredPerson.
     * @param {ReferredPersonCreateArgs} args - Arguments to create a ReferredPerson.
     * @example
     * // Create one ReferredPerson
     * const ReferredPerson = await prisma.referredPerson.create({
     *   data: {
     *     // ... data to create a ReferredPerson
     *   }
     * })
     * 
     */
    create<T extends ReferredPersonCreateArgs>(args: SelectSubset<T, ReferredPersonCreateArgs<ExtArgs>>): Prisma__ReferredPersonClient<$Result.GetResult<Prisma.$ReferredPersonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReferredPeople.
     * @param {ReferredPersonCreateManyArgs} args - Arguments to create many ReferredPeople.
     * @example
     * // Create many ReferredPeople
     * const referredPerson = await prisma.referredPerson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferredPersonCreateManyArgs>(args?: SelectSubset<T, ReferredPersonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReferredPeople and returns the data saved in the database.
     * @param {ReferredPersonCreateManyAndReturnArgs} args - Arguments to create many ReferredPeople.
     * @example
     * // Create many ReferredPeople
     * const referredPerson = await prisma.referredPerson.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReferredPeople and only return the `id`
     * const referredPersonWithIdOnly = await prisma.referredPerson.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferredPersonCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferredPersonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferredPersonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReferredPerson.
     * @param {ReferredPersonDeleteArgs} args - Arguments to delete one ReferredPerson.
     * @example
     * // Delete one ReferredPerson
     * const ReferredPerson = await prisma.referredPerson.delete({
     *   where: {
     *     // ... filter to delete one ReferredPerson
     *   }
     * })
     * 
     */
    delete<T extends ReferredPersonDeleteArgs>(args: SelectSubset<T, ReferredPersonDeleteArgs<ExtArgs>>): Prisma__ReferredPersonClient<$Result.GetResult<Prisma.$ReferredPersonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReferredPerson.
     * @param {ReferredPersonUpdateArgs} args - Arguments to update one ReferredPerson.
     * @example
     * // Update one ReferredPerson
     * const referredPerson = await prisma.referredPerson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferredPersonUpdateArgs>(args: SelectSubset<T, ReferredPersonUpdateArgs<ExtArgs>>): Prisma__ReferredPersonClient<$Result.GetResult<Prisma.$ReferredPersonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReferredPeople.
     * @param {ReferredPersonDeleteManyArgs} args - Arguments to filter ReferredPeople to delete.
     * @example
     * // Delete a few ReferredPeople
     * const { count } = await prisma.referredPerson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferredPersonDeleteManyArgs>(args?: SelectSubset<T, ReferredPersonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferredPeople.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferredPersonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReferredPeople
     * const referredPerson = await prisma.referredPerson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferredPersonUpdateManyArgs>(args: SelectSubset<T, ReferredPersonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferredPeople and returns the data updated in the database.
     * @param {ReferredPersonUpdateManyAndReturnArgs} args - Arguments to update many ReferredPeople.
     * @example
     * // Update many ReferredPeople
     * const referredPerson = await prisma.referredPerson.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReferredPeople and only return the `id`
     * const referredPersonWithIdOnly = await prisma.referredPerson.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReferredPersonUpdateManyAndReturnArgs>(args: SelectSubset<T, ReferredPersonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferredPersonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReferredPerson.
     * @param {ReferredPersonUpsertArgs} args - Arguments to update or create a ReferredPerson.
     * @example
     * // Update or create a ReferredPerson
     * const referredPerson = await prisma.referredPerson.upsert({
     *   create: {
     *     // ... data to create a ReferredPerson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReferredPerson we want to update
     *   }
     * })
     */
    upsert<T extends ReferredPersonUpsertArgs>(args: SelectSubset<T, ReferredPersonUpsertArgs<ExtArgs>>): Prisma__ReferredPersonClient<$Result.GetResult<Prisma.$ReferredPersonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReferredPeople.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferredPersonCountArgs} args - Arguments to filter ReferredPeople to count.
     * @example
     * // Count the number of ReferredPeople
     * const count = await prisma.referredPerson.count({
     *   where: {
     *     // ... the filter for the ReferredPeople we want to count
     *   }
     * })
    **/
    count<T extends ReferredPersonCountArgs>(
      args?: Subset<T, ReferredPersonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferredPersonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReferredPerson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferredPersonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferredPersonAggregateArgs>(args: Subset<T, ReferredPersonAggregateArgs>): Prisma.PrismaPromise<GetReferredPersonAggregateType<T>>

    /**
     * Group by ReferredPerson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferredPersonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferredPersonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferredPersonGroupByArgs['orderBy'] }
        : { orderBy?: ReferredPersonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferredPersonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferredPersonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReferredPerson model
   */
  readonly fields: ReferredPersonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReferredPerson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferredPersonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReferredPerson model
   */
  interface ReferredPersonFieldRefs {
    readonly id: FieldRef<"ReferredPerson", 'String'>
    readonly name: FieldRef<"ReferredPerson", 'String'>
    readonly userId: FieldRef<"ReferredPerson", 'String'>
    readonly email: FieldRef<"ReferredPerson", 'String'>
    readonly phoneNumber: FieldRef<"ReferredPerson", 'Int'>
    readonly aboutThere: FieldRef<"ReferredPerson", 'String'>
    readonly createdAt: FieldRef<"ReferredPerson", 'DateTime'>
    readonly updatedAt: FieldRef<"ReferredPerson", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReferredPerson findUnique
   */
  export type ReferredPersonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferredPerson
     */
    select?: ReferredPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferredPerson
     */
    omit?: ReferredPersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferredPersonInclude<ExtArgs> | null
    /**
     * Filter, which ReferredPerson to fetch.
     */
    where: ReferredPersonWhereUniqueInput
  }

  /**
   * ReferredPerson findUniqueOrThrow
   */
  export type ReferredPersonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferredPerson
     */
    select?: ReferredPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferredPerson
     */
    omit?: ReferredPersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferredPersonInclude<ExtArgs> | null
    /**
     * Filter, which ReferredPerson to fetch.
     */
    where: ReferredPersonWhereUniqueInput
  }

  /**
   * ReferredPerson findFirst
   */
  export type ReferredPersonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferredPerson
     */
    select?: ReferredPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferredPerson
     */
    omit?: ReferredPersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferredPersonInclude<ExtArgs> | null
    /**
     * Filter, which ReferredPerson to fetch.
     */
    where?: ReferredPersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferredPeople to fetch.
     */
    orderBy?: ReferredPersonOrderByWithRelationInput | ReferredPersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferredPeople.
     */
    cursor?: ReferredPersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferredPeople from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferredPeople.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferredPeople.
     */
    distinct?: ReferredPersonScalarFieldEnum | ReferredPersonScalarFieldEnum[]
  }

  /**
   * ReferredPerson findFirstOrThrow
   */
  export type ReferredPersonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferredPerson
     */
    select?: ReferredPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferredPerson
     */
    omit?: ReferredPersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferredPersonInclude<ExtArgs> | null
    /**
     * Filter, which ReferredPerson to fetch.
     */
    where?: ReferredPersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferredPeople to fetch.
     */
    orderBy?: ReferredPersonOrderByWithRelationInput | ReferredPersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferredPeople.
     */
    cursor?: ReferredPersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferredPeople from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferredPeople.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferredPeople.
     */
    distinct?: ReferredPersonScalarFieldEnum | ReferredPersonScalarFieldEnum[]
  }

  /**
   * ReferredPerson findMany
   */
  export type ReferredPersonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferredPerson
     */
    select?: ReferredPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferredPerson
     */
    omit?: ReferredPersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferredPersonInclude<ExtArgs> | null
    /**
     * Filter, which ReferredPeople to fetch.
     */
    where?: ReferredPersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferredPeople to fetch.
     */
    orderBy?: ReferredPersonOrderByWithRelationInput | ReferredPersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReferredPeople.
     */
    cursor?: ReferredPersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferredPeople from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferredPeople.
     */
    skip?: number
    distinct?: ReferredPersonScalarFieldEnum | ReferredPersonScalarFieldEnum[]
  }

  /**
   * ReferredPerson create
   */
  export type ReferredPersonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferredPerson
     */
    select?: ReferredPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferredPerson
     */
    omit?: ReferredPersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferredPersonInclude<ExtArgs> | null
    /**
     * The data needed to create a ReferredPerson.
     */
    data: XOR<ReferredPersonCreateInput, ReferredPersonUncheckedCreateInput>
  }

  /**
   * ReferredPerson createMany
   */
  export type ReferredPersonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReferredPeople.
     */
    data: ReferredPersonCreateManyInput | ReferredPersonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReferredPerson createManyAndReturn
   */
  export type ReferredPersonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferredPerson
     */
    select?: ReferredPersonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReferredPerson
     */
    omit?: ReferredPersonOmit<ExtArgs> | null
    /**
     * The data used to create many ReferredPeople.
     */
    data: ReferredPersonCreateManyInput | ReferredPersonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferredPersonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReferredPerson update
   */
  export type ReferredPersonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferredPerson
     */
    select?: ReferredPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferredPerson
     */
    omit?: ReferredPersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferredPersonInclude<ExtArgs> | null
    /**
     * The data needed to update a ReferredPerson.
     */
    data: XOR<ReferredPersonUpdateInput, ReferredPersonUncheckedUpdateInput>
    /**
     * Choose, which ReferredPerson to update.
     */
    where: ReferredPersonWhereUniqueInput
  }

  /**
   * ReferredPerson updateMany
   */
  export type ReferredPersonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReferredPeople.
     */
    data: XOR<ReferredPersonUpdateManyMutationInput, ReferredPersonUncheckedUpdateManyInput>
    /**
     * Filter which ReferredPeople to update
     */
    where?: ReferredPersonWhereInput
    /**
     * Limit how many ReferredPeople to update.
     */
    limit?: number
  }

  /**
   * ReferredPerson updateManyAndReturn
   */
  export type ReferredPersonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferredPerson
     */
    select?: ReferredPersonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReferredPerson
     */
    omit?: ReferredPersonOmit<ExtArgs> | null
    /**
     * The data used to update ReferredPeople.
     */
    data: XOR<ReferredPersonUpdateManyMutationInput, ReferredPersonUncheckedUpdateManyInput>
    /**
     * Filter which ReferredPeople to update
     */
    where?: ReferredPersonWhereInput
    /**
     * Limit how many ReferredPeople to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferredPersonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReferredPerson upsert
   */
  export type ReferredPersonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferredPerson
     */
    select?: ReferredPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferredPerson
     */
    omit?: ReferredPersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferredPersonInclude<ExtArgs> | null
    /**
     * The filter to search for the ReferredPerson to update in case it exists.
     */
    where: ReferredPersonWhereUniqueInput
    /**
     * In case the ReferredPerson found by the `where` argument doesn't exist, create a new ReferredPerson with this data.
     */
    create: XOR<ReferredPersonCreateInput, ReferredPersonUncheckedCreateInput>
    /**
     * In case the ReferredPerson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferredPersonUpdateInput, ReferredPersonUncheckedUpdateInput>
  }

  /**
   * ReferredPerson delete
   */
  export type ReferredPersonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferredPerson
     */
    select?: ReferredPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferredPerson
     */
    omit?: ReferredPersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferredPersonInclude<ExtArgs> | null
    /**
     * Filter which ReferredPerson to delete.
     */
    where: ReferredPersonWhereUniqueInput
  }

  /**
   * ReferredPerson deleteMany
   */
  export type ReferredPersonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferredPeople to delete
     */
    where?: ReferredPersonWhereInput
    /**
     * Limit how many ReferredPeople to delete.
     */
    limit?: number
  }

  /**
   * ReferredPerson without action
   */
  export type ReferredPersonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferredPerson
     */
    select?: ReferredPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferredPerson
     */
    omit?: ReferredPersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferredPersonInclude<ExtArgs> | null
  }


  /**
   * Model RequestToAddProjectMember
   */

  export type AggregateRequestToAddProjectMember = {
    _count: RequestToAddProjectMemberCountAggregateOutputType | null
    _min: RequestToAddProjectMemberMinAggregateOutputType | null
    _max: RequestToAddProjectMemberMaxAggregateOutputType | null
  }

  export type RequestToAddProjectMemberMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    projectId: string | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RequestToAddProjectMemberMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    projectId: string | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RequestToAddProjectMemberCountAggregateOutputType = {
    id: number
    clientId: number
    projectId: number
    managerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RequestToAddProjectMemberMinAggregateInputType = {
    id?: true
    clientId?: true
    projectId?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RequestToAddProjectMemberMaxAggregateInputType = {
    id?: true
    clientId?: true
    projectId?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RequestToAddProjectMemberCountAggregateInputType = {
    id?: true
    clientId?: true
    projectId?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RequestToAddProjectMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestToAddProjectMember to aggregate.
     */
    where?: RequestToAddProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestToAddProjectMembers to fetch.
     */
    orderBy?: RequestToAddProjectMemberOrderByWithRelationInput | RequestToAddProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestToAddProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestToAddProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestToAddProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestToAddProjectMembers
    **/
    _count?: true | RequestToAddProjectMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestToAddProjectMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestToAddProjectMemberMaxAggregateInputType
  }

  export type GetRequestToAddProjectMemberAggregateType<T extends RequestToAddProjectMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestToAddProjectMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestToAddProjectMember[P]>
      : GetScalarType<T[P], AggregateRequestToAddProjectMember[P]>
  }




  export type RequestToAddProjectMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestToAddProjectMemberWhereInput
    orderBy?: RequestToAddProjectMemberOrderByWithAggregationInput | RequestToAddProjectMemberOrderByWithAggregationInput[]
    by: RequestToAddProjectMemberScalarFieldEnum[] | RequestToAddProjectMemberScalarFieldEnum
    having?: RequestToAddProjectMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestToAddProjectMemberCountAggregateInputType | true
    _min?: RequestToAddProjectMemberMinAggregateInputType
    _max?: RequestToAddProjectMemberMaxAggregateInputType
  }

  export type RequestToAddProjectMemberGroupByOutputType = {
    id: string
    clientId: string | null
    projectId: string
    managerId: string
    createdAt: Date
    updatedAt: Date
    _count: RequestToAddProjectMemberCountAggregateOutputType | null
    _min: RequestToAddProjectMemberMinAggregateOutputType | null
    _max: RequestToAddProjectMemberMaxAggregateOutputType | null
  }

  type GetRequestToAddProjectMemberGroupByPayload<T extends RequestToAddProjectMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestToAddProjectMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestToAddProjectMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestToAddProjectMemberGroupByOutputType[P]>
            : GetScalarType<T[P], RequestToAddProjectMemberGroupByOutputType[P]>
        }
      >
    >


  export type RequestToAddProjectMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    projectId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requestToAddProjectMember"]>

  export type RequestToAddProjectMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    projectId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requestToAddProjectMember"]>

  export type RequestToAddProjectMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    projectId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requestToAddProjectMember"]>

  export type RequestToAddProjectMemberSelectScalar = {
    id?: boolean
    clientId?: boolean
    projectId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RequestToAddProjectMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "projectId" | "managerId" | "createdAt" | "updatedAt", ExtArgs["result"]["requestToAddProjectMember"]>
  export type RequestToAddProjectMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
  }
  export type RequestToAddProjectMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
  }
  export type RequestToAddProjectMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
  }

  export type $RequestToAddProjectMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RequestToAddProjectMember"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      manager: Prisma.$ManagerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string | null
      projectId: string
      managerId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["requestToAddProjectMember"]>
    composites: {}
  }

  type RequestToAddProjectMemberGetPayload<S extends boolean | null | undefined | RequestToAddProjectMemberDefaultArgs> = $Result.GetResult<Prisma.$RequestToAddProjectMemberPayload, S>

  type RequestToAddProjectMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequestToAddProjectMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequestToAddProjectMemberCountAggregateInputType | true
    }

  export interface RequestToAddProjectMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RequestToAddProjectMember'], meta: { name: 'RequestToAddProjectMember' } }
    /**
     * Find zero or one RequestToAddProjectMember that matches the filter.
     * @param {RequestToAddProjectMemberFindUniqueArgs} args - Arguments to find a RequestToAddProjectMember
     * @example
     * // Get one RequestToAddProjectMember
     * const requestToAddProjectMember = await prisma.requestToAddProjectMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequestToAddProjectMemberFindUniqueArgs>(args: SelectSubset<T, RequestToAddProjectMemberFindUniqueArgs<ExtArgs>>): Prisma__RequestToAddProjectMemberClient<$Result.GetResult<Prisma.$RequestToAddProjectMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RequestToAddProjectMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequestToAddProjectMemberFindUniqueOrThrowArgs} args - Arguments to find a RequestToAddProjectMember
     * @example
     * // Get one RequestToAddProjectMember
     * const requestToAddProjectMember = await prisma.requestToAddProjectMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequestToAddProjectMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, RequestToAddProjectMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequestToAddProjectMemberClient<$Result.GetResult<Prisma.$RequestToAddProjectMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestToAddProjectMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestToAddProjectMemberFindFirstArgs} args - Arguments to find a RequestToAddProjectMember
     * @example
     * // Get one RequestToAddProjectMember
     * const requestToAddProjectMember = await prisma.requestToAddProjectMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequestToAddProjectMemberFindFirstArgs>(args?: SelectSubset<T, RequestToAddProjectMemberFindFirstArgs<ExtArgs>>): Prisma__RequestToAddProjectMemberClient<$Result.GetResult<Prisma.$RequestToAddProjectMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestToAddProjectMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestToAddProjectMemberFindFirstOrThrowArgs} args - Arguments to find a RequestToAddProjectMember
     * @example
     * // Get one RequestToAddProjectMember
     * const requestToAddProjectMember = await prisma.requestToAddProjectMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequestToAddProjectMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, RequestToAddProjectMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequestToAddProjectMemberClient<$Result.GetResult<Prisma.$RequestToAddProjectMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RequestToAddProjectMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestToAddProjectMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestToAddProjectMembers
     * const requestToAddProjectMembers = await prisma.requestToAddProjectMember.findMany()
     * 
     * // Get first 10 RequestToAddProjectMembers
     * const requestToAddProjectMembers = await prisma.requestToAddProjectMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestToAddProjectMemberWithIdOnly = await prisma.requestToAddProjectMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequestToAddProjectMemberFindManyArgs>(args?: SelectSubset<T, RequestToAddProjectMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestToAddProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RequestToAddProjectMember.
     * @param {RequestToAddProjectMemberCreateArgs} args - Arguments to create a RequestToAddProjectMember.
     * @example
     * // Create one RequestToAddProjectMember
     * const RequestToAddProjectMember = await prisma.requestToAddProjectMember.create({
     *   data: {
     *     // ... data to create a RequestToAddProjectMember
     *   }
     * })
     * 
     */
    create<T extends RequestToAddProjectMemberCreateArgs>(args: SelectSubset<T, RequestToAddProjectMemberCreateArgs<ExtArgs>>): Prisma__RequestToAddProjectMemberClient<$Result.GetResult<Prisma.$RequestToAddProjectMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RequestToAddProjectMembers.
     * @param {RequestToAddProjectMemberCreateManyArgs} args - Arguments to create many RequestToAddProjectMembers.
     * @example
     * // Create many RequestToAddProjectMembers
     * const requestToAddProjectMember = await prisma.requestToAddProjectMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequestToAddProjectMemberCreateManyArgs>(args?: SelectSubset<T, RequestToAddProjectMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RequestToAddProjectMembers and returns the data saved in the database.
     * @param {RequestToAddProjectMemberCreateManyAndReturnArgs} args - Arguments to create many RequestToAddProjectMembers.
     * @example
     * // Create many RequestToAddProjectMembers
     * const requestToAddProjectMember = await prisma.requestToAddProjectMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RequestToAddProjectMembers and only return the `id`
     * const requestToAddProjectMemberWithIdOnly = await prisma.requestToAddProjectMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequestToAddProjectMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, RequestToAddProjectMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestToAddProjectMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RequestToAddProjectMember.
     * @param {RequestToAddProjectMemberDeleteArgs} args - Arguments to delete one RequestToAddProjectMember.
     * @example
     * // Delete one RequestToAddProjectMember
     * const RequestToAddProjectMember = await prisma.requestToAddProjectMember.delete({
     *   where: {
     *     // ... filter to delete one RequestToAddProjectMember
     *   }
     * })
     * 
     */
    delete<T extends RequestToAddProjectMemberDeleteArgs>(args: SelectSubset<T, RequestToAddProjectMemberDeleteArgs<ExtArgs>>): Prisma__RequestToAddProjectMemberClient<$Result.GetResult<Prisma.$RequestToAddProjectMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RequestToAddProjectMember.
     * @param {RequestToAddProjectMemberUpdateArgs} args - Arguments to update one RequestToAddProjectMember.
     * @example
     * // Update one RequestToAddProjectMember
     * const requestToAddProjectMember = await prisma.requestToAddProjectMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequestToAddProjectMemberUpdateArgs>(args: SelectSubset<T, RequestToAddProjectMemberUpdateArgs<ExtArgs>>): Prisma__RequestToAddProjectMemberClient<$Result.GetResult<Prisma.$RequestToAddProjectMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RequestToAddProjectMembers.
     * @param {RequestToAddProjectMemberDeleteManyArgs} args - Arguments to filter RequestToAddProjectMembers to delete.
     * @example
     * // Delete a few RequestToAddProjectMembers
     * const { count } = await prisma.requestToAddProjectMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequestToAddProjectMemberDeleteManyArgs>(args?: SelectSubset<T, RequestToAddProjectMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestToAddProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestToAddProjectMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestToAddProjectMembers
     * const requestToAddProjectMember = await prisma.requestToAddProjectMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequestToAddProjectMemberUpdateManyArgs>(args: SelectSubset<T, RequestToAddProjectMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestToAddProjectMembers and returns the data updated in the database.
     * @param {RequestToAddProjectMemberUpdateManyAndReturnArgs} args - Arguments to update many RequestToAddProjectMembers.
     * @example
     * // Update many RequestToAddProjectMembers
     * const requestToAddProjectMember = await prisma.requestToAddProjectMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RequestToAddProjectMembers and only return the `id`
     * const requestToAddProjectMemberWithIdOnly = await prisma.requestToAddProjectMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequestToAddProjectMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, RequestToAddProjectMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestToAddProjectMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RequestToAddProjectMember.
     * @param {RequestToAddProjectMemberUpsertArgs} args - Arguments to update or create a RequestToAddProjectMember.
     * @example
     * // Update or create a RequestToAddProjectMember
     * const requestToAddProjectMember = await prisma.requestToAddProjectMember.upsert({
     *   create: {
     *     // ... data to create a RequestToAddProjectMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestToAddProjectMember we want to update
     *   }
     * })
     */
    upsert<T extends RequestToAddProjectMemberUpsertArgs>(args: SelectSubset<T, RequestToAddProjectMemberUpsertArgs<ExtArgs>>): Prisma__RequestToAddProjectMemberClient<$Result.GetResult<Prisma.$RequestToAddProjectMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RequestToAddProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestToAddProjectMemberCountArgs} args - Arguments to filter RequestToAddProjectMembers to count.
     * @example
     * // Count the number of RequestToAddProjectMembers
     * const count = await prisma.requestToAddProjectMember.count({
     *   where: {
     *     // ... the filter for the RequestToAddProjectMembers we want to count
     *   }
     * })
    **/
    count<T extends RequestToAddProjectMemberCountArgs>(
      args?: Subset<T, RequestToAddProjectMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestToAddProjectMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestToAddProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestToAddProjectMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestToAddProjectMemberAggregateArgs>(args: Subset<T, RequestToAddProjectMemberAggregateArgs>): Prisma.PrismaPromise<GetRequestToAddProjectMemberAggregateType<T>>

    /**
     * Group by RequestToAddProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestToAddProjectMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestToAddProjectMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestToAddProjectMemberGroupByArgs['orderBy'] }
        : { orderBy?: RequestToAddProjectMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestToAddProjectMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestToAddProjectMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RequestToAddProjectMember model
   */
  readonly fields: RequestToAddProjectMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestToAddProjectMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequestToAddProjectMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    manager<T extends ManagerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ManagerDefaultArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RequestToAddProjectMember model
   */
  interface RequestToAddProjectMemberFieldRefs {
    readonly id: FieldRef<"RequestToAddProjectMember", 'String'>
    readonly clientId: FieldRef<"RequestToAddProjectMember", 'String'>
    readonly projectId: FieldRef<"RequestToAddProjectMember", 'String'>
    readonly managerId: FieldRef<"RequestToAddProjectMember", 'String'>
    readonly createdAt: FieldRef<"RequestToAddProjectMember", 'DateTime'>
    readonly updatedAt: FieldRef<"RequestToAddProjectMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RequestToAddProjectMember findUnique
   */
  export type RequestToAddProjectMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestToAddProjectMember
     */
    select?: RequestToAddProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestToAddProjectMember
     */
    omit?: RequestToAddProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestToAddProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which RequestToAddProjectMember to fetch.
     */
    where: RequestToAddProjectMemberWhereUniqueInput
  }

  /**
   * RequestToAddProjectMember findUniqueOrThrow
   */
  export type RequestToAddProjectMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestToAddProjectMember
     */
    select?: RequestToAddProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestToAddProjectMember
     */
    omit?: RequestToAddProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestToAddProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which RequestToAddProjectMember to fetch.
     */
    where: RequestToAddProjectMemberWhereUniqueInput
  }

  /**
   * RequestToAddProjectMember findFirst
   */
  export type RequestToAddProjectMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestToAddProjectMember
     */
    select?: RequestToAddProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestToAddProjectMember
     */
    omit?: RequestToAddProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestToAddProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which RequestToAddProjectMember to fetch.
     */
    where?: RequestToAddProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestToAddProjectMembers to fetch.
     */
    orderBy?: RequestToAddProjectMemberOrderByWithRelationInput | RequestToAddProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestToAddProjectMembers.
     */
    cursor?: RequestToAddProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestToAddProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestToAddProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestToAddProjectMembers.
     */
    distinct?: RequestToAddProjectMemberScalarFieldEnum | RequestToAddProjectMemberScalarFieldEnum[]
  }

  /**
   * RequestToAddProjectMember findFirstOrThrow
   */
  export type RequestToAddProjectMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestToAddProjectMember
     */
    select?: RequestToAddProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestToAddProjectMember
     */
    omit?: RequestToAddProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestToAddProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which RequestToAddProjectMember to fetch.
     */
    where?: RequestToAddProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestToAddProjectMembers to fetch.
     */
    orderBy?: RequestToAddProjectMemberOrderByWithRelationInput | RequestToAddProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestToAddProjectMembers.
     */
    cursor?: RequestToAddProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestToAddProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestToAddProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestToAddProjectMembers.
     */
    distinct?: RequestToAddProjectMemberScalarFieldEnum | RequestToAddProjectMemberScalarFieldEnum[]
  }

  /**
   * RequestToAddProjectMember findMany
   */
  export type RequestToAddProjectMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestToAddProjectMember
     */
    select?: RequestToAddProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestToAddProjectMember
     */
    omit?: RequestToAddProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestToAddProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which RequestToAddProjectMembers to fetch.
     */
    where?: RequestToAddProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestToAddProjectMembers to fetch.
     */
    orderBy?: RequestToAddProjectMemberOrderByWithRelationInput | RequestToAddProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestToAddProjectMembers.
     */
    cursor?: RequestToAddProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestToAddProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestToAddProjectMembers.
     */
    skip?: number
    distinct?: RequestToAddProjectMemberScalarFieldEnum | RequestToAddProjectMemberScalarFieldEnum[]
  }

  /**
   * RequestToAddProjectMember create
   */
  export type RequestToAddProjectMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestToAddProjectMember
     */
    select?: RequestToAddProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestToAddProjectMember
     */
    omit?: RequestToAddProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestToAddProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a RequestToAddProjectMember.
     */
    data: XOR<RequestToAddProjectMemberCreateInput, RequestToAddProjectMemberUncheckedCreateInput>
  }

  /**
   * RequestToAddProjectMember createMany
   */
  export type RequestToAddProjectMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RequestToAddProjectMembers.
     */
    data: RequestToAddProjectMemberCreateManyInput | RequestToAddProjectMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RequestToAddProjectMember createManyAndReturn
   */
  export type RequestToAddProjectMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestToAddProjectMember
     */
    select?: RequestToAddProjectMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestToAddProjectMember
     */
    omit?: RequestToAddProjectMemberOmit<ExtArgs> | null
    /**
     * The data used to create many RequestToAddProjectMembers.
     */
    data: RequestToAddProjectMemberCreateManyInput | RequestToAddProjectMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestToAddProjectMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestToAddProjectMember update
   */
  export type RequestToAddProjectMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestToAddProjectMember
     */
    select?: RequestToAddProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestToAddProjectMember
     */
    omit?: RequestToAddProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestToAddProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a RequestToAddProjectMember.
     */
    data: XOR<RequestToAddProjectMemberUpdateInput, RequestToAddProjectMemberUncheckedUpdateInput>
    /**
     * Choose, which RequestToAddProjectMember to update.
     */
    where: RequestToAddProjectMemberWhereUniqueInput
  }

  /**
   * RequestToAddProjectMember updateMany
   */
  export type RequestToAddProjectMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RequestToAddProjectMembers.
     */
    data: XOR<RequestToAddProjectMemberUpdateManyMutationInput, RequestToAddProjectMemberUncheckedUpdateManyInput>
    /**
     * Filter which RequestToAddProjectMembers to update
     */
    where?: RequestToAddProjectMemberWhereInput
    /**
     * Limit how many RequestToAddProjectMembers to update.
     */
    limit?: number
  }

  /**
   * RequestToAddProjectMember updateManyAndReturn
   */
  export type RequestToAddProjectMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestToAddProjectMember
     */
    select?: RequestToAddProjectMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequestToAddProjectMember
     */
    omit?: RequestToAddProjectMemberOmit<ExtArgs> | null
    /**
     * The data used to update RequestToAddProjectMembers.
     */
    data: XOR<RequestToAddProjectMemberUpdateManyMutationInput, RequestToAddProjectMemberUncheckedUpdateManyInput>
    /**
     * Filter which RequestToAddProjectMembers to update
     */
    where?: RequestToAddProjectMemberWhereInput
    /**
     * Limit how many RequestToAddProjectMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestToAddProjectMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequestToAddProjectMember upsert
   */
  export type RequestToAddProjectMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestToAddProjectMember
     */
    select?: RequestToAddProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestToAddProjectMember
     */
    omit?: RequestToAddProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestToAddProjectMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the RequestToAddProjectMember to update in case it exists.
     */
    where: RequestToAddProjectMemberWhereUniqueInput
    /**
     * In case the RequestToAddProjectMember found by the `where` argument doesn't exist, create a new RequestToAddProjectMember with this data.
     */
    create: XOR<RequestToAddProjectMemberCreateInput, RequestToAddProjectMemberUncheckedCreateInput>
    /**
     * In case the RequestToAddProjectMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestToAddProjectMemberUpdateInput, RequestToAddProjectMemberUncheckedUpdateInput>
  }

  /**
   * RequestToAddProjectMember delete
   */
  export type RequestToAddProjectMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestToAddProjectMember
     */
    select?: RequestToAddProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestToAddProjectMember
     */
    omit?: RequestToAddProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestToAddProjectMemberInclude<ExtArgs> | null
    /**
     * Filter which RequestToAddProjectMember to delete.
     */
    where: RequestToAddProjectMemberWhereUniqueInput
  }

  /**
   * RequestToAddProjectMember deleteMany
   */
  export type RequestToAddProjectMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestToAddProjectMembers to delete
     */
    where?: RequestToAddProjectMemberWhereInput
    /**
     * Limit how many RequestToAddProjectMembers to delete.
     */
    limit?: number
  }

  /**
   * RequestToAddProjectMember without action
   */
  export type RequestToAddProjectMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestToAddProjectMember
     */
    select?: RequestToAddProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestToAddProjectMember
     */
    omit?: RequestToAddProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestToAddProjectMemberInclude<ExtArgs> | null
  }


  /**
   * Model Viewer
   */

  export type AggregateViewer = {
    _count: ViewerCountAggregateOutputType | null
    _min: ViewerMinAggregateOutputType | null
    _max: ViewerMaxAggregateOutputType | null
  }

  export type ViewerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ViewerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ViewerCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ViewerMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ViewerMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ViewerCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ViewerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Viewer to aggregate.
     */
    where?: ViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Viewers to fetch.
     */
    orderBy?: ViewerOrderByWithRelationInput | ViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Viewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Viewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Viewers
    **/
    _count?: true | ViewerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViewerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViewerMaxAggregateInputType
  }

  export type GetViewerAggregateType<T extends ViewerAggregateArgs> = {
        [P in keyof T & keyof AggregateViewer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViewer[P]>
      : GetScalarType<T[P], AggregateViewer[P]>
  }




  export type ViewerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewerWhereInput
    orderBy?: ViewerOrderByWithAggregationInput | ViewerOrderByWithAggregationInput[]
    by: ViewerScalarFieldEnum[] | ViewerScalarFieldEnum
    having?: ViewerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViewerCountAggregateInputType | true
    _min?: ViewerMinAggregateInputType
    _max?: ViewerMaxAggregateInputType
  }

  export type ViewerGroupByOutputType = {
    id: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: ViewerCountAggregateOutputType | null
    _min: ViewerMinAggregateOutputType | null
    _max: ViewerMaxAggregateOutputType | null
  }

  type GetViewerGroupByPayload<T extends ViewerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViewerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViewerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViewerGroupByOutputType[P]>
            : GetScalarType<T[P], ViewerGroupByOutputType[P]>
        }
      >
    >


  export type ViewerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viewer"]>

  export type ViewerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viewer"]>

  export type ViewerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viewer"]>

  export type ViewerSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ViewerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["viewer"]>
  export type ViewerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ViewerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ViewerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ViewerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Viewer"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["viewer"]>
    composites: {}
  }

  type ViewerGetPayload<S extends boolean | null | undefined | ViewerDefaultArgs> = $Result.GetResult<Prisma.$ViewerPayload, S>

  type ViewerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ViewerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ViewerCountAggregateInputType | true
    }

  export interface ViewerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Viewer'], meta: { name: 'Viewer' } }
    /**
     * Find zero or one Viewer that matches the filter.
     * @param {ViewerFindUniqueArgs} args - Arguments to find a Viewer
     * @example
     * // Get one Viewer
     * const viewer = await prisma.viewer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViewerFindUniqueArgs>(args: SelectSubset<T, ViewerFindUniqueArgs<ExtArgs>>): Prisma__ViewerClient<$Result.GetResult<Prisma.$ViewerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Viewer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ViewerFindUniqueOrThrowArgs} args - Arguments to find a Viewer
     * @example
     * // Get one Viewer
     * const viewer = await prisma.viewer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViewerFindUniqueOrThrowArgs>(args: SelectSubset<T, ViewerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViewerClient<$Result.GetResult<Prisma.$ViewerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Viewer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewerFindFirstArgs} args - Arguments to find a Viewer
     * @example
     * // Get one Viewer
     * const viewer = await prisma.viewer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViewerFindFirstArgs>(args?: SelectSubset<T, ViewerFindFirstArgs<ExtArgs>>): Prisma__ViewerClient<$Result.GetResult<Prisma.$ViewerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Viewer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewerFindFirstOrThrowArgs} args - Arguments to find a Viewer
     * @example
     * // Get one Viewer
     * const viewer = await prisma.viewer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViewerFindFirstOrThrowArgs>(args?: SelectSubset<T, ViewerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ViewerClient<$Result.GetResult<Prisma.$ViewerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Viewers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Viewers
     * const viewers = await prisma.viewer.findMany()
     * 
     * // Get first 10 Viewers
     * const viewers = await prisma.viewer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viewerWithIdOnly = await prisma.viewer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ViewerFindManyArgs>(args?: SelectSubset<T, ViewerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Viewer.
     * @param {ViewerCreateArgs} args - Arguments to create a Viewer.
     * @example
     * // Create one Viewer
     * const Viewer = await prisma.viewer.create({
     *   data: {
     *     // ... data to create a Viewer
     *   }
     * })
     * 
     */
    create<T extends ViewerCreateArgs>(args: SelectSubset<T, ViewerCreateArgs<ExtArgs>>): Prisma__ViewerClient<$Result.GetResult<Prisma.$ViewerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Viewers.
     * @param {ViewerCreateManyArgs} args - Arguments to create many Viewers.
     * @example
     * // Create many Viewers
     * const viewer = await prisma.viewer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViewerCreateManyArgs>(args?: SelectSubset<T, ViewerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Viewers and returns the data saved in the database.
     * @param {ViewerCreateManyAndReturnArgs} args - Arguments to create many Viewers.
     * @example
     * // Create many Viewers
     * const viewer = await prisma.viewer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Viewers and only return the `id`
     * const viewerWithIdOnly = await prisma.viewer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ViewerCreateManyAndReturnArgs>(args?: SelectSubset<T, ViewerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Viewer.
     * @param {ViewerDeleteArgs} args - Arguments to delete one Viewer.
     * @example
     * // Delete one Viewer
     * const Viewer = await prisma.viewer.delete({
     *   where: {
     *     // ... filter to delete one Viewer
     *   }
     * })
     * 
     */
    delete<T extends ViewerDeleteArgs>(args: SelectSubset<T, ViewerDeleteArgs<ExtArgs>>): Prisma__ViewerClient<$Result.GetResult<Prisma.$ViewerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Viewer.
     * @param {ViewerUpdateArgs} args - Arguments to update one Viewer.
     * @example
     * // Update one Viewer
     * const viewer = await prisma.viewer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViewerUpdateArgs>(args: SelectSubset<T, ViewerUpdateArgs<ExtArgs>>): Prisma__ViewerClient<$Result.GetResult<Prisma.$ViewerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Viewers.
     * @param {ViewerDeleteManyArgs} args - Arguments to filter Viewers to delete.
     * @example
     * // Delete a few Viewers
     * const { count } = await prisma.viewer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViewerDeleteManyArgs>(args?: SelectSubset<T, ViewerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Viewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Viewers
     * const viewer = await prisma.viewer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViewerUpdateManyArgs>(args: SelectSubset<T, ViewerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Viewers and returns the data updated in the database.
     * @param {ViewerUpdateManyAndReturnArgs} args - Arguments to update many Viewers.
     * @example
     * // Update many Viewers
     * const viewer = await prisma.viewer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Viewers and only return the `id`
     * const viewerWithIdOnly = await prisma.viewer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ViewerUpdateManyAndReturnArgs>(args: SelectSubset<T, ViewerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Viewer.
     * @param {ViewerUpsertArgs} args - Arguments to update or create a Viewer.
     * @example
     * // Update or create a Viewer
     * const viewer = await prisma.viewer.upsert({
     *   create: {
     *     // ... data to create a Viewer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Viewer we want to update
     *   }
     * })
     */
    upsert<T extends ViewerUpsertArgs>(args: SelectSubset<T, ViewerUpsertArgs<ExtArgs>>): Prisma__ViewerClient<$Result.GetResult<Prisma.$ViewerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Viewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewerCountArgs} args - Arguments to filter Viewers to count.
     * @example
     * // Count the number of Viewers
     * const count = await prisma.viewer.count({
     *   where: {
     *     // ... the filter for the Viewers we want to count
     *   }
     * })
    **/
    count<T extends ViewerCountArgs>(
      args?: Subset<T, ViewerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViewerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Viewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViewerAggregateArgs>(args: Subset<T, ViewerAggregateArgs>): Prisma.PrismaPromise<GetViewerAggregateType<T>>

    /**
     * Group by Viewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViewerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViewerGroupByArgs['orderBy'] }
        : { orderBy?: ViewerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViewerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViewerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Viewer model
   */
  readonly fields: ViewerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Viewer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViewerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Viewer model
   */
  interface ViewerFieldRefs {
    readonly id: FieldRef<"Viewer", 'String'>
    readonly userId: FieldRef<"Viewer", 'String'>
    readonly createdAt: FieldRef<"Viewer", 'DateTime'>
    readonly updatedAt: FieldRef<"Viewer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Viewer findUnique
   */
  export type ViewerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viewer
     */
    select?: ViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Viewer
     */
    omit?: ViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerInclude<ExtArgs> | null
    /**
     * Filter, which Viewer to fetch.
     */
    where: ViewerWhereUniqueInput
  }

  /**
   * Viewer findUniqueOrThrow
   */
  export type ViewerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viewer
     */
    select?: ViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Viewer
     */
    omit?: ViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerInclude<ExtArgs> | null
    /**
     * Filter, which Viewer to fetch.
     */
    where: ViewerWhereUniqueInput
  }

  /**
   * Viewer findFirst
   */
  export type ViewerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viewer
     */
    select?: ViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Viewer
     */
    omit?: ViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerInclude<ExtArgs> | null
    /**
     * Filter, which Viewer to fetch.
     */
    where?: ViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Viewers to fetch.
     */
    orderBy?: ViewerOrderByWithRelationInput | ViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Viewers.
     */
    cursor?: ViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Viewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Viewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Viewers.
     */
    distinct?: ViewerScalarFieldEnum | ViewerScalarFieldEnum[]
  }

  /**
   * Viewer findFirstOrThrow
   */
  export type ViewerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viewer
     */
    select?: ViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Viewer
     */
    omit?: ViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerInclude<ExtArgs> | null
    /**
     * Filter, which Viewer to fetch.
     */
    where?: ViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Viewers to fetch.
     */
    orderBy?: ViewerOrderByWithRelationInput | ViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Viewers.
     */
    cursor?: ViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Viewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Viewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Viewers.
     */
    distinct?: ViewerScalarFieldEnum | ViewerScalarFieldEnum[]
  }

  /**
   * Viewer findMany
   */
  export type ViewerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viewer
     */
    select?: ViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Viewer
     */
    omit?: ViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerInclude<ExtArgs> | null
    /**
     * Filter, which Viewers to fetch.
     */
    where?: ViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Viewers to fetch.
     */
    orderBy?: ViewerOrderByWithRelationInput | ViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Viewers.
     */
    cursor?: ViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Viewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Viewers.
     */
    skip?: number
    distinct?: ViewerScalarFieldEnum | ViewerScalarFieldEnum[]
  }

  /**
   * Viewer create
   */
  export type ViewerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viewer
     */
    select?: ViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Viewer
     */
    omit?: ViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerInclude<ExtArgs> | null
    /**
     * The data needed to create a Viewer.
     */
    data: XOR<ViewerCreateInput, ViewerUncheckedCreateInput>
  }

  /**
   * Viewer createMany
   */
  export type ViewerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Viewers.
     */
    data: ViewerCreateManyInput | ViewerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Viewer createManyAndReturn
   */
  export type ViewerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viewer
     */
    select?: ViewerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Viewer
     */
    omit?: ViewerOmit<ExtArgs> | null
    /**
     * The data used to create many Viewers.
     */
    data: ViewerCreateManyInput | ViewerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Viewer update
   */
  export type ViewerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viewer
     */
    select?: ViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Viewer
     */
    omit?: ViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerInclude<ExtArgs> | null
    /**
     * The data needed to update a Viewer.
     */
    data: XOR<ViewerUpdateInput, ViewerUncheckedUpdateInput>
    /**
     * Choose, which Viewer to update.
     */
    where: ViewerWhereUniqueInput
  }

  /**
   * Viewer updateMany
   */
  export type ViewerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Viewers.
     */
    data: XOR<ViewerUpdateManyMutationInput, ViewerUncheckedUpdateManyInput>
    /**
     * Filter which Viewers to update
     */
    where?: ViewerWhereInput
    /**
     * Limit how many Viewers to update.
     */
    limit?: number
  }

  /**
   * Viewer updateManyAndReturn
   */
  export type ViewerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viewer
     */
    select?: ViewerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Viewer
     */
    omit?: ViewerOmit<ExtArgs> | null
    /**
     * The data used to update Viewers.
     */
    data: XOR<ViewerUpdateManyMutationInput, ViewerUncheckedUpdateManyInput>
    /**
     * Filter which Viewers to update
     */
    where?: ViewerWhereInput
    /**
     * Limit how many Viewers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Viewer upsert
   */
  export type ViewerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viewer
     */
    select?: ViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Viewer
     */
    omit?: ViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerInclude<ExtArgs> | null
    /**
     * The filter to search for the Viewer to update in case it exists.
     */
    where: ViewerWhereUniqueInput
    /**
     * In case the Viewer found by the `where` argument doesn't exist, create a new Viewer with this data.
     */
    create: XOR<ViewerCreateInput, ViewerUncheckedCreateInput>
    /**
     * In case the Viewer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViewerUpdateInput, ViewerUncheckedUpdateInput>
  }

  /**
   * Viewer delete
   */
  export type ViewerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viewer
     */
    select?: ViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Viewer
     */
    omit?: ViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerInclude<ExtArgs> | null
    /**
     * Filter which Viewer to delete.
     */
    where: ViewerWhereUniqueInput
  }

  /**
   * Viewer deleteMany
   */
  export type ViewerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Viewers to delete
     */
    where?: ViewerWhereInput
    /**
     * Limit how many Viewers to delete.
     */
    limit?: number
  }

  /**
   * Viewer without action
   */
  export type ViewerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Viewer
     */
    select?: ViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Viewer
     */
    omit?: ViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    timestamp: 'timestamp',
    description: 'description',
    projectId: 'projectId',
    ipAddress: 'ipAddress',
    actionType: 'actionType',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    email: 'email',
    contactPersonName: 'contactPersonName',
    clientLogo: 'clientLogo',
    favicon: 'favicon',
    primaryColor: 'primaryColor',
    secondaryColor: 'secondaryColor',
    footerText: 'footerText',
    supportMail: 'supportMail',
    subdomain: 'subdomain',
    serverLocation: 'serverLocation',
    category: 'category',
    onboarding: 'onboarding',
    welcomeDashboard: 'welcomeDashboard',
    chartList: 'chartList',
    storage: 'storage',
    threshold: 'threshold',
    archiveAfter: 'archiveAfter',
    userWarning: 'userWarning',
    adminNote: 'adminNote',
    trialPeriod: 'trialPeriod',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    description: 'description',
    joinedDate: 'joinedDate',
    skills: 'skills'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const OtpVerificationScalarFieldEnum: {
    id: 'id',
    email: 'email',
    otp: 'otp',
    expiresAt: 'expiresAt',
    verified: 'verified',
    createdAt: 'createdAt'
  };

  export type OtpVerificationScalarFieldEnum = (typeof OtpVerificationScalarFieldEnum)[keyof typeof OtpVerificationScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    transactionId: 'transactionId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ManagerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    skills: 'skills',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    description: 'description',
    joinedDate: 'joinedDate'
  };

  export type ManagerScalarFieldEnum = (typeof ManagerScalarFieldEnum)[keyof typeof ManagerScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverIds: 'receiverIds',
    context: 'context',
    type: 'type',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NotificationProvisionScalarFieldEnum: {
    userId: 'userId',
    notificationId: 'notificationId'
  };

  export type NotificationProvisionScalarFieldEnum = (typeof NotificationProvisionScalarFieldEnum)[keyof typeof NotificationProvisionScalarFieldEnum]


  export const NotificationPermissionEmployeeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    returnProject: 'returnProject',
    assignNewProject: 'assignNewProject',
    projectPublish: 'projectPublish',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationPermissionEmployeeScalarFieldEnum = (typeof NotificationPermissionEmployeeScalarFieldEnum)[keyof typeof NotificationPermissionEmployeeScalarFieldEnum]


  export const NotificationPermissionManagerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    fileImportByEmployees: 'fileImportByEmployees',
    weeklySummary: 'weeklySummary',
    createNewProject: 'createNewProject',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationPermissionManagerScalarFieldEnum = (typeof NotificationPermissionManagerScalarFieldEnum)[keyof typeof NotificationPermissionManagerScalarFieldEnum]


  export const NotificationPermissionClientScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    onProjectApproval: 'onProjectApproval',
    onProjectRejection: 'onProjectRejection',
    fileImportByEmployees: 'fileImportByEmployees',
    weeklySummary: 'weeklySummary',
    storageLimit: 'storageLimit',
    billPayment: 'billPayment',
    overdueProject: 'overdueProject',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationPermissionClientScalarFieldEnum = (typeof NotificationPermissionClientScalarFieldEnum)[keyof typeof NotificationPermissionClientScalarFieldEnum]


  export const NotificationPermissionSupporterScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    assignNewProject: 'assignNewProject',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationPermissionSupporterScalarFieldEnum = (typeof NotificationPermissionSupporterScalarFieldEnum)[keyof typeof NotificationPermissionSupporterScalarFieldEnum]


  export const NotificationPermissionAdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    storageLimit: 'storageLimit',
    receivedPayment: 'receivedPayment',
    createClient: 'createClient',
    createTicket: 'createTicket',
    paymentCycleChange: 'paymentCycleChange',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationPermissionAdminScalarFieldEnum = (typeof NotificationPermissionAdminScalarFieldEnum)[keyof typeof NotificationPermissionAdminScalarFieldEnum]


  export const NotificationPermissionSuperAdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    storageLimit: 'storageLimit',
    receivedPayment: 'receivedPayment',
    createClient: 'createClient',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationPermissionSuperAdminScalarFieldEnum = (typeof NotificationPermissionSuperAdminScalarFieldEnum)[keyof typeof NotificationPermissionSuperAdminScalarFieldEnum]


  export const ProgramScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    programName: 'programName',
    datetime: 'datetime',
    programDescription: 'programDescription',
    priority: 'priority',
    deadline: 'deadline',
    progress: 'progress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProgramScalarFieldEnum = (typeof ProgramScalarFieldEnum)[keyof typeof ProgramScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    programId: 'programId',
    name: 'name',
    uploadbeforeday: 'uploadbeforeday',
    uploadCycle: 'uploadCycle',
    description: 'description',
    dataReceivedTime: 'dataReceivedTime',
    beforeSubmitData: 'beforeSubmitData',
    weakuploadData: 'weakuploadData',
    monthlyuploadData: 'monthlyuploadData',
    status: 'status',
    priority: 'priority',
    deadline: 'deadline',
    managerId: 'managerId',
    startDate: 'startDate',
    progress: 'progress',
    chartList: 'chartList',
    estimatedCompletedDate: 'estimatedCompletedDate',
    currentRate: 'currentRate',
    budget: 'budget',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    latitude: 'latitude',
    longitude: 'longitude'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectEmployeeScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    employeeId: 'employeeId',
    assignedAt: 'assignedAt'
  };

  export type ProjectEmployeeScalarFieldEnum = (typeof ProjectEmployeeScalarFieldEnum)[keyof typeof ProjectEmployeeScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    taskAssignId: 'taskAssignId',
    status: 'status',
    managerId: 'managerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const SheetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SheetScalarFieldEnum = (typeof SheetScalarFieldEnum)[keyof typeof SheetScalarFieldEnum]


  export const SubmissionReturnScalarFieldEnum: {
    id: 'id',
    submittedId: 'submittedId',
    returnedAt: 'returnedAt'
  };

  export type SubmissionReturnScalarFieldEnum = (typeof SubmissionReturnScalarFieldEnum)[keyof typeof SubmissionReturnScalarFieldEnum]


  export const SubmittedScalarFieldEnum: {
    id: 'id',
    information: 'information',
    submission: 'submission',
    status: 'status',
    employeeId: 'employeeId',
    projectId: 'projectId',
    sheetId: 'sheetId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubmittedScalarFieldEnum = (typeof SubmittedScalarFieldEnum)[keyof typeof SubmittedScalarFieldEnum]


  export const SuperAdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    clientLogo: 'clientLogo',
    favicon: 'favicon',
    primaryColor: 'primaryColor',
    secondaryColor: 'secondaryColor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SuperAdminScalarFieldEnum = (typeof SuperAdminScalarFieldEnum)[keyof typeof SuperAdminScalarFieldEnum]


  export const SupporterScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    supporterRole: 'supporterRole',
    skills: 'skills',
    workload: 'workload',
    workItems: 'workItems',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupporterScalarFieldEnum = (typeof SupporterScalarFieldEnum)[keyof typeof SupporterScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    status: 'status',
    name: 'name',
    projectId: 'projectId',
    progress: 'progress',
    dueDate: 'dueDate',
    assignedTo: 'assignedTo',
    assigneeType: 'assigneeType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const TicketScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    supporterIds: 'supporterIds',
    adminIds: 'adminIds',
    companyName: 'companyName',
    subject: 'subject',
    status: 'status',
    priority: 'priority',
    issue: 'issue',
    adminNote: 'adminNote',
    attachFile: 'attachFile',
    issueType: 'issueType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    phoneNumber: 'phoneNumber',
    password: 'password',
    name: 'name',
    role: 'role',
    profileImage: 'profileImage',
    language: 'language',
    timezone: 'timezone',
    verification2FA: 'verification2FA',
    status: 'status',
    lastActive: 'lastActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userStatus: 'userStatus'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const TagScalarFieldEnum: {
    clientId: 'clientId',
    tags: 'tags',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const ReferredPersonScalarFieldEnum: {
    id: 'id',
    name: 'name',
    userId: 'userId',
    email: 'email',
    phoneNumber: 'phoneNumber',
    aboutThere: 'aboutThere',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReferredPersonScalarFieldEnum = (typeof ReferredPersonScalarFieldEnum)[keyof typeof ReferredPersonScalarFieldEnum]


  export const RequestToAddProjectMemberScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    projectId: 'projectId',
    managerId: 'managerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RequestToAddProjectMemberScalarFieldEnum = (typeof RequestToAddProjectMemberScalarFieldEnum)[keyof typeof RequestToAddProjectMemberScalarFieldEnum]


  export const ViewerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ViewerScalarFieldEnum = (typeof ViewerScalarFieldEnum)[keyof typeof ViewerScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ActivityActionType'
   */
  export type EnumActivityActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityActionType'>
    


  /**
   * Reference to a field of type 'ActivityActionType[]'
   */
  export type ListEnumActivityActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityActionType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'IndustryCategory'
   */
  export type EnumIndustryCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IndustryCategory'>
    


  /**
   * Reference to a field of type 'IndustryCategory[]'
   */
  export type ListEnumIndustryCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IndustryCategory[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ProjectCycle'
   */
  export type EnumProjectCycleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectCycle'>
    


  /**
   * Reference to a field of type 'ProjectCycle[]'
   */
  export type ListEnumProjectCycleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectCycle[]'>
    


  /**
   * Reference to a field of type 'ProjectStatus'
   */
  export type EnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus'>
    


  /**
   * Reference to a field of type 'ProjectStatus[]'
   */
  export type ListEnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'SubmittedStatus'
   */
  export type EnumSubmittedStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubmittedStatus'>
    


  /**
   * Reference to a field of type 'SubmittedStatus[]'
   */
  export type ListEnumSubmittedStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubmittedStatus[]'>
    


  /**
   * Reference to a field of type 'SupporterRole'
   */
  export type EnumSupporterRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupporterRole'>
    


  /**
   * Reference to a field of type 'SupporterRole[]'
   */
  export type ListEnumSupporterRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupporterRole[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    


  /**
   * Reference to a field of type 'TicketStatus'
   */
  export type EnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus'>
    


  /**
   * Reference to a field of type 'TicketStatus[]'
   */
  export type ListEnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus[]'>
    


  /**
   * Reference to a field of type 'IssueType'
   */
  export type EnumIssueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IssueType'>
    


  /**
   * Reference to a field of type 'IssueType[]'
   */
  export type ListEnumIssueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IssueType[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Language'
   */
  export type EnumLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Language'>
    


  /**
   * Reference to a field of type 'Language[]'
   */
  export type ListEnumLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Language[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    userId?: StringFilter<"Activity"> | string
    timestamp?: DateTimeFilter<"Activity"> | Date | string
    description?: StringFilter<"Activity"> | string
    projectId?: StringFilter<"Activity"> | string
    ipAddress?: StringNullableFilter<"Activity"> | string | null
    actionType?: EnumActivityActionTypeFilter<"Activity"> | $Enums.ActivityActionType
    metadata?: JsonNullableFilter<"Activity">
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    projectId?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    actionType?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    userId?: StringFilter<"Activity"> | string
    timestamp?: DateTimeFilter<"Activity"> | Date | string
    description?: StringFilter<"Activity"> | string
    projectId?: StringFilter<"Activity"> | string
    ipAddress?: StringNullableFilter<"Activity"> | string | null
    actionType?: EnumActivityActionTypeFilter<"Activity"> | $Enums.ActivityActionType
    metadata?: JsonNullableFilter<"Activity">
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    projectId?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    actionType?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    userId?: StringWithAggregatesFilter<"Activity"> | string
    timestamp?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    description?: StringWithAggregatesFilter<"Activity"> | string
    projectId?: StringWithAggregatesFilter<"Activity"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    actionType?: EnumActivityActionTypeWithAggregatesFilter<"Activity"> | $Enums.ActivityActionType
    metadata?: JsonNullableWithAggregatesFilter<"Activity">
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    userId?: StringFilter<"Client"> | string
    email?: StringFilter<"Client"> | string
    contactPersonName?: StringNullableFilter<"Client"> | string | null
    clientLogo?: StringNullableFilter<"Client"> | string | null
    favicon?: StringNullableFilter<"Client"> | string | null
    primaryColor?: StringNullableFilter<"Client"> | string | null
    secondaryColor?: StringNullableFilter<"Client"> | string | null
    footerText?: StringNullableFilter<"Client"> | string | null
    supportMail?: StringNullableFilter<"Client"> | string | null
    subdomain?: StringNullableFilter<"Client"> | string | null
    serverLocation?: StringNullableFilter<"Client"> | string | null
    category?: EnumIndustryCategoryFilter<"Client"> | $Enums.IndustryCategory
    onboarding?: BoolFilter<"Client"> | boolean
    welcomeDashboard?: BoolFilter<"Client"> | boolean
    chartList?: StringNullableListFilter<"Client">
    storage?: StringNullableFilter<"Client"> | string | null
    threshold?: IntNullableFilter<"Client"> | number | null
    archiveAfter?: IntNullableFilter<"Client"> | number | null
    userWarning?: BoolFilter<"Client"> | boolean
    adminNote?: StringNullableFilter<"Client"> | string | null
    trialPeriod?: IntNullableFilter<"Client"> | number | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    referredPersons?: ReferredPersonListRelationFilter
    tickets?: TicketListRelationFilter
    programs?: ProgramListRelationFilter
    tags?: XOR<TagNullableScalarRelationFilter, TagWhereInput> | null
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    contactPersonName?: SortOrderInput | SortOrder
    clientLogo?: SortOrderInput | SortOrder
    favicon?: SortOrderInput | SortOrder
    primaryColor?: SortOrderInput | SortOrder
    secondaryColor?: SortOrderInput | SortOrder
    footerText?: SortOrderInput | SortOrder
    supportMail?: SortOrderInput | SortOrder
    subdomain?: SortOrderInput | SortOrder
    serverLocation?: SortOrderInput | SortOrder
    category?: SortOrder
    onboarding?: SortOrder
    welcomeDashboard?: SortOrder
    chartList?: SortOrder
    storage?: SortOrderInput | SortOrder
    threshold?: SortOrderInput | SortOrder
    archiveAfter?: SortOrderInput | SortOrder
    userWarning?: SortOrder
    adminNote?: SortOrderInput | SortOrder
    trialPeriod?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    referredPersons?: ReferredPersonOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
    programs?: ProgramOrderByRelationAggregateInput
    tags?: TagOrderByWithRelationInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    email?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    contactPersonName?: StringNullableFilter<"Client"> | string | null
    clientLogo?: StringNullableFilter<"Client"> | string | null
    favicon?: StringNullableFilter<"Client"> | string | null
    primaryColor?: StringNullableFilter<"Client"> | string | null
    secondaryColor?: StringNullableFilter<"Client"> | string | null
    footerText?: StringNullableFilter<"Client"> | string | null
    supportMail?: StringNullableFilter<"Client"> | string | null
    subdomain?: StringNullableFilter<"Client"> | string | null
    serverLocation?: StringNullableFilter<"Client"> | string | null
    category?: EnumIndustryCategoryFilter<"Client"> | $Enums.IndustryCategory
    onboarding?: BoolFilter<"Client"> | boolean
    welcomeDashboard?: BoolFilter<"Client"> | boolean
    chartList?: StringNullableListFilter<"Client">
    storage?: StringNullableFilter<"Client"> | string | null
    threshold?: IntNullableFilter<"Client"> | number | null
    archiveAfter?: IntNullableFilter<"Client"> | number | null
    userWarning?: BoolFilter<"Client"> | boolean
    adminNote?: StringNullableFilter<"Client"> | string | null
    trialPeriod?: IntNullableFilter<"Client"> | number | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    referredPersons?: ReferredPersonListRelationFilter
    tickets?: TicketListRelationFilter
    programs?: ProgramListRelationFilter
    tags?: XOR<TagNullableScalarRelationFilter, TagWhereInput> | null
  }, "id" | "userId" | "email">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    contactPersonName?: SortOrderInput | SortOrder
    clientLogo?: SortOrderInput | SortOrder
    favicon?: SortOrderInput | SortOrder
    primaryColor?: SortOrderInput | SortOrder
    secondaryColor?: SortOrderInput | SortOrder
    footerText?: SortOrderInput | SortOrder
    supportMail?: SortOrderInput | SortOrder
    subdomain?: SortOrderInput | SortOrder
    serverLocation?: SortOrderInput | SortOrder
    category?: SortOrder
    onboarding?: SortOrder
    welcomeDashboard?: SortOrder
    chartList?: SortOrder
    storage?: SortOrderInput | SortOrder
    threshold?: SortOrderInput | SortOrder
    archiveAfter?: SortOrderInput | SortOrder
    userWarning?: SortOrder
    adminNote?: SortOrderInput | SortOrder
    trialPeriod?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _avg?: ClientAvgOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
    _sum?: ClientSumOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    userId?: StringWithAggregatesFilter<"Client"> | string
    email?: StringWithAggregatesFilter<"Client"> | string
    contactPersonName?: StringNullableWithAggregatesFilter<"Client"> | string | null
    clientLogo?: StringNullableWithAggregatesFilter<"Client"> | string | null
    favicon?: StringNullableWithAggregatesFilter<"Client"> | string | null
    primaryColor?: StringNullableWithAggregatesFilter<"Client"> | string | null
    secondaryColor?: StringNullableWithAggregatesFilter<"Client"> | string | null
    footerText?: StringNullableWithAggregatesFilter<"Client"> | string | null
    supportMail?: StringNullableWithAggregatesFilter<"Client"> | string | null
    subdomain?: StringNullableWithAggregatesFilter<"Client"> | string | null
    serverLocation?: StringNullableWithAggregatesFilter<"Client"> | string | null
    category?: EnumIndustryCategoryWithAggregatesFilter<"Client"> | $Enums.IndustryCategory
    onboarding?: BoolWithAggregatesFilter<"Client"> | boolean
    welcomeDashboard?: BoolWithAggregatesFilter<"Client"> | boolean
    chartList?: StringNullableListFilter<"Client">
    storage?: StringNullableWithAggregatesFilter<"Client"> | string | null
    threshold?: IntNullableWithAggregatesFilter<"Client"> | number | null
    archiveAfter?: IntNullableWithAggregatesFilter<"Client"> | number | null
    userWarning?: BoolWithAggregatesFilter<"Client"> | boolean
    adminNote?: StringNullableWithAggregatesFilter<"Client"> | string | null
    trialPeriod?: IntNullableWithAggregatesFilter<"Client"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: StringFilter<"Employee"> | string
    userId?: StringFilter<"Employee"> | string
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    description?: StringFilter<"Employee"> | string
    joinedDate?: StringFilter<"Employee"> | string
    skills?: StringNullableListFilter<"Employee">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    projectEmployees?: ProjectEmployeeListRelationFilter
    submitted?: SubmittedListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    joinedDate?: SortOrder
    skills?: SortOrder
    user?: UserOrderByWithRelationInput
    projectEmployees?: ProjectEmployeeOrderByRelationAggregateInput
    submitted?: SubmittedOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    description?: StringFilter<"Employee"> | string
    joinedDate?: StringFilter<"Employee"> | string
    skills?: StringNullableListFilter<"Employee">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    projectEmployees?: ProjectEmployeeListRelationFilter
    submitted?: SubmittedListRelationFilter
  }, "id" | "userId">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    joinedDate?: SortOrder
    skills?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Employee"> | string
    userId?: StringWithAggregatesFilter<"Employee"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    description?: StringWithAggregatesFilter<"Employee"> | string
    joinedDate?: StringWithAggregatesFilter<"Employee"> | string
    skills?: StringNullableListFilter<"Employee">
  }

  export type OtpVerificationWhereInput = {
    AND?: OtpVerificationWhereInput | OtpVerificationWhereInput[]
    OR?: OtpVerificationWhereInput[]
    NOT?: OtpVerificationWhereInput | OtpVerificationWhereInput[]
    id?: StringFilter<"OtpVerification"> | string
    email?: StringFilter<"OtpVerification"> | string
    otp?: StringFilter<"OtpVerification"> | string
    expiresAt?: DateTimeFilter<"OtpVerification"> | Date | string
    verified?: BoolFilter<"OtpVerification"> | boolean
    createdAt?: DateTimeFilter<"OtpVerification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OtpVerificationOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OtpVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: OtpVerificationWhereInput | OtpVerificationWhereInput[]
    OR?: OtpVerificationWhereInput[]
    NOT?: OtpVerificationWhereInput | OtpVerificationWhereInput[]
    otp?: StringFilter<"OtpVerification"> | string
    expiresAt?: DateTimeFilter<"OtpVerification"> | Date | string
    verified?: BoolFilter<"OtpVerification"> | boolean
    createdAt?: DateTimeFilter<"OtpVerification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "email">

  export type OtpVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    _count?: OtpVerificationCountOrderByAggregateInput
    _max?: OtpVerificationMaxOrderByAggregateInput
    _min?: OtpVerificationMinOrderByAggregateInput
  }

  export type OtpVerificationScalarWhereWithAggregatesInput = {
    AND?: OtpVerificationScalarWhereWithAggregatesInput | OtpVerificationScalarWhereWithAggregatesInput[]
    OR?: OtpVerificationScalarWhereWithAggregatesInput[]
    NOT?: OtpVerificationScalarWhereWithAggregatesInput | OtpVerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OtpVerification"> | string
    email?: StringWithAggregatesFilter<"OtpVerification"> | string
    otp?: StringWithAggregatesFilter<"OtpVerification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"OtpVerification"> | Date | string
    verified?: BoolWithAggregatesFilter<"OtpVerification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OtpVerification"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    transactionId?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    amount?: FloatFilter<"Payment"> | number
    userId?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "transactionId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    transactionId?: StringWithAggregatesFilter<"Payment"> | string
    userId?: StringWithAggregatesFilter<"Payment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type ManagerWhereInput = {
    AND?: ManagerWhereInput | ManagerWhereInput[]
    OR?: ManagerWhereInput[]
    NOT?: ManagerWhereInput | ManagerWhereInput[]
    id?: StringFilter<"Manager"> | string
    userId?: StringFilter<"Manager"> | string
    skills?: StringNullableListFilter<"Manager">
    createdAt?: DateTimeFilter<"Manager"> | Date | string
    updatedAt?: DateTimeFilter<"Manager"> | Date | string
    description?: StringFilter<"Manager"> | string
    joinedDate?: StringFilter<"Manager"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    projects?: ProjectListRelationFilter
    requestsToAddProjectMember?: RequestToAddProjectMemberListRelationFilter
  }

  export type ManagerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    skills?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    joinedDate?: SortOrder
    user?: UserOrderByWithRelationInput
    projects?: ProjectOrderByRelationAggregateInput
    requestsToAddProjectMember?: RequestToAddProjectMemberOrderByRelationAggregateInput
  }

  export type ManagerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ManagerWhereInput | ManagerWhereInput[]
    OR?: ManagerWhereInput[]
    NOT?: ManagerWhereInput | ManagerWhereInput[]
    skills?: StringNullableListFilter<"Manager">
    createdAt?: DateTimeFilter<"Manager"> | Date | string
    updatedAt?: DateTimeFilter<"Manager"> | Date | string
    description?: StringFilter<"Manager"> | string
    joinedDate?: StringFilter<"Manager"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    projects?: ProjectListRelationFilter
    requestsToAddProjectMember?: RequestToAddProjectMemberListRelationFilter
  }, "id" | "userId">

  export type ManagerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    skills?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    joinedDate?: SortOrder
    _count?: ManagerCountOrderByAggregateInput
    _max?: ManagerMaxOrderByAggregateInput
    _min?: ManagerMinOrderByAggregateInput
  }

  export type ManagerScalarWhereWithAggregatesInput = {
    AND?: ManagerScalarWhereWithAggregatesInput | ManagerScalarWhereWithAggregatesInput[]
    OR?: ManagerScalarWhereWithAggregatesInput[]
    NOT?: ManagerScalarWhereWithAggregatesInput | ManagerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Manager"> | string
    userId?: StringWithAggregatesFilter<"Manager"> | string
    skills?: StringNullableListFilter<"Manager">
    createdAt?: DateTimeWithAggregatesFilter<"Manager"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Manager"> | Date | string
    description?: StringWithAggregatesFilter<"Manager"> | string
    joinedDate?: StringWithAggregatesFilter<"Manager"> | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    senderId?: StringFilter<"Notification"> | string
    receiverIds?: StringNullableListFilter<"Notification">
    context?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    provisions?: NotificationProvisionListRelationFilter
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverIds?: SortOrder
    context?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provisions?: NotificationProvisionOrderByRelationAggregateInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    senderId?: StringFilter<"Notification"> | string
    receiverIds?: StringNullableListFilter<"Notification">
    context?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    provisions?: NotificationProvisionListRelationFilter
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverIds?: SortOrder
    context?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    senderId?: StringWithAggregatesFilter<"Notification"> | string
    receiverIds?: StringNullableListFilter<"Notification">
    context?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type NotificationProvisionWhereInput = {
    AND?: NotificationProvisionWhereInput | NotificationProvisionWhereInput[]
    OR?: NotificationProvisionWhereInput[]
    NOT?: NotificationProvisionWhereInput | NotificationProvisionWhereInput[]
    userId?: StringFilter<"NotificationProvision"> | string
    notificationId?: StringFilter<"NotificationProvision"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    notification?: XOR<NotificationScalarRelationFilter, NotificationWhereInput>
  }

  export type NotificationProvisionOrderByWithRelationInput = {
    userId?: SortOrder
    notificationId?: SortOrder
    user?: UserOrderByWithRelationInput
    notification?: NotificationOrderByWithRelationInput
  }

  export type NotificationProvisionWhereUniqueInput = Prisma.AtLeast<{
    userId_notificationId?: NotificationProvisionUserIdNotificationIdCompoundUniqueInput
    AND?: NotificationProvisionWhereInput | NotificationProvisionWhereInput[]
    OR?: NotificationProvisionWhereInput[]
    NOT?: NotificationProvisionWhereInput | NotificationProvisionWhereInput[]
    userId?: StringFilter<"NotificationProvision"> | string
    notificationId?: StringFilter<"NotificationProvision"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    notification?: XOR<NotificationScalarRelationFilter, NotificationWhereInput>
  }, "userId_notificationId">

  export type NotificationProvisionOrderByWithAggregationInput = {
    userId?: SortOrder
    notificationId?: SortOrder
    _count?: NotificationProvisionCountOrderByAggregateInput
    _max?: NotificationProvisionMaxOrderByAggregateInput
    _min?: NotificationProvisionMinOrderByAggregateInput
  }

  export type NotificationProvisionScalarWhereWithAggregatesInput = {
    AND?: NotificationProvisionScalarWhereWithAggregatesInput | NotificationProvisionScalarWhereWithAggregatesInput[]
    OR?: NotificationProvisionScalarWhereWithAggregatesInput[]
    NOT?: NotificationProvisionScalarWhereWithAggregatesInput | NotificationProvisionScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"NotificationProvision"> | string
    notificationId?: StringWithAggregatesFilter<"NotificationProvision"> | string
  }

  export type NotificationPermissionEmployeeWhereInput = {
    AND?: NotificationPermissionEmployeeWhereInput | NotificationPermissionEmployeeWhereInput[]
    OR?: NotificationPermissionEmployeeWhereInput[]
    NOT?: NotificationPermissionEmployeeWhereInput | NotificationPermissionEmployeeWhereInput[]
    id?: StringFilter<"NotificationPermissionEmployee"> | string
    userId?: StringFilter<"NotificationPermissionEmployee"> | string
    returnProject?: BoolFilter<"NotificationPermissionEmployee"> | boolean
    assignNewProject?: BoolFilter<"NotificationPermissionEmployee"> | boolean
    projectPublish?: BoolFilter<"NotificationPermissionEmployee"> | boolean
    createdAt?: DateTimeFilter<"NotificationPermissionEmployee"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPermissionEmployee"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationPermissionEmployeeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    returnProject?: SortOrder
    assignNewProject?: SortOrder
    projectPublish?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationPermissionEmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: NotificationPermissionEmployeeWhereInput | NotificationPermissionEmployeeWhereInput[]
    OR?: NotificationPermissionEmployeeWhereInput[]
    NOT?: NotificationPermissionEmployeeWhereInput | NotificationPermissionEmployeeWhereInput[]
    returnProject?: BoolFilter<"NotificationPermissionEmployee"> | boolean
    assignNewProject?: BoolFilter<"NotificationPermissionEmployee"> | boolean
    projectPublish?: BoolFilter<"NotificationPermissionEmployee"> | boolean
    createdAt?: DateTimeFilter<"NotificationPermissionEmployee"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPermissionEmployee"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NotificationPermissionEmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    returnProject?: SortOrder
    assignNewProject?: SortOrder
    projectPublish?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationPermissionEmployeeCountOrderByAggregateInput
    _max?: NotificationPermissionEmployeeMaxOrderByAggregateInput
    _min?: NotificationPermissionEmployeeMinOrderByAggregateInput
  }

  export type NotificationPermissionEmployeeScalarWhereWithAggregatesInput = {
    AND?: NotificationPermissionEmployeeScalarWhereWithAggregatesInput | NotificationPermissionEmployeeScalarWhereWithAggregatesInput[]
    OR?: NotificationPermissionEmployeeScalarWhereWithAggregatesInput[]
    NOT?: NotificationPermissionEmployeeScalarWhereWithAggregatesInput | NotificationPermissionEmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationPermissionEmployee"> | string
    userId?: StringWithAggregatesFilter<"NotificationPermissionEmployee"> | string
    returnProject?: BoolWithAggregatesFilter<"NotificationPermissionEmployee"> | boolean
    assignNewProject?: BoolWithAggregatesFilter<"NotificationPermissionEmployee"> | boolean
    projectPublish?: BoolWithAggregatesFilter<"NotificationPermissionEmployee"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NotificationPermissionEmployee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationPermissionEmployee"> | Date | string
  }

  export type NotificationPermissionManagerWhereInput = {
    AND?: NotificationPermissionManagerWhereInput | NotificationPermissionManagerWhereInput[]
    OR?: NotificationPermissionManagerWhereInput[]
    NOT?: NotificationPermissionManagerWhereInput | NotificationPermissionManagerWhereInput[]
    id?: StringFilter<"NotificationPermissionManager"> | string
    userId?: StringFilter<"NotificationPermissionManager"> | string
    fileImportByEmployees?: BoolFilter<"NotificationPermissionManager"> | boolean
    weeklySummary?: BoolFilter<"NotificationPermissionManager"> | boolean
    createNewProject?: BoolFilter<"NotificationPermissionManager"> | boolean
    createdAt?: DateTimeFilter<"NotificationPermissionManager"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPermissionManager"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationPermissionManagerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    fileImportByEmployees?: SortOrder
    weeklySummary?: SortOrder
    createNewProject?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationPermissionManagerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: NotificationPermissionManagerWhereInput | NotificationPermissionManagerWhereInput[]
    OR?: NotificationPermissionManagerWhereInput[]
    NOT?: NotificationPermissionManagerWhereInput | NotificationPermissionManagerWhereInput[]
    fileImportByEmployees?: BoolFilter<"NotificationPermissionManager"> | boolean
    weeklySummary?: BoolFilter<"NotificationPermissionManager"> | boolean
    createNewProject?: BoolFilter<"NotificationPermissionManager"> | boolean
    createdAt?: DateTimeFilter<"NotificationPermissionManager"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPermissionManager"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NotificationPermissionManagerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    fileImportByEmployees?: SortOrder
    weeklySummary?: SortOrder
    createNewProject?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationPermissionManagerCountOrderByAggregateInput
    _max?: NotificationPermissionManagerMaxOrderByAggregateInput
    _min?: NotificationPermissionManagerMinOrderByAggregateInput
  }

  export type NotificationPermissionManagerScalarWhereWithAggregatesInput = {
    AND?: NotificationPermissionManagerScalarWhereWithAggregatesInput | NotificationPermissionManagerScalarWhereWithAggregatesInput[]
    OR?: NotificationPermissionManagerScalarWhereWithAggregatesInput[]
    NOT?: NotificationPermissionManagerScalarWhereWithAggregatesInput | NotificationPermissionManagerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationPermissionManager"> | string
    userId?: StringWithAggregatesFilter<"NotificationPermissionManager"> | string
    fileImportByEmployees?: BoolWithAggregatesFilter<"NotificationPermissionManager"> | boolean
    weeklySummary?: BoolWithAggregatesFilter<"NotificationPermissionManager"> | boolean
    createNewProject?: BoolWithAggregatesFilter<"NotificationPermissionManager"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NotificationPermissionManager"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationPermissionManager"> | Date | string
  }

  export type NotificationPermissionClientWhereInput = {
    AND?: NotificationPermissionClientWhereInput | NotificationPermissionClientWhereInput[]
    OR?: NotificationPermissionClientWhereInput[]
    NOT?: NotificationPermissionClientWhereInput | NotificationPermissionClientWhereInput[]
    id?: StringFilter<"NotificationPermissionClient"> | string
    userId?: StringFilter<"NotificationPermissionClient"> | string
    onProjectApproval?: BoolFilter<"NotificationPermissionClient"> | boolean
    onProjectRejection?: BoolFilter<"NotificationPermissionClient"> | boolean
    fileImportByEmployees?: BoolFilter<"NotificationPermissionClient"> | boolean
    weeklySummary?: BoolFilter<"NotificationPermissionClient"> | boolean
    storageLimit?: BoolFilter<"NotificationPermissionClient"> | boolean
    billPayment?: BoolFilter<"NotificationPermissionClient"> | boolean
    overdueProject?: BoolFilter<"NotificationPermissionClient"> | boolean
    createdAt?: DateTimeFilter<"NotificationPermissionClient"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPermissionClient"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationPermissionClientOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    onProjectApproval?: SortOrder
    onProjectRejection?: SortOrder
    fileImportByEmployees?: SortOrder
    weeklySummary?: SortOrder
    storageLimit?: SortOrder
    billPayment?: SortOrder
    overdueProject?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationPermissionClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: NotificationPermissionClientWhereInput | NotificationPermissionClientWhereInput[]
    OR?: NotificationPermissionClientWhereInput[]
    NOT?: NotificationPermissionClientWhereInput | NotificationPermissionClientWhereInput[]
    onProjectApproval?: BoolFilter<"NotificationPermissionClient"> | boolean
    onProjectRejection?: BoolFilter<"NotificationPermissionClient"> | boolean
    fileImportByEmployees?: BoolFilter<"NotificationPermissionClient"> | boolean
    weeklySummary?: BoolFilter<"NotificationPermissionClient"> | boolean
    storageLimit?: BoolFilter<"NotificationPermissionClient"> | boolean
    billPayment?: BoolFilter<"NotificationPermissionClient"> | boolean
    overdueProject?: BoolFilter<"NotificationPermissionClient"> | boolean
    createdAt?: DateTimeFilter<"NotificationPermissionClient"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPermissionClient"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NotificationPermissionClientOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    onProjectApproval?: SortOrder
    onProjectRejection?: SortOrder
    fileImportByEmployees?: SortOrder
    weeklySummary?: SortOrder
    storageLimit?: SortOrder
    billPayment?: SortOrder
    overdueProject?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationPermissionClientCountOrderByAggregateInput
    _max?: NotificationPermissionClientMaxOrderByAggregateInput
    _min?: NotificationPermissionClientMinOrderByAggregateInput
  }

  export type NotificationPermissionClientScalarWhereWithAggregatesInput = {
    AND?: NotificationPermissionClientScalarWhereWithAggregatesInput | NotificationPermissionClientScalarWhereWithAggregatesInput[]
    OR?: NotificationPermissionClientScalarWhereWithAggregatesInput[]
    NOT?: NotificationPermissionClientScalarWhereWithAggregatesInput | NotificationPermissionClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationPermissionClient"> | string
    userId?: StringWithAggregatesFilter<"NotificationPermissionClient"> | string
    onProjectApproval?: BoolWithAggregatesFilter<"NotificationPermissionClient"> | boolean
    onProjectRejection?: BoolWithAggregatesFilter<"NotificationPermissionClient"> | boolean
    fileImportByEmployees?: BoolWithAggregatesFilter<"NotificationPermissionClient"> | boolean
    weeklySummary?: BoolWithAggregatesFilter<"NotificationPermissionClient"> | boolean
    storageLimit?: BoolWithAggregatesFilter<"NotificationPermissionClient"> | boolean
    billPayment?: BoolWithAggregatesFilter<"NotificationPermissionClient"> | boolean
    overdueProject?: BoolWithAggregatesFilter<"NotificationPermissionClient"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NotificationPermissionClient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationPermissionClient"> | Date | string
  }

  export type NotificationPermissionSupporterWhereInput = {
    AND?: NotificationPermissionSupporterWhereInput | NotificationPermissionSupporterWhereInput[]
    OR?: NotificationPermissionSupporterWhereInput[]
    NOT?: NotificationPermissionSupporterWhereInput | NotificationPermissionSupporterWhereInput[]
    id?: StringFilter<"NotificationPermissionSupporter"> | string
    userId?: StringFilter<"NotificationPermissionSupporter"> | string
    assignNewProject?: BoolFilter<"NotificationPermissionSupporter"> | boolean
    createdAt?: DateTimeFilter<"NotificationPermissionSupporter"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPermissionSupporter"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationPermissionSupporterOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    assignNewProject?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationPermissionSupporterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: NotificationPermissionSupporterWhereInput | NotificationPermissionSupporterWhereInput[]
    OR?: NotificationPermissionSupporterWhereInput[]
    NOT?: NotificationPermissionSupporterWhereInput | NotificationPermissionSupporterWhereInput[]
    assignNewProject?: BoolFilter<"NotificationPermissionSupporter"> | boolean
    createdAt?: DateTimeFilter<"NotificationPermissionSupporter"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPermissionSupporter"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NotificationPermissionSupporterOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    assignNewProject?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationPermissionSupporterCountOrderByAggregateInput
    _max?: NotificationPermissionSupporterMaxOrderByAggregateInput
    _min?: NotificationPermissionSupporterMinOrderByAggregateInput
  }

  export type NotificationPermissionSupporterScalarWhereWithAggregatesInput = {
    AND?: NotificationPermissionSupporterScalarWhereWithAggregatesInput | NotificationPermissionSupporterScalarWhereWithAggregatesInput[]
    OR?: NotificationPermissionSupporterScalarWhereWithAggregatesInput[]
    NOT?: NotificationPermissionSupporterScalarWhereWithAggregatesInput | NotificationPermissionSupporterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationPermissionSupporter"> | string
    userId?: StringWithAggregatesFilter<"NotificationPermissionSupporter"> | string
    assignNewProject?: BoolWithAggregatesFilter<"NotificationPermissionSupporter"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NotificationPermissionSupporter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationPermissionSupporter"> | Date | string
  }

  export type NotificationPermissionAdminWhereInput = {
    AND?: NotificationPermissionAdminWhereInput | NotificationPermissionAdminWhereInput[]
    OR?: NotificationPermissionAdminWhereInput[]
    NOT?: NotificationPermissionAdminWhereInput | NotificationPermissionAdminWhereInput[]
    id?: StringFilter<"NotificationPermissionAdmin"> | string
    userId?: StringFilter<"NotificationPermissionAdmin"> | string
    storageLimit?: BoolFilter<"NotificationPermissionAdmin"> | boolean
    receivedPayment?: BoolFilter<"NotificationPermissionAdmin"> | boolean
    createClient?: BoolFilter<"NotificationPermissionAdmin"> | boolean
    createTicket?: BoolFilter<"NotificationPermissionAdmin"> | boolean
    paymentCycleChange?: BoolFilter<"NotificationPermissionAdmin"> | boolean
    createdAt?: DateTimeFilter<"NotificationPermissionAdmin"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPermissionAdmin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationPermissionAdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    storageLimit?: SortOrder
    receivedPayment?: SortOrder
    createClient?: SortOrder
    createTicket?: SortOrder
    paymentCycleChange?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationPermissionAdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: NotificationPermissionAdminWhereInput | NotificationPermissionAdminWhereInput[]
    OR?: NotificationPermissionAdminWhereInput[]
    NOT?: NotificationPermissionAdminWhereInput | NotificationPermissionAdminWhereInput[]
    storageLimit?: BoolFilter<"NotificationPermissionAdmin"> | boolean
    receivedPayment?: BoolFilter<"NotificationPermissionAdmin"> | boolean
    createClient?: BoolFilter<"NotificationPermissionAdmin"> | boolean
    createTicket?: BoolFilter<"NotificationPermissionAdmin"> | boolean
    paymentCycleChange?: BoolFilter<"NotificationPermissionAdmin"> | boolean
    createdAt?: DateTimeFilter<"NotificationPermissionAdmin"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPermissionAdmin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NotificationPermissionAdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    storageLimit?: SortOrder
    receivedPayment?: SortOrder
    createClient?: SortOrder
    createTicket?: SortOrder
    paymentCycleChange?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationPermissionAdminCountOrderByAggregateInput
    _max?: NotificationPermissionAdminMaxOrderByAggregateInput
    _min?: NotificationPermissionAdminMinOrderByAggregateInput
  }

  export type NotificationPermissionAdminScalarWhereWithAggregatesInput = {
    AND?: NotificationPermissionAdminScalarWhereWithAggregatesInput | NotificationPermissionAdminScalarWhereWithAggregatesInput[]
    OR?: NotificationPermissionAdminScalarWhereWithAggregatesInput[]
    NOT?: NotificationPermissionAdminScalarWhereWithAggregatesInput | NotificationPermissionAdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationPermissionAdmin"> | string
    userId?: StringWithAggregatesFilter<"NotificationPermissionAdmin"> | string
    storageLimit?: BoolWithAggregatesFilter<"NotificationPermissionAdmin"> | boolean
    receivedPayment?: BoolWithAggregatesFilter<"NotificationPermissionAdmin"> | boolean
    createClient?: BoolWithAggregatesFilter<"NotificationPermissionAdmin"> | boolean
    createTicket?: BoolWithAggregatesFilter<"NotificationPermissionAdmin"> | boolean
    paymentCycleChange?: BoolWithAggregatesFilter<"NotificationPermissionAdmin"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NotificationPermissionAdmin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationPermissionAdmin"> | Date | string
  }

  export type NotificationPermissionSuperAdminWhereInput = {
    AND?: NotificationPermissionSuperAdminWhereInput | NotificationPermissionSuperAdminWhereInput[]
    OR?: NotificationPermissionSuperAdminWhereInput[]
    NOT?: NotificationPermissionSuperAdminWhereInput | NotificationPermissionSuperAdminWhereInput[]
    id?: StringFilter<"NotificationPermissionSuperAdmin"> | string
    userId?: StringFilter<"NotificationPermissionSuperAdmin"> | string
    storageLimit?: BoolFilter<"NotificationPermissionSuperAdmin"> | boolean
    receivedPayment?: BoolFilter<"NotificationPermissionSuperAdmin"> | boolean
    createClient?: BoolFilter<"NotificationPermissionSuperAdmin"> | boolean
    createdAt?: DateTimeFilter<"NotificationPermissionSuperAdmin"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPermissionSuperAdmin"> | Date | string
    user?: XOR<SuperAdminScalarRelationFilter, SuperAdminWhereInput>
  }

  export type NotificationPermissionSuperAdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    storageLimit?: SortOrder
    receivedPayment?: SortOrder
    createClient?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: SuperAdminOrderByWithRelationInput
  }

  export type NotificationPermissionSuperAdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: NotificationPermissionSuperAdminWhereInput | NotificationPermissionSuperAdminWhereInput[]
    OR?: NotificationPermissionSuperAdminWhereInput[]
    NOT?: NotificationPermissionSuperAdminWhereInput | NotificationPermissionSuperAdminWhereInput[]
    storageLimit?: BoolFilter<"NotificationPermissionSuperAdmin"> | boolean
    receivedPayment?: BoolFilter<"NotificationPermissionSuperAdmin"> | boolean
    createClient?: BoolFilter<"NotificationPermissionSuperAdmin"> | boolean
    createdAt?: DateTimeFilter<"NotificationPermissionSuperAdmin"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPermissionSuperAdmin"> | Date | string
    user?: XOR<SuperAdminScalarRelationFilter, SuperAdminWhereInput>
  }, "id" | "userId">

  export type NotificationPermissionSuperAdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    storageLimit?: SortOrder
    receivedPayment?: SortOrder
    createClient?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationPermissionSuperAdminCountOrderByAggregateInput
    _max?: NotificationPermissionSuperAdminMaxOrderByAggregateInput
    _min?: NotificationPermissionSuperAdminMinOrderByAggregateInput
  }

  export type NotificationPermissionSuperAdminScalarWhereWithAggregatesInput = {
    AND?: NotificationPermissionSuperAdminScalarWhereWithAggregatesInput | NotificationPermissionSuperAdminScalarWhereWithAggregatesInput[]
    OR?: NotificationPermissionSuperAdminScalarWhereWithAggregatesInput[]
    NOT?: NotificationPermissionSuperAdminScalarWhereWithAggregatesInput | NotificationPermissionSuperAdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationPermissionSuperAdmin"> | string
    userId?: StringWithAggregatesFilter<"NotificationPermissionSuperAdmin"> | string
    storageLimit?: BoolWithAggregatesFilter<"NotificationPermissionSuperAdmin"> | boolean
    receivedPayment?: BoolWithAggregatesFilter<"NotificationPermissionSuperAdmin"> | boolean
    createClient?: BoolWithAggregatesFilter<"NotificationPermissionSuperAdmin"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NotificationPermissionSuperAdmin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationPermissionSuperAdmin"> | Date | string
  }

  export type ProgramWhereInput = {
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    id?: StringFilter<"Program"> | string
    userId?: StringFilter<"Program"> | string
    programName?: StringFilter<"Program"> | string
    datetime?: StringFilter<"Program"> | string
    programDescription?: StringFilter<"Program"> | string
    priority?: StringFilter<"Program"> | string
    deadline?: StringFilter<"Program"> | string
    progress?: IntNullableFilter<"Program"> | number | null
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeFilter<"Program"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    projects?: ProjectListRelationFilter
  }

  export type ProgramOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    programName?: SortOrder
    datetime?: SortOrder
    programDescription?: SortOrder
    priority?: SortOrder
    deadline?: SortOrder
    progress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    projects?: ProjectOrderByRelationAggregateInput
  }

  export type ProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    userId?: StringFilter<"Program"> | string
    programName?: StringFilter<"Program"> | string
    datetime?: StringFilter<"Program"> | string
    programDescription?: StringFilter<"Program"> | string
    priority?: StringFilter<"Program"> | string
    deadline?: StringFilter<"Program"> | string
    progress?: IntNullableFilter<"Program"> | number | null
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeFilter<"Program"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    projects?: ProjectListRelationFilter
  }, "id">

  export type ProgramOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    programName?: SortOrder
    datetime?: SortOrder
    programDescription?: SortOrder
    priority?: SortOrder
    deadline?: SortOrder
    progress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProgramCountOrderByAggregateInput
    _avg?: ProgramAvgOrderByAggregateInput
    _max?: ProgramMaxOrderByAggregateInput
    _min?: ProgramMinOrderByAggregateInput
    _sum?: ProgramSumOrderByAggregateInput
  }

  export type ProgramScalarWhereWithAggregatesInput = {
    AND?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    OR?: ProgramScalarWhereWithAggregatesInput[]
    NOT?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Program"> | string
    userId?: StringWithAggregatesFilter<"Program"> | string
    programName?: StringWithAggregatesFilter<"Program"> | string
    datetime?: StringWithAggregatesFilter<"Program"> | string
    programDescription?: StringWithAggregatesFilter<"Program"> | string
    priority?: StringWithAggregatesFilter<"Program"> | string
    deadline?: StringWithAggregatesFilter<"Program"> | string
    progress?: IntNullableWithAggregatesFilter<"Program"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Program"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Program"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    programId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    uploadbeforeday?: StringFilter<"Project"> | string
    uploadCycle?: EnumProjectCycleFilter<"Project"> | $Enums.ProjectCycle
    description?: StringFilter<"Project"> | string
    dataReceivedTime?: StringNullableFilter<"Project"> | string | null
    beforeSubmitData?: IntNullableFilter<"Project"> | number | null
    weakuploadData?: StringNullableListFilter<"Project">
    monthlyuploadData?: StringNullableListFilter<"Project">
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    priority?: EnumPriorityFilter<"Project"> | $Enums.Priority
    deadline?: DateTimeFilter<"Project"> | Date | string
    managerId?: StringFilter<"Project"> | string
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    progress?: IntNullableFilter<"Project"> | number | null
    chartList?: StringNullableListFilter<"Project">
    estimatedCompletedDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    currentRate?: StringNullableFilter<"Project"> | string | null
    budget?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    latitude?: FloatNullableFilter<"Project"> | number | null
    longitude?: FloatNullableFilter<"Project"> | number | null
    program?: XOR<ProgramScalarRelationFilter, ProgramWhereInput>
    manager?: XOR<ManagerScalarRelationFilter, ManagerWhereInput>
    projectEmployees?: ProjectEmployeeListRelationFilter
    tasks?: TaskListRelationFilter
    activities?: ActivityListRelationFilter
    reviews?: ReviewListRelationFilter
    requestsToAddProjectMember?: RequestToAddProjectMemberListRelationFilter
    submitted?: SubmittedListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    programId?: SortOrder
    name?: SortOrder
    uploadbeforeday?: SortOrder
    uploadCycle?: SortOrder
    description?: SortOrder
    dataReceivedTime?: SortOrderInput | SortOrder
    beforeSubmitData?: SortOrderInput | SortOrder
    weakuploadData?: SortOrder
    monthlyuploadData?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    deadline?: SortOrder
    managerId?: SortOrder
    startDate?: SortOrderInput | SortOrder
    progress?: SortOrderInput | SortOrder
    chartList?: SortOrder
    estimatedCompletedDate?: SortOrderInput | SortOrder
    currentRate?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    program?: ProgramOrderByWithRelationInput
    manager?: ManagerOrderByWithRelationInput
    projectEmployees?: ProjectEmployeeOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    requestsToAddProjectMember?: RequestToAddProjectMemberOrderByRelationAggregateInput
    submitted?: SubmittedOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    programId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    uploadbeforeday?: StringFilter<"Project"> | string
    uploadCycle?: EnumProjectCycleFilter<"Project"> | $Enums.ProjectCycle
    description?: StringFilter<"Project"> | string
    dataReceivedTime?: StringNullableFilter<"Project"> | string | null
    beforeSubmitData?: IntNullableFilter<"Project"> | number | null
    weakuploadData?: StringNullableListFilter<"Project">
    monthlyuploadData?: StringNullableListFilter<"Project">
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    priority?: EnumPriorityFilter<"Project"> | $Enums.Priority
    deadline?: DateTimeFilter<"Project"> | Date | string
    managerId?: StringFilter<"Project"> | string
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    progress?: IntNullableFilter<"Project"> | number | null
    chartList?: StringNullableListFilter<"Project">
    estimatedCompletedDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    currentRate?: StringNullableFilter<"Project"> | string | null
    budget?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    latitude?: FloatNullableFilter<"Project"> | number | null
    longitude?: FloatNullableFilter<"Project"> | number | null
    program?: XOR<ProgramScalarRelationFilter, ProgramWhereInput>
    manager?: XOR<ManagerScalarRelationFilter, ManagerWhereInput>
    projectEmployees?: ProjectEmployeeListRelationFilter
    tasks?: TaskListRelationFilter
    activities?: ActivityListRelationFilter
    reviews?: ReviewListRelationFilter
    requestsToAddProjectMember?: RequestToAddProjectMemberListRelationFilter
    submitted?: SubmittedListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    programId?: SortOrder
    name?: SortOrder
    uploadbeforeday?: SortOrder
    uploadCycle?: SortOrder
    description?: SortOrder
    dataReceivedTime?: SortOrderInput | SortOrder
    beforeSubmitData?: SortOrderInput | SortOrder
    weakuploadData?: SortOrder
    monthlyuploadData?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    deadline?: SortOrder
    managerId?: SortOrder
    startDate?: SortOrderInput | SortOrder
    progress?: SortOrderInput | SortOrder
    chartList?: SortOrder
    estimatedCompletedDate?: SortOrderInput | SortOrder
    currentRate?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    programId?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    uploadbeforeday?: StringWithAggregatesFilter<"Project"> | string
    uploadCycle?: EnumProjectCycleWithAggregatesFilter<"Project"> | $Enums.ProjectCycle
    description?: StringWithAggregatesFilter<"Project"> | string
    dataReceivedTime?: StringNullableWithAggregatesFilter<"Project"> | string | null
    beforeSubmitData?: IntNullableWithAggregatesFilter<"Project"> | number | null
    weakuploadData?: StringNullableListFilter<"Project">
    monthlyuploadData?: StringNullableListFilter<"Project">
    status?: EnumProjectStatusWithAggregatesFilter<"Project"> | $Enums.ProjectStatus
    priority?: EnumPriorityWithAggregatesFilter<"Project"> | $Enums.Priority
    deadline?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    managerId?: StringWithAggregatesFilter<"Project"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    progress?: IntNullableWithAggregatesFilter<"Project"> | number | null
    chartList?: StringNullableListFilter<"Project">
    estimatedCompletedDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    currentRate?: StringNullableWithAggregatesFilter<"Project"> | string | null
    budget?: StringNullableWithAggregatesFilter<"Project"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    latitude?: FloatNullableWithAggregatesFilter<"Project"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Project"> | number | null
  }

  export type ProjectEmployeeWhereInput = {
    AND?: ProjectEmployeeWhereInput | ProjectEmployeeWhereInput[]
    OR?: ProjectEmployeeWhereInput[]
    NOT?: ProjectEmployeeWhereInput | ProjectEmployeeWhereInput[]
    id?: StringFilter<"ProjectEmployee"> | string
    projectId?: StringFilter<"ProjectEmployee"> | string
    employeeId?: StringFilter<"ProjectEmployee"> | string
    assignedAt?: DateTimeFilter<"ProjectEmployee"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type ProjectEmployeeOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    employeeId?: SortOrder
    assignedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
  }

  export type ProjectEmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_employeeId?: ProjectEmployeeProjectIdEmployeeIdCompoundUniqueInput
    AND?: ProjectEmployeeWhereInput | ProjectEmployeeWhereInput[]
    OR?: ProjectEmployeeWhereInput[]
    NOT?: ProjectEmployeeWhereInput | ProjectEmployeeWhereInput[]
    projectId?: StringFilter<"ProjectEmployee"> | string
    employeeId?: StringFilter<"ProjectEmployee"> | string
    assignedAt?: DateTimeFilter<"ProjectEmployee"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id" | "projectId_employeeId">

  export type ProjectEmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    employeeId?: SortOrder
    assignedAt?: SortOrder
    _count?: ProjectEmployeeCountOrderByAggregateInput
    _max?: ProjectEmployeeMaxOrderByAggregateInput
    _min?: ProjectEmployeeMinOrderByAggregateInput
  }

  export type ProjectEmployeeScalarWhereWithAggregatesInput = {
    AND?: ProjectEmployeeScalarWhereWithAggregatesInput | ProjectEmployeeScalarWhereWithAggregatesInput[]
    OR?: ProjectEmployeeScalarWhereWithAggregatesInput[]
    NOT?: ProjectEmployeeScalarWhereWithAggregatesInput | ProjectEmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectEmployee"> | string
    projectId?: StringWithAggregatesFilter<"ProjectEmployee"> | string
    employeeId?: StringWithAggregatesFilter<"ProjectEmployee"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"ProjectEmployee"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    projectId?: StringFilter<"Review"> | string
    taskAssignId?: StringNullableFilter<"Review"> | string | null
    status?: EnumProjectStatusFilter<"Review"> | $Enums.ProjectStatus
    managerId?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    taskAssignId?: SortOrderInput | SortOrder
    status?: SortOrder
    managerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    projectId?: StringFilter<"Review"> | string
    taskAssignId?: StringNullableFilter<"Review"> | string | null
    status?: EnumProjectStatusFilter<"Review"> | $Enums.ProjectStatus
    managerId?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    taskAssignId?: SortOrderInput | SortOrder
    status?: SortOrder
    managerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    projectId?: StringWithAggregatesFilter<"Review"> | string
    taskAssignId?: StringNullableWithAggregatesFilter<"Review"> | string | null
    status?: EnumProjectStatusWithAggregatesFilter<"Review"> | $Enums.ProjectStatus
    managerId?: StringNullableWithAggregatesFilter<"Review"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type SheetWhereInput = {
    AND?: SheetWhereInput | SheetWhereInput[]
    OR?: SheetWhereInput[]
    NOT?: SheetWhereInput | SheetWhereInput[]
    id?: StringFilter<"Sheet"> | string
    name?: StringFilter<"Sheet"> | string
    createdAt?: DateTimeFilter<"Sheet"> | Date | string
    updatedAt?: DateTimeFilter<"Sheet"> | Date | string
    submitted?: SubmittedListRelationFilter
  }

  export type SheetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    submitted?: SubmittedOrderByRelationAggregateInput
  }

  export type SheetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SheetWhereInput | SheetWhereInput[]
    OR?: SheetWhereInput[]
    NOT?: SheetWhereInput | SheetWhereInput[]
    name?: StringFilter<"Sheet"> | string
    createdAt?: DateTimeFilter<"Sheet"> | Date | string
    updatedAt?: DateTimeFilter<"Sheet"> | Date | string
    submitted?: SubmittedListRelationFilter
  }, "id">

  export type SheetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SheetCountOrderByAggregateInput
    _max?: SheetMaxOrderByAggregateInput
    _min?: SheetMinOrderByAggregateInput
  }

  export type SheetScalarWhereWithAggregatesInput = {
    AND?: SheetScalarWhereWithAggregatesInput | SheetScalarWhereWithAggregatesInput[]
    OR?: SheetScalarWhereWithAggregatesInput[]
    NOT?: SheetScalarWhereWithAggregatesInput | SheetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sheet"> | string
    name?: StringWithAggregatesFilter<"Sheet"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Sheet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sheet"> | Date | string
  }

  export type SubmissionReturnWhereInput = {
    AND?: SubmissionReturnWhereInput | SubmissionReturnWhereInput[]
    OR?: SubmissionReturnWhereInput[]
    NOT?: SubmissionReturnWhereInput | SubmissionReturnWhereInput[]
    id?: StringFilter<"SubmissionReturn"> | string
    submittedId?: StringFilter<"SubmissionReturn"> | string
    returnedAt?: DateTimeFilter<"SubmissionReturn"> | Date | string
    submitted?: XOR<SubmittedScalarRelationFilter, SubmittedWhereInput>
  }

  export type SubmissionReturnOrderByWithRelationInput = {
    id?: SortOrder
    submittedId?: SortOrder
    returnedAt?: SortOrder
    submitted?: SubmittedOrderByWithRelationInput
  }

  export type SubmissionReturnWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    submittedId?: string
    AND?: SubmissionReturnWhereInput | SubmissionReturnWhereInput[]
    OR?: SubmissionReturnWhereInput[]
    NOT?: SubmissionReturnWhereInput | SubmissionReturnWhereInput[]
    returnedAt?: DateTimeFilter<"SubmissionReturn"> | Date | string
    submitted?: XOR<SubmittedScalarRelationFilter, SubmittedWhereInput>
  }, "id" | "submittedId">

  export type SubmissionReturnOrderByWithAggregationInput = {
    id?: SortOrder
    submittedId?: SortOrder
    returnedAt?: SortOrder
    _count?: SubmissionReturnCountOrderByAggregateInput
    _max?: SubmissionReturnMaxOrderByAggregateInput
    _min?: SubmissionReturnMinOrderByAggregateInput
  }

  export type SubmissionReturnScalarWhereWithAggregatesInput = {
    AND?: SubmissionReturnScalarWhereWithAggregatesInput | SubmissionReturnScalarWhereWithAggregatesInput[]
    OR?: SubmissionReturnScalarWhereWithAggregatesInput[]
    NOT?: SubmissionReturnScalarWhereWithAggregatesInput | SubmissionReturnScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubmissionReturn"> | string
    submittedId?: StringWithAggregatesFilter<"SubmissionReturn"> | string
    returnedAt?: DateTimeWithAggregatesFilter<"SubmissionReturn"> | Date | string
  }

  export type SubmittedWhereInput = {
    AND?: SubmittedWhereInput | SubmittedWhereInput[]
    OR?: SubmittedWhereInput[]
    NOT?: SubmittedWhereInput | SubmittedWhereInput[]
    id?: StringFilter<"Submitted"> | string
    information?: StringFilter<"Submitted"> | string
    submission?: StringFilter<"Submitted"> | string
    status?: EnumSubmittedStatusFilter<"Submitted"> | $Enums.SubmittedStatus
    employeeId?: StringFilter<"Submitted"> | string
    projectId?: StringFilter<"Submitted"> | string
    sheetId?: StringFilter<"Submitted"> | string
    createdAt?: DateTimeFilter<"Submitted"> | Date | string
    updatedAt?: DateTimeFilter<"Submitted"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    sheet?: XOR<SheetScalarRelationFilter, SheetWhereInput>
    submissionReturn?: XOR<SubmissionReturnNullableScalarRelationFilter, SubmissionReturnWhereInput> | null
  }

  export type SubmittedOrderByWithRelationInput = {
    id?: SortOrder
    information?: SortOrder
    submission?: SortOrder
    status?: SortOrder
    employeeId?: SortOrder
    projectId?: SortOrder
    sheetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    sheet?: SheetOrderByWithRelationInput
    submissionReturn?: SubmissionReturnOrderByWithRelationInput
  }

  export type SubmittedWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubmittedWhereInput | SubmittedWhereInput[]
    OR?: SubmittedWhereInput[]
    NOT?: SubmittedWhereInput | SubmittedWhereInput[]
    information?: StringFilter<"Submitted"> | string
    submission?: StringFilter<"Submitted"> | string
    status?: EnumSubmittedStatusFilter<"Submitted"> | $Enums.SubmittedStatus
    employeeId?: StringFilter<"Submitted"> | string
    projectId?: StringFilter<"Submitted"> | string
    sheetId?: StringFilter<"Submitted"> | string
    createdAt?: DateTimeFilter<"Submitted"> | Date | string
    updatedAt?: DateTimeFilter<"Submitted"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    sheet?: XOR<SheetScalarRelationFilter, SheetWhereInput>
    submissionReturn?: XOR<SubmissionReturnNullableScalarRelationFilter, SubmissionReturnWhereInput> | null
  }, "id">

  export type SubmittedOrderByWithAggregationInput = {
    id?: SortOrder
    information?: SortOrder
    submission?: SortOrder
    status?: SortOrder
    employeeId?: SortOrder
    projectId?: SortOrder
    sheetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubmittedCountOrderByAggregateInput
    _max?: SubmittedMaxOrderByAggregateInput
    _min?: SubmittedMinOrderByAggregateInput
  }

  export type SubmittedScalarWhereWithAggregatesInput = {
    AND?: SubmittedScalarWhereWithAggregatesInput | SubmittedScalarWhereWithAggregatesInput[]
    OR?: SubmittedScalarWhereWithAggregatesInput[]
    NOT?: SubmittedScalarWhereWithAggregatesInput | SubmittedScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Submitted"> | string
    information?: StringWithAggregatesFilter<"Submitted"> | string
    submission?: StringWithAggregatesFilter<"Submitted"> | string
    status?: EnumSubmittedStatusWithAggregatesFilter<"Submitted"> | $Enums.SubmittedStatus
    employeeId?: StringWithAggregatesFilter<"Submitted"> | string
    projectId?: StringWithAggregatesFilter<"Submitted"> | string
    sheetId?: StringWithAggregatesFilter<"Submitted"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Submitted"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Submitted"> | Date | string
  }

  export type SuperAdminWhereInput = {
    AND?: SuperAdminWhereInput | SuperAdminWhereInput[]
    OR?: SuperAdminWhereInput[]
    NOT?: SuperAdminWhereInput | SuperAdminWhereInput[]
    id?: StringFilter<"SuperAdmin"> | string
    userId?: StringFilter<"SuperAdmin"> | string
    clientLogo?: StringNullableFilter<"SuperAdmin"> | string | null
    favicon?: StringNullableFilter<"SuperAdmin"> | string | null
    primaryColor?: StringNullableFilter<"SuperAdmin"> | string | null
    secondaryColor?: StringNullableFilter<"SuperAdmin"> | string | null
    createdAt?: DateTimeFilter<"SuperAdmin"> | Date | string
    updatedAt?: DateTimeFilter<"SuperAdmin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    notificationPermissionSuperAdmin?: XOR<NotificationPermissionSuperAdminNullableScalarRelationFilter, NotificationPermissionSuperAdminWhereInput> | null
  }

  export type SuperAdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    clientLogo?: SortOrderInput | SortOrder
    favicon?: SortOrderInput | SortOrder
    primaryColor?: SortOrderInput | SortOrder
    secondaryColor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    notificationPermissionSuperAdmin?: NotificationPermissionSuperAdminOrderByWithRelationInput
  }

  export type SuperAdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: SuperAdminWhereInput | SuperAdminWhereInput[]
    OR?: SuperAdminWhereInput[]
    NOT?: SuperAdminWhereInput | SuperAdminWhereInput[]
    clientLogo?: StringNullableFilter<"SuperAdmin"> | string | null
    favicon?: StringNullableFilter<"SuperAdmin"> | string | null
    primaryColor?: StringNullableFilter<"SuperAdmin"> | string | null
    secondaryColor?: StringNullableFilter<"SuperAdmin"> | string | null
    createdAt?: DateTimeFilter<"SuperAdmin"> | Date | string
    updatedAt?: DateTimeFilter<"SuperAdmin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    notificationPermissionSuperAdmin?: XOR<NotificationPermissionSuperAdminNullableScalarRelationFilter, NotificationPermissionSuperAdminWhereInput> | null
  }, "id" | "userId">

  export type SuperAdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    clientLogo?: SortOrderInput | SortOrder
    favicon?: SortOrderInput | SortOrder
    primaryColor?: SortOrderInput | SortOrder
    secondaryColor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SuperAdminCountOrderByAggregateInput
    _max?: SuperAdminMaxOrderByAggregateInput
    _min?: SuperAdminMinOrderByAggregateInput
  }

  export type SuperAdminScalarWhereWithAggregatesInput = {
    AND?: SuperAdminScalarWhereWithAggregatesInput | SuperAdminScalarWhereWithAggregatesInput[]
    OR?: SuperAdminScalarWhereWithAggregatesInput[]
    NOT?: SuperAdminScalarWhereWithAggregatesInput | SuperAdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SuperAdmin"> | string
    userId?: StringWithAggregatesFilter<"SuperAdmin"> | string
    clientLogo?: StringNullableWithAggregatesFilter<"SuperAdmin"> | string | null
    favicon?: StringNullableWithAggregatesFilter<"SuperAdmin"> | string | null
    primaryColor?: StringNullableWithAggregatesFilter<"SuperAdmin"> | string | null
    secondaryColor?: StringNullableWithAggregatesFilter<"SuperAdmin"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SuperAdmin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SuperAdmin"> | Date | string
  }

  export type SupporterWhereInput = {
    AND?: SupporterWhereInput | SupporterWhereInput[]
    OR?: SupporterWhereInput[]
    NOT?: SupporterWhereInput | SupporterWhereInput[]
    id?: StringFilter<"Supporter"> | string
    userId?: StringFilter<"Supporter"> | string
    supporterRole?: EnumSupporterRoleFilter<"Supporter"> | $Enums.SupporterRole
    skills?: StringNullableListFilter<"Supporter">
    workload?: IntNullableFilter<"Supporter"> | number | null
    workItems?: StringNullableListFilter<"Supporter">
    createdAt?: DateTimeFilter<"Supporter"> | Date | string
    updatedAt?: DateTimeFilter<"Supporter"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SupporterOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    supporterRole?: SortOrder
    skills?: SortOrder
    workload?: SortOrderInput | SortOrder
    workItems?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SupporterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: SupporterWhereInput | SupporterWhereInput[]
    OR?: SupporterWhereInput[]
    NOT?: SupporterWhereInput | SupporterWhereInput[]
    supporterRole?: EnumSupporterRoleFilter<"Supporter"> | $Enums.SupporterRole
    skills?: StringNullableListFilter<"Supporter">
    workload?: IntNullableFilter<"Supporter"> | number | null
    workItems?: StringNullableListFilter<"Supporter">
    createdAt?: DateTimeFilter<"Supporter"> | Date | string
    updatedAt?: DateTimeFilter<"Supporter"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type SupporterOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    supporterRole?: SortOrder
    skills?: SortOrder
    workload?: SortOrderInput | SortOrder
    workItems?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupporterCountOrderByAggregateInput
    _avg?: SupporterAvgOrderByAggregateInput
    _max?: SupporterMaxOrderByAggregateInput
    _min?: SupporterMinOrderByAggregateInput
    _sum?: SupporterSumOrderByAggregateInput
  }

  export type SupporterScalarWhereWithAggregatesInput = {
    AND?: SupporterScalarWhereWithAggregatesInput | SupporterScalarWhereWithAggregatesInput[]
    OR?: SupporterScalarWhereWithAggregatesInput[]
    NOT?: SupporterScalarWhereWithAggregatesInput | SupporterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Supporter"> | string
    userId?: StringWithAggregatesFilter<"Supporter"> | string
    supporterRole?: EnumSupporterRoleWithAggregatesFilter<"Supporter"> | $Enums.SupporterRole
    skills?: StringNullableListFilter<"Supporter">
    workload?: IntNullableWithAggregatesFilter<"Supporter"> | number | null
    workItems?: StringNullableListFilter<"Supporter">
    createdAt?: DateTimeWithAggregatesFilter<"Supporter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Supporter"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    status?: EnumTaskStatusNullableFilter<"Task"> | $Enums.TaskStatus | null
    name?: StringFilter<"Task"> | string
    projectId?: StringFilter<"Task"> | string
    progress?: IntNullableFilter<"Task"> | number | null
    dueDate?: StringNullableFilter<"Task"> | string | null
    assignedTo?: StringFilter<"Task"> | string
    assigneeType?: StringFilter<"Task"> | string
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrderInput | SortOrder
    name?: SortOrder
    projectId?: SortOrder
    progress?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    assignedTo?: SortOrder
    assigneeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    status?: EnumTaskStatusNullableFilter<"Task"> | $Enums.TaskStatus | null
    name?: StringFilter<"Task"> | string
    projectId?: StringFilter<"Task"> | string
    progress?: IntNullableFilter<"Task"> | number | null
    dueDate?: StringNullableFilter<"Task"> | string | null
    assignedTo?: StringFilter<"Task"> | string
    assigneeType?: StringFilter<"Task"> | string
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrderInput | SortOrder
    name?: SortOrder
    projectId?: SortOrder
    progress?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    assignedTo?: SortOrder
    assigneeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    status?: EnumTaskStatusNullableWithAggregatesFilter<"Task"> | $Enums.TaskStatus | null
    name?: StringWithAggregatesFilter<"Task"> | string
    projectId?: StringWithAggregatesFilter<"Task"> | string
    progress?: IntNullableWithAggregatesFilter<"Task"> | number | null
    dueDate?: StringNullableWithAggregatesFilter<"Task"> | string | null
    assignedTo?: StringWithAggregatesFilter<"Task"> | string
    assigneeType?: StringWithAggregatesFilter<"Task"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type TicketWhereInput = {
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    id?: StringFilter<"Ticket"> | string
    clientId?: StringFilter<"Ticket"> | string
    supporterIds?: StringNullableListFilter<"Ticket">
    adminIds?: StringNullableListFilter<"Ticket">
    companyName?: StringNullableFilter<"Ticket"> | string | null
    subject?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumPriorityFilter<"Ticket"> | $Enums.Priority
    issue?: StringFilter<"Ticket"> | string
    adminNote?: StringNullableFilter<"Ticket"> | string | null
    attachFile?: StringNullableFilter<"Ticket"> | string | null
    issueType?: EnumIssueTypeFilter<"Ticket"> | $Enums.IssueType
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type TicketOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    supporterIds?: SortOrder
    adminIds?: SortOrder
    companyName?: SortOrderInput | SortOrder
    subject?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    issue?: SortOrder
    adminNote?: SortOrderInput | SortOrder
    attachFile?: SortOrderInput | SortOrder
    issueType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
  }

  export type TicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    clientId?: StringFilter<"Ticket"> | string
    supporterIds?: StringNullableListFilter<"Ticket">
    adminIds?: StringNullableListFilter<"Ticket">
    companyName?: StringNullableFilter<"Ticket"> | string | null
    subject?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumPriorityFilter<"Ticket"> | $Enums.Priority
    issue?: StringFilter<"Ticket"> | string
    adminNote?: StringNullableFilter<"Ticket"> | string | null
    attachFile?: StringNullableFilter<"Ticket"> | string | null
    issueType?: EnumIssueTypeFilter<"Ticket"> | $Enums.IssueType
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id">

  export type TicketOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    supporterIds?: SortOrder
    adminIds?: SortOrder
    companyName?: SortOrderInput | SortOrder
    subject?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    issue?: SortOrder
    adminNote?: SortOrderInput | SortOrder
    attachFile?: SortOrderInput | SortOrder
    issueType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TicketCountOrderByAggregateInput
    _max?: TicketMaxOrderByAggregateInput
    _min?: TicketMinOrderByAggregateInput
  }

  export type TicketScalarWhereWithAggregatesInput = {
    AND?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    OR?: TicketScalarWhereWithAggregatesInput[]
    NOT?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ticket"> | string
    clientId?: StringWithAggregatesFilter<"Ticket"> | string
    supporterIds?: StringNullableListFilter<"Ticket">
    adminIds?: StringNullableListFilter<"Ticket">
    companyName?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    subject?: StringWithAggregatesFilter<"Ticket"> | string
    status?: EnumTicketStatusWithAggregatesFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumPriorityWithAggregatesFilter<"Ticket"> | $Enums.Priority
    issue?: StringWithAggregatesFilter<"Ticket"> | string
    adminNote?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    attachFile?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    issueType?: EnumIssueTypeWithAggregatesFilter<"Ticket"> | $Enums.IssueType
    createdAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phoneNumber?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    profileImage?: StringNullableFilter<"User"> | string | null
    language?: EnumLanguageFilter<"User"> | $Enums.Language
    timezone?: DateTimeNullableFilter<"User"> | Date | string | null
    verification2FA?: BoolFilter<"User"> | boolean
    status?: BoolFilter<"User"> | boolean
    lastActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    userStatus?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    manager?: XOR<ManagerNullableScalarRelationFilter, ManagerWhereInput> | null
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    viewer?: XOR<ViewerNullableScalarRelationFilter, ViewerWhereInput> | null
    supporter?: XOR<SupporterNullableScalarRelationFilter, SupporterWhereInput> | null
    superAdmin?: XOR<SuperAdminNullableScalarRelationFilter, SuperAdminWhereInput> | null
    notificationEmployee?: XOR<NotificationPermissionEmployeeNullableScalarRelationFilter, NotificationPermissionEmployeeWhereInput> | null
    notificationManager?: XOR<NotificationPermissionManagerNullableScalarRelationFilter, NotificationPermissionManagerWhereInput> | null
    notificationClient?: XOR<NotificationPermissionClientNullableScalarRelationFilter, NotificationPermissionClientWhereInput> | null
    notificationSupporter?: XOR<NotificationPermissionSupporterNullableScalarRelationFilter, NotificationPermissionSupporterWhereInput> | null
    notificationAdmin?: XOR<NotificationPermissionAdminNullableScalarRelationFilter, NotificationPermissionAdminWhereInput> | null
    notifications?: NotificationProvisionListRelationFilter
    otpVerification?: XOR<OtpVerificationNullableScalarRelationFilter, OtpVerificationWhereInput> | null
    payments?: PaymentListRelationFilter
    activities?: ActivityListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    language?: SortOrder
    timezone?: SortOrderInput | SortOrder
    verification2FA?: SortOrder
    status?: SortOrder
    lastActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userStatus?: SortOrder
    client?: ClientOrderByWithRelationInput
    manager?: ManagerOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
    viewer?: ViewerOrderByWithRelationInput
    supporter?: SupporterOrderByWithRelationInput
    superAdmin?: SuperAdminOrderByWithRelationInput
    notificationEmployee?: NotificationPermissionEmployeeOrderByWithRelationInput
    notificationManager?: NotificationPermissionManagerOrderByWithRelationInput
    notificationClient?: NotificationPermissionClientOrderByWithRelationInput
    notificationSupporter?: NotificationPermissionSupporterOrderByWithRelationInput
    notificationAdmin?: NotificationPermissionAdminOrderByWithRelationInput
    notifications?: NotificationProvisionOrderByRelationAggregateInput
    otpVerification?: OtpVerificationOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phoneNumber?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    profileImage?: StringNullableFilter<"User"> | string | null
    language?: EnumLanguageFilter<"User"> | $Enums.Language
    timezone?: DateTimeNullableFilter<"User"> | Date | string | null
    verification2FA?: BoolFilter<"User"> | boolean
    status?: BoolFilter<"User"> | boolean
    lastActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    userStatus?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    manager?: XOR<ManagerNullableScalarRelationFilter, ManagerWhereInput> | null
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    viewer?: XOR<ViewerNullableScalarRelationFilter, ViewerWhereInput> | null
    supporter?: XOR<SupporterNullableScalarRelationFilter, SupporterWhereInput> | null
    superAdmin?: XOR<SuperAdminNullableScalarRelationFilter, SuperAdminWhereInput> | null
    notificationEmployee?: XOR<NotificationPermissionEmployeeNullableScalarRelationFilter, NotificationPermissionEmployeeWhereInput> | null
    notificationManager?: XOR<NotificationPermissionManagerNullableScalarRelationFilter, NotificationPermissionManagerWhereInput> | null
    notificationClient?: XOR<NotificationPermissionClientNullableScalarRelationFilter, NotificationPermissionClientWhereInput> | null
    notificationSupporter?: XOR<NotificationPermissionSupporterNullableScalarRelationFilter, NotificationPermissionSupporterWhereInput> | null
    notificationAdmin?: XOR<NotificationPermissionAdminNullableScalarRelationFilter, NotificationPermissionAdminWhereInput> | null
    notifications?: NotificationProvisionListRelationFilter
    otpVerification?: XOR<OtpVerificationNullableScalarRelationFilter, OtpVerificationWhereInput> | null
    payments?: PaymentListRelationFilter
    activities?: ActivityListRelationFilter
  }, "id" | "email" | "phoneNumber">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    language?: SortOrder
    timezone?: SortOrderInput | SortOrder
    verification2FA?: SortOrder
    status?: SortOrder
    lastActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userStatus?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phoneNumber?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    profileImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    language?: EnumLanguageWithAggregatesFilter<"User"> | $Enums.Language
    timezone?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    verification2FA?: BoolWithAggregatesFilter<"User"> | boolean
    status?: BoolWithAggregatesFilter<"User"> | boolean
    lastActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    userStatus?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    clientId?: StringFilter<"Tag"> | string
    tags?: StringNullableListFilter<"Tag">
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type TagOrderByWithRelationInput = {
    clientId?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    clientId?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    tags?: StringNullableListFilter<"Tag">
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "clientId">

  export type TagOrderByWithAggregationInput = {
    clientId?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    clientId?: StringWithAggregatesFilter<"Tag"> | string
    tags?: StringNullableListFilter<"Tag">
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type ReferredPersonWhereInput = {
    AND?: ReferredPersonWhereInput | ReferredPersonWhereInput[]
    OR?: ReferredPersonWhereInput[]
    NOT?: ReferredPersonWhereInput | ReferredPersonWhereInput[]
    id?: StringFilter<"ReferredPerson"> | string
    name?: StringFilter<"ReferredPerson"> | string
    userId?: StringFilter<"ReferredPerson"> | string
    email?: StringNullableFilter<"ReferredPerson"> | string | null
    phoneNumber?: IntNullableFilter<"ReferredPerson"> | number | null
    aboutThere?: StringNullableFilter<"ReferredPerson"> | string | null
    createdAt?: DateTimeFilter<"ReferredPerson"> | Date | string
    updatedAt?: DateTimeFilter<"ReferredPerson"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type ReferredPersonOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    email?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    aboutThere?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
  }

  export type ReferredPersonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReferredPersonWhereInput | ReferredPersonWhereInput[]
    OR?: ReferredPersonWhereInput[]
    NOT?: ReferredPersonWhereInput | ReferredPersonWhereInput[]
    name?: StringFilter<"ReferredPerson"> | string
    userId?: StringFilter<"ReferredPerson"> | string
    email?: StringNullableFilter<"ReferredPerson"> | string | null
    phoneNumber?: IntNullableFilter<"ReferredPerson"> | number | null
    aboutThere?: StringNullableFilter<"ReferredPerson"> | string | null
    createdAt?: DateTimeFilter<"ReferredPerson"> | Date | string
    updatedAt?: DateTimeFilter<"ReferredPerson"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id">

  export type ReferredPersonOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    email?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    aboutThere?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReferredPersonCountOrderByAggregateInput
    _avg?: ReferredPersonAvgOrderByAggregateInput
    _max?: ReferredPersonMaxOrderByAggregateInput
    _min?: ReferredPersonMinOrderByAggregateInput
    _sum?: ReferredPersonSumOrderByAggregateInput
  }

  export type ReferredPersonScalarWhereWithAggregatesInput = {
    AND?: ReferredPersonScalarWhereWithAggregatesInput | ReferredPersonScalarWhereWithAggregatesInput[]
    OR?: ReferredPersonScalarWhereWithAggregatesInput[]
    NOT?: ReferredPersonScalarWhereWithAggregatesInput | ReferredPersonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReferredPerson"> | string
    name?: StringWithAggregatesFilter<"ReferredPerson"> | string
    userId?: StringWithAggregatesFilter<"ReferredPerson"> | string
    email?: StringNullableWithAggregatesFilter<"ReferredPerson"> | string | null
    phoneNumber?: IntNullableWithAggregatesFilter<"ReferredPerson"> | number | null
    aboutThere?: StringNullableWithAggregatesFilter<"ReferredPerson"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ReferredPerson"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReferredPerson"> | Date | string
  }

  export type RequestToAddProjectMemberWhereInput = {
    AND?: RequestToAddProjectMemberWhereInput | RequestToAddProjectMemberWhereInput[]
    OR?: RequestToAddProjectMemberWhereInput[]
    NOT?: RequestToAddProjectMemberWhereInput | RequestToAddProjectMemberWhereInput[]
    id?: StringFilter<"RequestToAddProjectMember"> | string
    clientId?: StringNullableFilter<"RequestToAddProjectMember"> | string | null
    projectId?: StringFilter<"RequestToAddProjectMember"> | string
    managerId?: StringFilter<"RequestToAddProjectMember"> | string
    createdAt?: DateTimeFilter<"RequestToAddProjectMember"> | Date | string
    updatedAt?: DateTimeFilter<"RequestToAddProjectMember"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    manager?: XOR<ManagerScalarRelationFilter, ManagerWhereInput>
  }

  export type RequestToAddProjectMemberOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrderInput | SortOrder
    projectId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    manager?: ManagerOrderByWithRelationInput
  }

  export type RequestToAddProjectMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RequestToAddProjectMemberWhereInput | RequestToAddProjectMemberWhereInput[]
    OR?: RequestToAddProjectMemberWhereInput[]
    NOT?: RequestToAddProjectMemberWhereInput | RequestToAddProjectMemberWhereInput[]
    clientId?: StringNullableFilter<"RequestToAddProjectMember"> | string | null
    projectId?: StringFilter<"RequestToAddProjectMember"> | string
    managerId?: StringFilter<"RequestToAddProjectMember"> | string
    createdAt?: DateTimeFilter<"RequestToAddProjectMember"> | Date | string
    updatedAt?: DateTimeFilter<"RequestToAddProjectMember"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    manager?: XOR<ManagerScalarRelationFilter, ManagerWhereInput>
  }, "id">

  export type RequestToAddProjectMemberOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrderInput | SortOrder
    projectId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RequestToAddProjectMemberCountOrderByAggregateInput
    _max?: RequestToAddProjectMemberMaxOrderByAggregateInput
    _min?: RequestToAddProjectMemberMinOrderByAggregateInput
  }

  export type RequestToAddProjectMemberScalarWhereWithAggregatesInput = {
    AND?: RequestToAddProjectMemberScalarWhereWithAggregatesInput | RequestToAddProjectMemberScalarWhereWithAggregatesInput[]
    OR?: RequestToAddProjectMemberScalarWhereWithAggregatesInput[]
    NOT?: RequestToAddProjectMemberScalarWhereWithAggregatesInput | RequestToAddProjectMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RequestToAddProjectMember"> | string
    clientId?: StringNullableWithAggregatesFilter<"RequestToAddProjectMember"> | string | null
    projectId?: StringWithAggregatesFilter<"RequestToAddProjectMember"> | string
    managerId?: StringWithAggregatesFilter<"RequestToAddProjectMember"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RequestToAddProjectMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RequestToAddProjectMember"> | Date | string
  }

  export type ViewerWhereInput = {
    AND?: ViewerWhereInput | ViewerWhereInput[]
    OR?: ViewerWhereInput[]
    NOT?: ViewerWhereInput | ViewerWhereInput[]
    id?: StringFilter<"Viewer"> | string
    userId?: StringFilter<"Viewer"> | string
    createdAt?: DateTimeFilter<"Viewer"> | Date | string
    updatedAt?: DateTimeFilter<"Viewer"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ViewerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ViewerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ViewerWhereInput | ViewerWhereInput[]
    OR?: ViewerWhereInput[]
    NOT?: ViewerWhereInput | ViewerWhereInput[]
    createdAt?: DateTimeFilter<"Viewer"> | Date | string
    updatedAt?: DateTimeFilter<"Viewer"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type ViewerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ViewerCountOrderByAggregateInput
    _max?: ViewerMaxOrderByAggregateInput
    _min?: ViewerMinOrderByAggregateInput
  }

  export type ViewerScalarWhereWithAggregatesInput = {
    AND?: ViewerScalarWhereWithAggregatesInput | ViewerScalarWhereWithAggregatesInput[]
    OR?: ViewerScalarWhereWithAggregatesInput[]
    NOT?: ViewerScalarWhereWithAggregatesInput | ViewerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Viewer"> | string
    userId?: StringWithAggregatesFilter<"Viewer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Viewer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Viewer"> | Date | string
  }

  export type ActivityCreateInput = {
    id?: string
    timestamp?: Date | string
    description: string
    ipAddress?: string | null
    actionType?: $Enums.ActivityActionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutActivitiesInput
    user: UserCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    userId: string
    timestamp?: Date | string
    description: string
    projectId: string
    ipAddress?: string | null
    actionType?: $Enums.ActivityActionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: EnumActivityActionTypeFieldUpdateOperationsInput | $Enums.ActivityActionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutActivitiesNestedInput
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: EnumActivityActionTypeFieldUpdateOperationsInput | $Enums.ActivityActionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyInput = {
    id?: string
    userId: string
    timestamp?: Date | string
    description: string
    projectId: string
    ipAddress?: string | null
    actionType?: $Enums.ActivityActionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: EnumActivityActionTypeFieldUpdateOperationsInput | $Enums.ActivityActionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: EnumActivityActionTypeFieldUpdateOperationsInput | $Enums.ActivityActionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    id?: string
    email: string
    contactPersonName?: string | null
    clientLogo?: string | null
    favicon?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    footerText?: string | null
    supportMail?: string | null
    subdomain?: string | null
    serverLocation?: string | null
    category?: $Enums.IndustryCategory
    onboarding?: boolean
    welcomeDashboard?: boolean
    chartList?: ClientCreatechartListInput | string[]
    storage?: string | null
    threshold?: number | null
    archiveAfter?: number | null
    userWarning?: boolean
    adminNote?: string | null
    trialPeriod?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientInput
    referredPersons?: ReferredPersonCreateNestedManyWithoutClientInput
    tickets?: TicketCreateNestedManyWithoutClientInput
    programs?: ProgramCreateNestedManyWithoutClientInput
    tags?: TagCreateNestedOneWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    userId: string
    email: string
    contactPersonName?: string | null
    clientLogo?: string | null
    favicon?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    footerText?: string | null
    supportMail?: string | null
    subdomain?: string | null
    serverLocation?: string | null
    category?: $Enums.IndustryCategory
    onboarding?: boolean
    welcomeDashboard?: boolean
    chartList?: ClientCreatechartListInput | string[]
    storage?: string | null
    threshold?: number | null
    archiveAfter?: number | null
    userWarning?: boolean
    adminNote?: string | null
    trialPeriod?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredPersons?: ReferredPersonUncheckedCreateNestedManyWithoutClientInput
    tickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    programs?: ProgramUncheckedCreateNestedManyWithoutClientInput
    tags?: TagUncheckedCreateNestedOneWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactPersonName?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    supportMail?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    serverLocation?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumIndustryCategoryFieldUpdateOperationsInput | $Enums.IndustryCategory
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    welcomeDashboard?: BoolFieldUpdateOperationsInput | boolean
    chartList?: ClientUpdatechartListInput | string[]
    storage?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: NullableIntFieldUpdateOperationsInput | number | null
    archiveAfter?: NullableIntFieldUpdateOperationsInput | number | null
    userWarning?: BoolFieldUpdateOperationsInput | boolean
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    trialPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientNestedInput
    referredPersons?: ReferredPersonUpdateManyWithoutClientNestedInput
    tickets?: TicketUpdateManyWithoutClientNestedInput
    programs?: ProgramUpdateManyWithoutClientNestedInput
    tags?: TagUpdateOneWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactPersonName?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    supportMail?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    serverLocation?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumIndustryCategoryFieldUpdateOperationsInput | $Enums.IndustryCategory
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    welcomeDashboard?: BoolFieldUpdateOperationsInput | boolean
    chartList?: ClientUpdatechartListInput | string[]
    storage?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: NullableIntFieldUpdateOperationsInput | number | null
    archiveAfter?: NullableIntFieldUpdateOperationsInput | number | null
    userWarning?: BoolFieldUpdateOperationsInput | boolean
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    trialPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredPersons?: ReferredPersonUncheckedUpdateManyWithoutClientNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutClientNestedInput
    tags?: TagUncheckedUpdateOneWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    userId: string
    email: string
    contactPersonName?: string | null
    clientLogo?: string | null
    favicon?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    footerText?: string | null
    supportMail?: string | null
    subdomain?: string | null
    serverLocation?: string | null
    category?: $Enums.IndustryCategory
    onboarding?: boolean
    welcomeDashboard?: boolean
    chartList?: ClientCreatechartListInput | string[]
    storage?: string | null
    threshold?: number | null
    archiveAfter?: number | null
    userWarning?: boolean
    adminNote?: string | null
    trialPeriod?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactPersonName?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    supportMail?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    serverLocation?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumIndustryCategoryFieldUpdateOperationsInput | $Enums.IndustryCategory
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    welcomeDashboard?: BoolFieldUpdateOperationsInput | boolean
    chartList?: ClientUpdatechartListInput | string[]
    storage?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: NullableIntFieldUpdateOperationsInput | number | null
    archiveAfter?: NullableIntFieldUpdateOperationsInput | number | null
    userWarning?: BoolFieldUpdateOperationsInput | boolean
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    trialPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactPersonName?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    supportMail?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    serverLocation?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumIndustryCategoryFieldUpdateOperationsInput | $Enums.IndustryCategory
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    welcomeDashboard?: BoolFieldUpdateOperationsInput | boolean
    chartList?: ClientUpdatechartListInput | string[]
    storage?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: NullableIntFieldUpdateOperationsInput | number | null
    archiveAfter?: NullableIntFieldUpdateOperationsInput | number | null
    userWarning?: BoolFieldUpdateOperationsInput | boolean
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    trialPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    joinedDate: string
    skills?: EmployeeCreateskillsInput | string[]
    user: UserCreateNestedOneWithoutEmployeeInput
    projectEmployees?: ProjectEmployeeCreateNestedManyWithoutEmployeeInput
    submitted?: SubmittedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    joinedDate: string
    skills?: EmployeeCreateskillsInput | string[]
    projectEmployees?: ProjectEmployeeUncheckedCreateNestedManyWithoutEmployeeInput
    submitted?: SubmittedUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    joinedDate?: StringFieldUpdateOperationsInput | string
    skills?: EmployeeUpdateskillsInput | string[]
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    projectEmployees?: ProjectEmployeeUpdateManyWithoutEmployeeNestedInput
    submitted?: SubmittedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    joinedDate?: StringFieldUpdateOperationsInput | string
    skills?: EmployeeUpdateskillsInput | string[]
    projectEmployees?: ProjectEmployeeUncheckedUpdateManyWithoutEmployeeNestedInput
    submitted?: SubmittedUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    joinedDate: string
    skills?: EmployeeCreateskillsInput | string[]
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    joinedDate?: StringFieldUpdateOperationsInput | string
    skills?: EmployeeUpdateskillsInput | string[]
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    joinedDate?: StringFieldUpdateOperationsInput | string
    skills?: EmployeeUpdateskillsInput | string[]
  }

  export type OtpVerificationCreateInput = {
    id?: string
    otp: string
    expiresAt: Date | string
    verified?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutOtpVerificationInput
  }

  export type OtpVerificationUncheckedCreateInput = {
    id?: string
    email: string
    otp: string
    expiresAt: Date | string
    verified?: boolean
    createdAt?: Date | string
  }

  export type OtpVerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOtpVerificationNestedInput
  }

  export type OtpVerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpVerificationCreateManyInput = {
    id?: string
    email: string
    otp: string
    expiresAt: Date | string
    verified?: boolean
    createdAt?: Date | string
  }

  export type OtpVerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpVerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: number
    transactionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    amount: number
    transactionId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transactionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transactionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    amount: number
    transactionId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transactionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transactionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagerCreateInput = {
    id?: string
    skills?: ManagerCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    joinedDate: string
    user: UserCreateNestedOneWithoutManagerInput
    projects?: ProjectCreateNestedManyWithoutManagerInput
    requestsToAddProjectMember?: RequestToAddProjectMemberCreateNestedManyWithoutManagerInput
  }

  export type ManagerUncheckedCreateInput = {
    id?: string
    userId: string
    skills?: ManagerCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    joinedDate: string
    projects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUncheckedCreateNestedManyWithoutManagerInput
  }

  export type ManagerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: ManagerUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    joinedDate?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutManagerNestedInput
    projects?: ProjectUpdateManyWithoutManagerNestedInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    skills?: ManagerUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    joinedDate?: StringFieldUpdateOperationsInput | string
    projects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type ManagerCreateManyInput = {
    id?: string
    userId: string
    skills?: ManagerCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    joinedDate: string
  }

  export type ManagerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: ManagerUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    joinedDate?: StringFieldUpdateOperationsInput | string
  }

  export type ManagerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    skills?: ManagerUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    joinedDate?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateInput = {
    id?: string
    senderId: string
    receiverIds?: NotificationCreatereceiverIdsInput | string[]
    context: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    provisions?: NotificationProvisionCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    senderId: string
    receiverIds?: NotificationCreatereceiverIdsInput | string[]
    context: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    provisions?: NotificationProvisionUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverIds?: NotificationUpdatereceiverIdsInput | string[]
    context?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provisions?: NotificationProvisionUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverIds?: NotificationUpdatereceiverIdsInput | string[]
    context?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provisions?: NotificationProvisionUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationCreateManyInput = {
    id?: string
    senderId: string
    receiverIds?: NotificationCreatereceiverIdsInput | string[]
    context: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverIds?: NotificationUpdatereceiverIdsInput | string[]
    context?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverIds?: NotificationUpdatereceiverIdsInput | string[]
    context?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationProvisionCreateInput = {
    user: UserCreateNestedOneWithoutNotificationsInput
    notification: NotificationCreateNestedOneWithoutProvisionsInput
  }

  export type NotificationProvisionUncheckedCreateInput = {
    userId: string
    notificationId: string
  }

  export type NotificationProvisionUpdateInput = {
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    notification?: NotificationUpdateOneRequiredWithoutProvisionsNestedInput
  }

  export type NotificationProvisionUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationProvisionCreateManyInput = {
    userId: string
    notificationId: string
  }

  export type NotificationProvisionUpdateManyMutationInput = {

  }

  export type NotificationProvisionUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationPermissionEmployeeCreateInput = {
    id?: string
    returnProject?: boolean
    assignNewProject?: boolean
    projectPublish?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationEmployeeInput
  }

  export type NotificationPermissionEmployeeUncheckedCreateInput = {
    id?: string
    userId: string
    returnProject?: boolean
    assignNewProject?: boolean
    projectPublish?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionEmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnProject?: BoolFieldUpdateOperationsInput | boolean
    assignNewProject?: BoolFieldUpdateOperationsInput | boolean
    projectPublish?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationEmployeeNestedInput
  }

  export type NotificationPermissionEmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    returnProject?: BoolFieldUpdateOperationsInput | boolean
    assignNewProject?: BoolFieldUpdateOperationsInput | boolean
    projectPublish?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionEmployeeCreateManyInput = {
    id?: string
    userId: string
    returnProject?: boolean
    assignNewProject?: boolean
    projectPublish?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionEmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnProject?: BoolFieldUpdateOperationsInput | boolean
    assignNewProject?: BoolFieldUpdateOperationsInput | boolean
    projectPublish?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionEmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    returnProject?: BoolFieldUpdateOperationsInput | boolean
    assignNewProject?: BoolFieldUpdateOperationsInput | boolean
    projectPublish?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionManagerCreateInput = {
    id?: string
    fileImportByEmployees?: boolean
    weeklySummary?: boolean
    createNewProject?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationManagerInput
  }

  export type NotificationPermissionManagerUncheckedCreateInput = {
    id?: string
    userId: string
    fileImportByEmployees?: boolean
    weeklySummary?: boolean
    createNewProject?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionManagerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileImportByEmployees?: BoolFieldUpdateOperationsInput | boolean
    weeklySummary?: BoolFieldUpdateOperationsInput | boolean
    createNewProject?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationManagerNestedInput
  }

  export type NotificationPermissionManagerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fileImportByEmployees?: BoolFieldUpdateOperationsInput | boolean
    weeklySummary?: BoolFieldUpdateOperationsInput | boolean
    createNewProject?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionManagerCreateManyInput = {
    id?: string
    userId: string
    fileImportByEmployees?: boolean
    weeklySummary?: boolean
    createNewProject?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionManagerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileImportByEmployees?: BoolFieldUpdateOperationsInput | boolean
    weeklySummary?: BoolFieldUpdateOperationsInput | boolean
    createNewProject?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionManagerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fileImportByEmployees?: BoolFieldUpdateOperationsInput | boolean
    weeklySummary?: BoolFieldUpdateOperationsInput | boolean
    createNewProject?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionClientCreateInput = {
    id?: string
    onProjectApproval?: boolean
    onProjectRejection?: boolean
    fileImportByEmployees?: boolean
    weeklySummary?: boolean
    storageLimit?: boolean
    billPayment?: boolean
    overdueProject?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationClientInput
  }

  export type NotificationPermissionClientUncheckedCreateInput = {
    id?: string
    userId: string
    onProjectApproval?: boolean
    onProjectRejection?: boolean
    fileImportByEmployees?: boolean
    weeklySummary?: boolean
    storageLimit?: boolean
    billPayment?: boolean
    overdueProject?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    onProjectApproval?: BoolFieldUpdateOperationsInput | boolean
    onProjectRejection?: BoolFieldUpdateOperationsInput | boolean
    fileImportByEmployees?: BoolFieldUpdateOperationsInput | boolean
    weeklySummary?: BoolFieldUpdateOperationsInput | boolean
    storageLimit?: BoolFieldUpdateOperationsInput | boolean
    billPayment?: BoolFieldUpdateOperationsInput | boolean
    overdueProject?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationClientNestedInput
  }

  export type NotificationPermissionClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    onProjectApproval?: BoolFieldUpdateOperationsInput | boolean
    onProjectRejection?: BoolFieldUpdateOperationsInput | boolean
    fileImportByEmployees?: BoolFieldUpdateOperationsInput | boolean
    weeklySummary?: BoolFieldUpdateOperationsInput | boolean
    storageLimit?: BoolFieldUpdateOperationsInput | boolean
    billPayment?: BoolFieldUpdateOperationsInput | boolean
    overdueProject?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionClientCreateManyInput = {
    id?: string
    userId: string
    onProjectApproval?: boolean
    onProjectRejection?: boolean
    fileImportByEmployees?: boolean
    weeklySummary?: boolean
    storageLimit?: boolean
    billPayment?: boolean
    overdueProject?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    onProjectApproval?: BoolFieldUpdateOperationsInput | boolean
    onProjectRejection?: BoolFieldUpdateOperationsInput | boolean
    fileImportByEmployees?: BoolFieldUpdateOperationsInput | boolean
    weeklySummary?: BoolFieldUpdateOperationsInput | boolean
    storageLimit?: BoolFieldUpdateOperationsInput | boolean
    billPayment?: BoolFieldUpdateOperationsInput | boolean
    overdueProject?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    onProjectApproval?: BoolFieldUpdateOperationsInput | boolean
    onProjectRejection?: BoolFieldUpdateOperationsInput | boolean
    fileImportByEmployees?: BoolFieldUpdateOperationsInput | boolean
    weeklySummary?: BoolFieldUpdateOperationsInput | boolean
    storageLimit?: BoolFieldUpdateOperationsInput | boolean
    billPayment?: BoolFieldUpdateOperationsInput | boolean
    overdueProject?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionSupporterCreateInput = {
    id?: string
    assignNewProject?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationSupporterInput
  }

  export type NotificationPermissionSupporterUncheckedCreateInput = {
    id?: string
    userId: string
    assignNewProject?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionSupporterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignNewProject?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationSupporterNestedInput
  }

  export type NotificationPermissionSupporterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignNewProject?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionSupporterCreateManyInput = {
    id?: string
    userId: string
    assignNewProject?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionSupporterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignNewProject?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionSupporterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignNewProject?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionAdminCreateInput = {
    id?: string
    storageLimit?: boolean
    receivedPayment?: boolean
    createClient?: boolean
    createTicket?: boolean
    paymentCycleChange?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationAdminInput
  }

  export type NotificationPermissionAdminUncheckedCreateInput = {
    id?: string
    userId: string
    storageLimit?: boolean
    receivedPayment?: boolean
    createClient?: boolean
    createTicket?: boolean
    paymentCycleChange?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionAdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageLimit?: BoolFieldUpdateOperationsInput | boolean
    receivedPayment?: BoolFieldUpdateOperationsInput | boolean
    createClient?: BoolFieldUpdateOperationsInput | boolean
    createTicket?: BoolFieldUpdateOperationsInput | boolean
    paymentCycleChange?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationAdminNestedInput
  }

  export type NotificationPermissionAdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    storageLimit?: BoolFieldUpdateOperationsInput | boolean
    receivedPayment?: BoolFieldUpdateOperationsInput | boolean
    createClient?: BoolFieldUpdateOperationsInput | boolean
    createTicket?: BoolFieldUpdateOperationsInput | boolean
    paymentCycleChange?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionAdminCreateManyInput = {
    id?: string
    userId: string
    storageLimit?: boolean
    receivedPayment?: boolean
    createClient?: boolean
    createTicket?: boolean
    paymentCycleChange?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionAdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageLimit?: BoolFieldUpdateOperationsInput | boolean
    receivedPayment?: BoolFieldUpdateOperationsInput | boolean
    createClient?: BoolFieldUpdateOperationsInput | boolean
    createTicket?: BoolFieldUpdateOperationsInput | boolean
    paymentCycleChange?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionAdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    storageLimit?: BoolFieldUpdateOperationsInput | boolean
    receivedPayment?: BoolFieldUpdateOperationsInput | boolean
    createClient?: BoolFieldUpdateOperationsInput | boolean
    createTicket?: BoolFieldUpdateOperationsInput | boolean
    paymentCycleChange?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionSuperAdminCreateInput = {
    id?: string
    storageLimit?: boolean
    receivedPayment?: boolean
    createClient?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: SuperAdminCreateNestedOneWithoutNotificationPermissionSuperAdminInput
  }

  export type NotificationPermissionSuperAdminUncheckedCreateInput = {
    id?: string
    userId: string
    storageLimit?: boolean
    receivedPayment?: boolean
    createClient?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionSuperAdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageLimit?: BoolFieldUpdateOperationsInput | boolean
    receivedPayment?: BoolFieldUpdateOperationsInput | boolean
    createClient?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: SuperAdminUpdateOneRequiredWithoutNotificationPermissionSuperAdminNestedInput
  }

  export type NotificationPermissionSuperAdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    storageLimit?: BoolFieldUpdateOperationsInput | boolean
    receivedPayment?: BoolFieldUpdateOperationsInput | boolean
    createClient?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionSuperAdminCreateManyInput = {
    id?: string
    userId: string
    storageLimit?: boolean
    receivedPayment?: boolean
    createClient?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionSuperAdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageLimit?: BoolFieldUpdateOperationsInput | boolean
    receivedPayment?: BoolFieldUpdateOperationsInput | boolean
    createClient?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionSuperAdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    storageLimit?: BoolFieldUpdateOperationsInput | boolean
    receivedPayment?: BoolFieldUpdateOperationsInput | boolean
    createClient?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramCreateInput = {
    id?: string
    programName: string
    datetime: string
    programDescription: string
    priority: string
    deadline: string
    progress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutProgramsInput
    projects?: ProjectCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateInput = {
    id?: string
    userId: string
    programName: string
    datetime: string
    programDescription: string
    priority: string
    deadline: string
    progress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    programName?: StringFieldUpdateOperationsInput | string
    datetime?: StringFieldUpdateOperationsInput | string
    programDescription?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    deadline?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutProgramsNestedInput
    projects?: ProjectUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    programName?: StringFieldUpdateOperationsInput | string
    datetime?: StringFieldUpdateOperationsInput | string
    programDescription?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    deadline?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramCreateManyInput = {
    id?: string
    userId: string
    programName: string
    datetime: string
    programDescription: string
    priority: string
    deadline: string
    progress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    programName?: StringFieldUpdateOperationsInput | string
    datetime?: StringFieldUpdateOperationsInput | string
    programDescription?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    deadline?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    programName?: StringFieldUpdateOperationsInput | string
    datetime?: StringFieldUpdateOperationsInput | string
    programDescription?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    deadline?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    uploadbeforeday: string
    uploadCycle: $Enums.ProjectCycle
    description: string
    dataReceivedTime?: string | null
    beforeSubmitData?: number | null
    weakuploadData?: ProjectCreateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectCreatemonthlyuploadDataInput | string[]
    status?: $Enums.ProjectStatus
    priority: $Enums.Priority
    deadline: Date | string
    startDate?: Date | string | null
    progress?: number | null
    chartList?: ProjectCreatechartListInput | string[]
    estimatedCompletedDate?: Date | string | null
    currentRate?: string | null
    budget?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    latitude?: number | null
    longitude?: number | null
    program: ProgramCreateNestedOneWithoutProjectsInput
    manager: ManagerCreateNestedOneWithoutProjectsInput
    projectEmployees?: ProjectEmployeeCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    reviews?: ReviewCreateNestedManyWithoutProjectInput
    requestsToAddProjectMember?: RequestToAddProjectMemberCreateNestedManyWithoutProjectInput
    submitted?: SubmittedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    programId: string
    name: string
    uploadbeforeday: string
    uploadCycle: $Enums.ProjectCycle
    description: string
    dataReceivedTime?: string | null
    beforeSubmitData?: number | null
    weakuploadData?: ProjectCreateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectCreatemonthlyuploadDataInput | string[]
    status?: $Enums.ProjectStatus
    priority: $Enums.Priority
    deadline: Date | string
    managerId: string
    startDate?: Date | string | null
    progress?: number | null
    chartList?: ProjectCreatechartListInput | string[]
    estimatedCompletedDate?: Date | string | null
    currentRate?: string | null
    budget?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    latitude?: number | null
    longitude?: number | null
    projectEmployees?: ProjectEmployeeUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProjectInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    submitted?: SubmittedUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uploadbeforeday?: StringFieldUpdateOperationsInput | string
    uploadCycle?: EnumProjectCycleFieldUpdateOperationsInput | $Enums.ProjectCycle
    description?: StringFieldUpdateOperationsInput | string
    dataReceivedTime?: NullableStringFieldUpdateOperationsInput | string | null
    beforeSubmitData?: NullableIntFieldUpdateOperationsInput | number | null
    weakuploadData?: ProjectUpdateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectUpdatemonthlyuploadDataInput | string[]
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    chartList?: ProjectUpdatechartListInput | string[]
    estimatedCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentRate?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    program?: ProgramUpdateOneRequiredWithoutProjectsNestedInput
    manager?: ManagerUpdateOneRequiredWithoutProjectsNestedInput
    projectEmployees?: ProjectEmployeeUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    reviews?: ReviewUpdateManyWithoutProjectNestedInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUpdateManyWithoutProjectNestedInput
    submitted?: SubmittedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uploadbeforeday?: StringFieldUpdateOperationsInput | string
    uploadCycle?: EnumProjectCycleFieldUpdateOperationsInput | $Enums.ProjectCycle
    description?: StringFieldUpdateOperationsInput | string
    dataReceivedTime?: NullableStringFieldUpdateOperationsInput | string | null
    beforeSubmitData?: NullableIntFieldUpdateOperationsInput | number | null
    weakuploadData?: ProjectUpdateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectUpdatemonthlyuploadDataInput | string[]
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    chartList?: ProjectUpdatechartListInput | string[]
    estimatedCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentRate?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    projectEmployees?: ProjectEmployeeUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProjectNestedInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    submitted?: SubmittedUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    programId: string
    name: string
    uploadbeforeday: string
    uploadCycle: $Enums.ProjectCycle
    description: string
    dataReceivedTime?: string | null
    beforeSubmitData?: number | null
    weakuploadData?: ProjectCreateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectCreatemonthlyuploadDataInput | string[]
    status?: $Enums.ProjectStatus
    priority: $Enums.Priority
    deadline: Date | string
    managerId: string
    startDate?: Date | string | null
    progress?: number | null
    chartList?: ProjectCreatechartListInput | string[]
    estimatedCompletedDate?: Date | string | null
    currentRate?: string | null
    budget?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    latitude?: number | null
    longitude?: number | null
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uploadbeforeday?: StringFieldUpdateOperationsInput | string
    uploadCycle?: EnumProjectCycleFieldUpdateOperationsInput | $Enums.ProjectCycle
    description?: StringFieldUpdateOperationsInput | string
    dataReceivedTime?: NullableStringFieldUpdateOperationsInput | string | null
    beforeSubmitData?: NullableIntFieldUpdateOperationsInput | number | null
    weakuploadData?: ProjectUpdateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectUpdatemonthlyuploadDataInput | string[]
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    chartList?: ProjectUpdatechartListInput | string[]
    estimatedCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentRate?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uploadbeforeday?: StringFieldUpdateOperationsInput | string
    uploadCycle?: EnumProjectCycleFieldUpdateOperationsInput | $Enums.ProjectCycle
    description?: StringFieldUpdateOperationsInput | string
    dataReceivedTime?: NullableStringFieldUpdateOperationsInput | string | null
    beforeSubmitData?: NullableIntFieldUpdateOperationsInput | number | null
    weakuploadData?: ProjectUpdateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectUpdatemonthlyuploadDataInput | string[]
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    chartList?: ProjectUpdatechartListInput | string[]
    estimatedCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentRate?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ProjectEmployeeCreateInput = {
    id?: string
    assignedAt?: Date | string
    project: ProjectCreateNestedOneWithoutProjectEmployeesInput
    employee: EmployeeCreateNestedOneWithoutProjectEmployeesInput
  }

  export type ProjectEmployeeUncheckedCreateInput = {
    id?: string
    projectId: string
    employeeId: string
    assignedAt?: Date | string
  }

  export type ProjectEmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutProjectEmployeesNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutProjectEmployeesNestedInput
  }

  export type ProjectEmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectEmployeeCreateManyInput = {
    id?: string
    projectId: string
    employeeId: string
    assignedAt?: Date | string
  }

  export type ProjectEmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectEmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    taskAssignId?: string | null
    status: $Enums.ProjectStatus
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    projectId: string
    taskAssignId?: string | null
    status: $Enums.ProjectStatus
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskAssignId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    taskAssignId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    projectId: string
    taskAssignId?: string | null
    status: $Enums.ProjectStatus
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskAssignId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    taskAssignId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SheetCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    submitted?: SubmittedCreateNestedManyWithoutSheetInput
  }

  export type SheetUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    submitted?: SubmittedUncheckedCreateNestedManyWithoutSheetInput
  }

  export type SheetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submitted?: SubmittedUpdateManyWithoutSheetNestedInput
  }

  export type SheetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submitted?: SubmittedUncheckedUpdateManyWithoutSheetNestedInput
  }

  export type SheetCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SheetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SheetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionReturnCreateInput = {
    id?: string
    returnedAt?: Date | string
    submitted: SubmittedCreateNestedOneWithoutSubmissionReturnInput
  }

  export type SubmissionReturnUncheckedCreateInput = {
    id?: string
    submittedId: string
    returnedAt?: Date | string
  }

  export type SubmissionReturnUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submitted?: SubmittedUpdateOneRequiredWithoutSubmissionReturnNestedInput
  }

  export type SubmissionReturnUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    submittedId?: StringFieldUpdateOperationsInput | string
    returnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionReturnCreateManyInput = {
    id?: string
    submittedId: string
    returnedAt?: Date | string
  }

  export type SubmissionReturnUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionReturnUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    submittedId?: StringFieldUpdateOperationsInput | string
    returnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmittedCreateInput = {
    id?: string
    information: string
    submission: string
    status?: $Enums.SubmittedStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutSubmittedInput
    project: ProjectCreateNestedOneWithoutSubmittedInput
    sheet: SheetCreateNestedOneWithoutSubmittedInput
    submissionReturn?: SubmissionReturnCreateNestedOneWithoutSubmittedInput
  }

  export type SubmittedUncheckedCreateInput = {
    id?: string
    information: string
    submission: string
    status?: $Enums.SubmittedStatus
    employeeId: string
    projectId: string
    sheetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    submissionReturn?: SubmissionReturnUncheckedCreateNestedOneWithoutSubmittedInput
  }

  export type SubmittedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    submission?: StringFieldUpdateOperationsInput | string
    status?: EnumSubmittedStatusFieldUpdateOperationsInput | $Enums.SubmittedStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutSubmittedNestedInput
    project?: ProjectUpdateOneRequiredWithoutSubmittedNestedInput
    sheet?: SheetUpdateOneRequiredWithoutSubmittedNestedInput
    submissionReturn?: SubmissionReturnUpdateOneWithoutSubmittedNestedInput
  }

  export type SubmittedUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    submission?: StringFieldUpdateOperationsInput | string
    status?: EnumSubmittedStatusFieldUpdateOperationsInput | $Enums.SubmittedStatus
    employeeId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sheetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionReturn?: SubmissionReturnUncheckedUpdateOneWithoutSubmittedNestedInput
  }

  export type SubmittedCreateManyInput = {
    id?: string
    information: string
    submission: string
    status?: $Enums.SubmittedStatus
    employeeId: string
    projectId: string
    sheetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubmittedUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    submission?: StringFieldUpdateOperationsInput | string
    status?: EnumSubmittedStatusFieldUpdateOperationsInput | $Enums.SubmittedStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmittedUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    submission?: StringFieldUpdateOperationsInput | string
    status?: EnumSubmittedStatusFieldUpdateOperationsInput | $Enums.SubmittedStatus
    employeeId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sheetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuperAdminCreateInput = {
    id?: string
    clientLogo?: string | null
    favicon?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSuperAdminInput
    notificationPermissionSuperAdmin?: NotificationPermissionSuperAdminCreateNestedOneWithoutUserInput
  }

  export type SuperAdminUncheckedCreateInput = {
    id?: string
    userId: string
    clientLogo?: string | null
    favicon?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationPermissionSuperAdmin?: NotificationPermissionSuperAdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type SuperAdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSuperAdminNestedInput
    notificationPermissionSuperAdmin?: NotificationPermissionSuperAdminUpdateOneWithoutUserNestedInput
  }

  export type SuperAdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationPermissionSuperAdmin?: NotificationPermissionSuperAdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type SuperAdminCreateManyInput = {
    id?: string
    userId: string
    clientLogo?: string | null
    favicon?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuperAdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuperAdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupporterCreateInput = {
    id?: string
    supporterRole: $Enums.SupporterRole
    skills?: SupporterCreateskillsInput | string[]
    workload?: number | null
    workItems?: SupporterCreateworkItemsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSupporterInput
  }

  export type SupporterUncheckedCreateInput = {
    id?: string
    userId: string
    supporterRole: $Enums.SupporterRole
    skills?: SupporterCreateskillsInput | string[]
    workload?: number | null
    workItems?: SupporterCreateworkItemsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupporterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supporterRole?: EnumSupporterRoleFieldUpdateOperationsInput | $Enums.SupporterRole
    skills?: SupporterUpdateskillsInput | string[]
    workload?: NullableIntFieldUpdateOperationsInput | number | null
    workItems?: SupporterUpdateworkItemsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSupporterNestedInput
  }

  export type SupporterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    supporterRole?: EnumSupporterRoleFieldUpdateOperationsInput | $Enums.SupporterRole
    skills?: SupporterUpdateskillsInput | string[]
    workload?: NullableIntFieldUpdateOperationsInput | number | null
    workItems?: SupporterUpdateworkItemsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupporterCreateManyInput = {
    id?: string
    userId: string
    supporterRole: $Enums.SupporterRole
    skills?: SupporterCreateskillsInput | string[]
    workload?: number | null
    workItems?: SupporterCreateworkItemsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupporterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    supporterRole?: EnumSupporterRoleFieldUpdateOperationsInput | $Enums.SupporterRole
    skills?: SupporterUpdateskillsInput | string[]
    workload?: NullableIntFieldUpdateOperationsInput | number | null
    workItems?: SupporterUpdateworkItemsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupporterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    supporterRole?: EnumSupporterRoleFieldUpdateOperationsInput | $Enums.SupporterRole
    skills?: SupporterUpdateskillsInput | string[]
    workload?: NullableIntFieldUpdateOperationsInput | number | null
    workItems?: SupporterUpdateworkItemsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    id?: string
    status?: $Enums.TaskStatus | null
    name: string
    progress?: number | null
    dueDate?: string | null
    assignedTo: string
    assigneeType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    status?: $Enums.TaskStatus | null
    name: string
    projectId: string
    progress?: number | null
    dueDate?: string | null
    assignedTo: string
    assigneeType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus | null
    name?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    assigneeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus | null
    name?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    assigneeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyInput = {
    id?: string
    status?: $Enums.TaskStatus | null
    name: string
    projectId: string
    progress?: number | null
    dueDate?: string | null
    assignedTo: string
    assigneeType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus | null
    name?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    assigneeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus | null
    name?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    assigneeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateInput = {
    id?: string
    supporterIds?: TicketCreatesupporterIdsInput | string[]
    adminIds?: TicketCreateadminIdsInput | string[]
    companyName?: string | null
    subject: string
    status?: $Enums.TicketStatus
    priority: $Enums.Priority
    issue: string
    adminNote?: string | null
    attachFile?: string | null
    issueType: $Enums.IssueType
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateInput = {
    id?: string
    clientId: string
    supporterIds?: TicketCreatesupporterIdsInput | string[]
    adminIds?: TicketCreateadminIdsInput | string[]
    companyName?: string | null
    subject: string
    status?: $Enums.TicketStatus
    priority: $Enums.Priority
    issue: string
    adminNote?: string | null
    attachFile?: string | null
    issueType: $Enums.IssueType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supporterIds?: TicketUpdatesupporterIdsInput | string[]
    adminIds?: TicketUpdateadminIdsInput | string[]
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    issue?: StringFieldUpdateOperationsInput | string
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    attachFile?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    supporterIds?: TicketUpdatesupporterIdsInput | string[]
    adminIds?: TicketUpdateadminIdsInput | string[]
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    issue?: StringFieldUpdateOperationsInput | string
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    attachFile?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateManyInput = {
    id?: string
    clientId: string
    supporterIds?: TicketCreatesupporterIdsInput | string[]
    adminIds?: TicketCreateadminIdsInput | string[]
    companyName?: string | null
    subject: string
    status?: $Enums.TicketStatus
    priority: $Enums.Priority
    issue: string
    adminNote?: string | null
    attachFile?: string | null
    issueType: $Enums.IssueType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    supporterIds?: TicketUpdatesupporterIdsInput | string[]
    adminIds?: TicketUpdateadminIdsInput | string[]
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    issue?: StringFieldUpdateOperationsInput | string
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    attachFile?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    supporterIds?: TicketUpdatesupporterIdsInput | string[]
    adminIds?: TicketUpdateadminIdsInput | string[]
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    issue?: StringFieldUpdateOperationsInput | string
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    attachFile?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientCreateNestedOneWithoutUserInput
    manager?: ManagerCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    viewer?: ViewerCreateNestedOneWithoutUserInput
    supporter?: SupporterCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    viewer?: ViewerUncheckedCreateNestedOneWithoutUserInput
    supporter?: SupporterUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerUncheckedCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientUncheckedCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionUncheckedCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUpdateOneWithoutUserNestedInput
    manager?: ManagerUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    viewer?: ViewerUpdateOneWithoutUserNestedInput
    supporter?: SupporterUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    viewer?: ViewerUncheckedUpdateOneWithoutUserNestedInput
    supporter?: SupporterUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUncheckedUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUncheckedUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUncheckedUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
  }

  export type TagCreateInput = {
    tags?: TagCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutTagsInput
  }

  export type TagUncheckedCreateInput = {
    clientId: string
    tags?: TagCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateInput = {
    tags?: TagUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    tags?: TagUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateManyInput = {
    clientId: string
    tags?: TagCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    tags?: TagUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    tags?: TagUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferredPersonCreateInput = {
    id?: string
    name: string
    email?: string | null
    phoneNumber?: number | null
    aboutThere?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutReferredPersonsInput
  }

  export type ReferredPersonUncheckedCreateInput = {
    id?: string
    name: string
    userId: string
    email?: string | null
    phoneNumber?: number | null
    aboutThere?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferredPersonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    aboutThere?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutReferredPersonsNestedInput
  }

  export type ReferredPersonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    aboutThere?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferredPersonCreateManyInput = {
    id?: string
    name: string
    userId: string
    email?: string | null
    phoneNumber?: number | null
    aboutThere?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferredPersonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    aboutThere?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferredPersonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    aboutThere?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestToAddProjectMemberCreateInput = {
    id?: string
    clientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutRequestsToAddProjectMemberInput
    manager: ManagerCreateNestedOneWithoutRequestsToAddProjectMemberInput
  }

  export type RequestToAddProjectMemberUncheckedCreateInput = {
    id?: string
    clientId?: string | null
    projectId: string
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestToAddProjectMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutRequestsToAddProjectMemberNestedInput
    manager?: ManagerUpdateOneRequiredWithoutRequestsToAddProjectMemberNestedInput
  }

  export type RequestToAddProjectMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestToAddProjectMemberCreateManyInput = {
    id?: string
    clientId?: string | null
    projectId: string
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestToAddProjectMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestToAddProjectMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewerCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutViewerInput
  }

  export type ViewerUncheckedCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViewerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutViewerNestedInput
  }

  export type ViewerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewerCreateManyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViewerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumActivityActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityActionType | EnumActivityActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityActionType[] | ListEnumActivityActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityActionType[] | ListEnumActivityActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityActionTypeFilter<$PrismaModel> | $Enums.ActivityActionType
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    projectId?: SortOrder
    ipAddress?: SortOrder
    actionType?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    projectId?: SortOrder
    ipAddress?: SortOrder
    actionType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    projectId?: SortOrder
    ipAddress?: SortOrder
    actionType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumActivityActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityActionType | EnumActivityActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityActionType[] | ListEnumActivityActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityActionType[] | ListEnumActivityActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityActionTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityActionTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumIndustryCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.IndustryCategory | EnumIndustryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.IndustryCategory[] | ListEnumIndustryCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.IndustryCategory[] | ListEnumIndustryCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumIndustryCategoryFilter<$PrismaModel> | $Enums.IndustryCategory
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ReferredPersonListRelationFilter = {
    every?: ReferredPersonWhereInput
    some?: ReferredPersonWhereInput
    none?: ReferredPersonWhereInput
  }

  export type TicketListRelationFilter = {
    every?: TicketWhereInput
    some?: TicketWhereInput
    none?: TicketWhereInput
  }

  export type ProgramListRelationFilter = {
    every?: ProgramWhereInput
    some?: ProgramWhereInput
    none?: ProgramWhereInput
  }

  export type TagNullableScalarRelationFilter = {
    is?: TagWhereInput | null
    isNot?: TagWhereInput | null
  }

  export type ReferredPersonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    contactPersonName?: SortOrder
    clientLogo?: SortOrder
    favicon?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    footerText?: SortOrder
    supportMail?: SortOrder
    subdomain?: SortOrder
    serverLocation?: SortOrder
    category?: SortOrder
    onboarding?: SortOrder
    welcomeDashboard?: SortOrder
    chartList?: SortOrder
    storage?: SortOrder
    threshold?: SortOrder
    archiveAfter?: SortOrder
    userWarning?: SortOrder
    adminNote?: SortOrder
    trialPeriod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientAvgOrderByAggregateInput = {
    threshold?: SortOrder
    archiveAfter?: SortOrder
    trialPeriod?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    contactPersonName?: SortOrder
    clientLogo?: SortOrder
    favicon?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    footerText?: SortOrder
    supportMail?: SortOrder
    subdomain?: SortOrder
    serverLocation?: SortOrder
    category?: SortOrder
    onboarding?: SortOrder
    welcomeDashboard?: SortOrder
    storage?: SortOrder
    threshold?: SortOrder
    archiveAfter?: SortOrder
    userWarning?: SortOrder
    adminNote?: SortOrder
    trialPeriod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    contactPersonName?: SortOrder
    clientLogo?: SortOrder
    favicon?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    footerText?: SortOrder
    supportMail?: SortOrder
    subdomain?: SortOrder
    serverLocation?: SortOrder
    category?: SortOrder
    onboarding?: SortOrder
    welcomeDashboard?: SortOrder
    storage?: SortOrder
    threshold?: SortOrder
    archiveAfter?: SortOrder
    userWarning?: SortOrder
    adminNote?: SortOrder
    trialPeriod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientSumOrderByAggregateInput = {
    threshold?: SortOrder
    archiveAfter?: SortOrder
    trialPeriod?: SortOrder
  }

  export type EnumIndustryCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IndustryCategory | EnumIndustryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.IndustryCategory[] | ListEnumIndustryCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.IndustryCategory[] | ListEnumIndustryCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumIndustryCategoryWithAggregatesFilter<$PrismaModel> | $Enums.IndustryCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIndustryCategoryFilter<$PrismaModel>
    _max?: NestedEnumIndustryCategoryFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ProjectEmployeeListRelationFilter = {
    every?: ProjectEmployeeWhereInput
    some?: ProjectEmployeeWhereInput
    none?: ProjectEmployeeWhereInput
  }

  export type SubmittedListRelationFilter = {
    every?: SubmittedWhereInput
    some?: SubmittedWhereInput
    none?: SubmittedWhereInput
  }

  export type ProjectEmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubmittedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    joinedDate?: SortOrder
    skills?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    joinedDate?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    joinedDate?: SortOrder
  }

  export type OtpVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type OtpVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type OtpVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type RequestToAddProjectMemberListRelationFilter = {
    every?: RequestToAddProjectMemberWhereInput
    some?: RequestToAddProjectMemberWhereInput
    none?: RequestToAddProjectMemberWhereInput
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestToAddProjectMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ManagerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    skills?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    joinedDate?: SortOrder
  }

  export type ManagerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    joinedDate?: SortOrder
  }

  export type ManagerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    joinedDate?: SortOrder
  }

  export type NotificationProvisionListRelationFilter = {
    every?: NotificationProvisionWhereInput
    some?: NotificationProvisionWhereInput
    none?: NotificationProvisionWhereInput
  }

  export type NotificationProvisionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverIds?: SortOrder
    context?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    context?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    context?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationScalarRelationFilter = {
    is?: NotificationWhereInput
    isNot?: NotificationWhereInput
  }

  export type NotificationProvisionUserIdNotificationIdCompoundUniqueInput = {
    userId: string
    notificationId: string
  }

  export type NotificationProvisionCountOrderByAggregateInput = {
    userId?: SortOrder
    notificationId?: SortOrder
  }

  export type NotificationProvisionMaxOrderByAggregateInput = {
    userId?: SortOrder
    notificationId?: SortOrder
  }

  export type NotificationProvisionMinOrderByAggregateInput = {
    userId?: SortOrder
    notificationId?: SortOrder
  }

  export type NotificationPermissionEmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    returnProject?: SortOrder
    assignNewProject?: SortOrder
    projectPublish?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPermissionEmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    returnProject?: SortOrder
    assignNewProject?: SortOrder
    projectPublish?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPermissionEmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    returnProject?: SortOrder
    assignNewProject?: SortOrder
    projectPublish?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPermissionManagerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fileImportByEmployees?: SortOrder
    weeklySummary?: SortOrder
    createNewProject?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPermissionManagerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fileImportByEmployees?: SortOrder
    weeklySummary?: SortOrder
    createNewProject?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPermissionManagerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fileImportByEmployees?: SortOrder
    weeklySummary?: SortOrder
    createNewProject?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPermissionClientCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    onProjectApproval?: SortOrder
    onProjectRejection?: SortOrder
    fileImportByEmployees?: SortOrder
    weeklySummary?: SortOrder
    storageLimit?: SortOrder
    billPayment?: SortOrder
    overdueProject?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPermissionClientMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    onProjectApproval?: SortOrder
    onProjectRejection?: SortOrder
    fileImportByEmployees?: SortOrder
    weeklySummary?: SortOrder
    storageLimit?: SortOrder
    billPayment?: SortOrder
    overdueProject?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPermissionClientMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    onProjectApproval?: SortOrder
    onProjectRejection?: SortOrder
    fileImportByEmployees?: SortOrder
    weeklySummary?: SortOrder
    storageLimit?: SortOrder
    billPayment?: SortOrder
    overdueProject?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPermissionSupporterCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assignNewProject?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPermissionSupporterMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assignNewProject?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPermissionSupporterMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assignNewProject?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPermissionAdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storageLimit?: SortOrder
    receivedPayment?: SortOrder
    createClient?: SortOrder
    createTicket?: SortOrder
    paymentCycleChange?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPermissionAdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storageLimit?: SortOrder
    receivedPayment?: SortOrder
    createClient?: SortOrder
    createTicket?: SortOrder
    paymentCycleChange?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPermissionAdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storageLimit?: SortOrder
    receivedPayment?: SortOrder
    createClient?: SortOrder
    createTicket?: SortOrder
    paymentCycleChange?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuperAdminScalarRelationFilter = {
    is?: SuperAdminWhereInput
    isNot?: SuperAdminWhereInput
  }

  export type NotificationPermissionSuperAdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storageLimit?: SortOrder
    receivedPayment?: SortOrder
    createClient?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPermissionSuperAdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storageLimit?: SortOrder
    receivedPayment?: SortOrder
    createClient?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPermissionSuperAdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storageLimit?: SortOrder
    receivedPayment?: SortOrder
    createClient?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type ProgramCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    programName?: SortOrder
    datetime?: SortOrder
    programDescription?: SortOrder
    priority?: SortOrder
    deadline?: SortOrder
    progress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type ProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    programName?: SortOrder
    datetime?: SortOrder
    programDescription?: SortOrder
    priority?: SortOrder
    deadline?: SortOrder
    progress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    programName?: SortOrder
    datetime?: SortOrder
    programDescription?: SortOrder
    priority?: SortOrder
    deadline?: SortOrder
    progress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type EnumProjectCycleFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectCycle | EnumProjectCycleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectCycle[] | ListEnumProjectCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectCycle[] | ListEnumProjectCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectCycleFilter<$PrismaModel> | $Enums.ProjectCycle
  }

  export type EnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ProgramScalarRelationFilter = {
    is?: ProgramWhereInput
    isNot?: ProgramWhereInput
  }

  export type ManagerScalarRelationFilter = {
    is?: ManagerWhereInput
    isNot?: ManagerWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    name?: SortOrder
    uploadbeforeday?: SortOrder
    uploadCycle?: SortOrder
    description?: SortOrder
    dataReceivedTime?: SortOrder
    beforeSubmitData?: SortOrder
    weakuploadData?: SortOrder
    monthlyuploadData?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    deadline?: SortOrder
    managerId?: SortOrder
    startDate?: SortOrder
    progress?: SortOrder
    chartList?: SortOrder
    estimatedCompletedDate?: SortOrder
    currentRate?: SortOrder
    budget?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    beforeSubmitData?: SortOrder
    progress?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    name?: SortOrder
    uploadbeforeday?: SortOrder
    uploadCycle?: SortOrder
    description?: SortOrder
    dataReceivedTime?: SortOrder
    beforeSubmitData?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    deadline?: SortOrder
    managerId?: SortOrder
    startDate?: SortOrder
    progress?: SortOrder
    estimatedCompletedDate?: SortOrder
    currentRate?: SortOrder
    budget?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    name?: SortOrder
    uploadbeforeday?: SortOrder
    uploadCycle?: SortOrder
    description?: SortOrder
    dataReceivedTime?: SortOrder
    beforeSubmitData?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    deadline?: SortOrder
    managerId?: SortOrder
    startDate?: SortOrder
    progress?: SortOrder
    estimatedCompletedDate?: SortOrder
    currentRate?: SortOrder
    budget?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    beforeSubmitData?: SortOrder
    progress?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type EnumProjectCycleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectCycle | EnumProjectCycleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectCycle[] | ListEnumProjectCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectCycle[] | ListEnumProjectCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectCycleWithAggregatesFilter<$PrismaModel> | $Enums.ProjectCycle
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectCycleFilter<$PrismaModel>
    _max?: NestedEnumProjectCycleFilter<$PrismaModel>
  }

  export type EnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type ProjectEmployeeProjectIdEmployeeIdCompoundUniqueInput = {
    projectId: string
    employeeId: string
  }

  export type ProjectEmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    employeeId?: SortOrder
    assignedAt?: SortOrder
  }

  export type ProjectEmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    employeeId?: SortOrder
    assignedAt?: SortOrder
  }

  export type ProjectEmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    employeeId?: SortOrder
    assignedAt?: SortOrder
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    taskAssignId?: SortOrder
    status?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    taskAssignId?: SortOrder
    status?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    taskAssignId?: SortOrder
    status?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SheetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SheetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SheetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubmittedScalarRelationFilter = {
    is?: SubmittedWhereInput
    isNot?: SubmittedWhereInput
  }

  export type SubmissionReturnCountOrderByAggregateInput = {
    id?: SortOrder
    submittedId?: SortOrder
    returnedAt?: SortOrder
  }

  export type SubmissionReturnMaxOrderByAggregateInput = {
    id?: SortOrder
    submittedId?: SortOrder
    returnedAt?: SortOrder
  }

  export type SubmissionReturnMinOrderByAggregateInput = {
    id?: SortOrder
    submittedId?: SortOrder
    returnedAt?: SortOrder
  }

  export type EnumSubmittedStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmittedStatus | EnumSubmittedStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmittedStatus[] | ListEnumSubmittedStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmittedStatus[] | ListEnumSubmittedStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmittedStatusFilter<$PrismaModel> | $Enums.SubmittedStatus
  }

  export type SheetScalarRelationFilter = {
    is?: SheetWhereInput
    isNot?: SheetWhereInput
  }

  export type SubmissionReturnNullableScalarRelationFilter = {
    is?: SubmissionReturnWhereInput | null
    isNot?: SubmissionReturnWhereInput | null
  }

  export type SubmittedCountOrderByAggregateInput = {
    id?: SortOrder
    information?: SortOrder
    submission?: SortOrder
    status?: SortOrder
    employeeId?: SortOrder
    projectId?: SortOrder
    sheetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubmittedMaxOrderByAggregateInput = {
    id?: SortOrder
    information?: SortOrder
    submission?: SortOrder
    status?: SortOrder
    employeeId?: SortOrder
    projectId?: SortOrder
    sheetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubmittedMinOrderByAggregateInput = {
    id?: SortOrder
    information?: SortOrder
    submission?: SortOrder
    status?: SortOrder
    employeeId?: SortOrder
    projectId?: SortOrder
    sheetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSubmittedStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmittedStatus | EnumSubmittedStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmittedStatus[] | ListEnumSubmittedStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmittedStatus[] | ListEnumSubmittedStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmittedStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubmittedStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubmittedStatusFilter<$PrismaModel>
    _max?: NestedEnumSubmittedStatusFilter<$PrismaModel>
  }

  export type NotificationPermissionSuperAdminNullableScalarRelationFilter = {
    is?: NotificationPermissionSuperAdminWhereInput | null
    isNot?: NotificationPermissionSuperAdminWhereInput | null
  }

  export type SuperAdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clientLogo?: SortOrder
    favicon?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuperAdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clientLogo?: SortOrder
    favicon?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuperAdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clientLogo?: SortOrder
    favicon?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSupporterRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.SupporterRole | EnumSupporterRoleFieldRefInput<$PrismaModel>
    in?: $Enums.SupporterRole[] | ListEnumSupporterRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupporterRole[] | ListEnumSupporterRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumSupporterRoleFilter<$PrismaModel> | $Enums.SupporterRole
  }

  export type SupporterCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    supporterRole?: SortOrder
    skills?: SortOrder
    workload?: SortOrder
    workItems?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupporterAvgOrderByAggregateInput = {
    workload?: SortOrder
  }

  export type SupporterMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    supporterRole?: SortOrder
    workload?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupporterMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    supporterRole?: SortOrder
    workload?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupporterSumOrderByAggregateInput = {
    workload?: SortOrder
  }

  export type EnumSupporterRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SupporterRole | EnumSupporterRoleFieldRefInput<$PrismaModel>
    in?: $Enums.SupporterRole[] | ListEnumSupporterRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupporterRole[] | ListEnumSupporterRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumSupporterRoleWithAggregatesFilter<$PrismaModel> | $Enums.SupporterRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSupporterRoleFilter<$PrismaModel>
    _max?: NestedEnumSupporterRoleFilter<$PrismaModel>
  }

  export type EnumTaskStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskStatusNullableFilter<$PrismaModel> | $Enums.TaskStatus | null
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    progress?: SortOrder
    dueDate?: SortOrder
    assignedTo?: SortOrder
    assigneeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    progress?: SortOrder
    dueDate?: SortOrder
    assignedTo?: SortOrder
    assigneeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    progress?: SortOrder
    dueDate?: SortOrder
    assignedTo?: SortOrder
    assigneeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type EnumTaskStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusNullableFilter<$PrismaModel>
  }

  export type EnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type EnumIssueTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IssueType | EnumIssueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IssueType[] | ListEnumIssueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssueType[] | ListEnumIssueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIssueTypeFilter<$PrismaModel> | $Enums.IssueType
  }

  export type TicketCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    supporterIds?: SortOrder
    adminIds?: SortOrder
    companyName?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    issue?: SortOrder
    adminNote?: SortOrder
    attachFile?: SortOrder
    issueType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    companyName?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    issue?: SortOrder
    adminNote?: SortOrder
    attachFile?: SortOrder
    issueType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    companyName?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    issue?: SortOrder
    adminNote?: SortOrder
    attachFile?: SortOrder
    issueType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type EnumIssueTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IssueType | EnumIssueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IssueType[] | ListEnumIssueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssueType[] | ListEnumIssueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIssueTypeWithAggregatesFilter<$PrismaModel> | $Enums.IssueType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIssueTypeFilter<$PrismaModel>
    _max?: NestedEnumIssueTypeFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type EnumLanguageFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageFilter<$PrismaModel> | $Enums.Language
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type ManagerNullableScalarRelationFilter = {
    is?: ManagerWhereInput | null
    isNot?: ManagerWhereInput | null
  }

  export type EmployeeNullableScalarRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type ViewerNullableScalarRelationFilter = {
    is?: ViewerWhereInput | null
    isNot?: ViewerWhereInput | null
  }

  export type SupporterNullableScalarRelationFilter = {
    is?: SupporterWhereInput | null
    isNot?: SupporterWhereInput | null
  }

  export type SuperAdminNullableScalarRelationFilter = {
    is?: SuperAdminWhereInput | null
    isNot?: SuperAdminWhereInput | null
  }

  export type NotificationPermissionEmployeeNullableScalarRelationFilter = {
    is?: NotificationPermissionEmployeeWhereInput | null
    isNot?: NotificationPermissionEmployeeWhereInput | null
  }

  export type NotificationPermissionManagerNullableScalarRelationFilter = {
    is?: NotificationPermissionManagerWhereInput | null
    isNot?: NotificationPermissionManagerWhereInput | null
  }

  export type NotificationPermissionClientNullableScalarRelationFilter = {
    is?: NotificationPermissionClientWhereInput | null
    isNot?: NotificationPermissionClientWhereInput | null
  }

  export type NotificationPermissionSupporterNullableScalarRelationFilter = {
    is?: NotificationPermissionSupporterWhereInput | null
    isNot?: NotificationPermissionSupporterWhereInput | null
  }

  export type NotificationPermissionAdminNullableScalarRelationFilter = {
    is?: NotificationPermissionAdminWhereInput | null
    isNot?: NotificationPermissionAdminWhereInput | null
  }

  export type OtpVerificationNullableScalarRelationFilter = {
    is?: OtpVerificationWhereInput | null
    isNot?: OtpVerificationWhereInput | null
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    profileImage?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    verification2FA?: SortOrder
    status?: SortOrder
    lastActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userStatus?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    profileImage?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    verification2FA?: SortOrder
    status?: SortOrder
    lastActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userStatus?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    profileImage?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    verification2FA?: SortOrder
    status?: SortOrder
    lastActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userStatus?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumLanguageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageWithAggregatesFilter<$PrismaModel> | $Enums.Language
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLanguageFilter<$PrismaModel>
    _max?: NestedEnumLanguageFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type TagCountOrderByAggregateInput = {
    clientId?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferredPersonCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    aboutThere?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferredPersonAvgOrderByAggregateInput = {
    phoneNumber?: SortOrder
  }

  export type ReferredPersonMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    aboutThere?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferredPersonMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    aboutThere?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferredPersonSumOrderByAggregateInput = {
    phoneNumber?: SortOrder
  }

  export type RequestToAddProjectMemberCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequestToAddProjectMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequestToAddProjectMemberMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    projectId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ViewerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ViewerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ViewerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<ProjectCreateWithoutActivitiesInput, ProjectUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutActivitiesInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumActivityActionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActivityActionType
  }

  export type ProjectUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<ProjectCreateWithoutActivitiesInput, ProjectUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutActivitiesInput
    upsert?: ProjectUpsertWithoutActivitiesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutActivitiesInput, ProjectUpdateWithoutActivitiesInput>, ProjectUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    upsert?: UserUpsertWithoutActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivitiesInput, UserUpdateWithoutActivitiesInput>, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type ClientCreatechartListInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutClientInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientInput
    connect?: UserWhereUniqueInput
  }

  export type ReferredPersonCreateNestedManyWithoutClientInput = {
    create?: XOR<ReferredPersonCreateWithoutClientInput, ReferredPersonUncheckedCreateWithoutClientInput> | ReferredPersonCreateWithoutClientInput[] | ReferredPersonUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReferredPersonCreateOrConnectWithoutClientInput | ReferredPersonCreateOrConnectWithoutClientInput[]
    createMany?: ReferredPersonCreateManyClientInputEnvelope
    connect?: ReferredPersonWhereUniqueInput | ReferredPersonWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutClientInput = {
    create?: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput> | TicketCreateWithoutClientInput[] | TicketUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClientInput | TicketCreateOrConnectWithoutClientInput[]
    createMany?: TicketCreateManyClientInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type ProgramCreateNestedManyWithoutClientInput = {
    create?: XOR<ProgramCreateWithoutClientInput, ProgramUncheckedCreateWithoutClientInput> | ProgramCreateWithoutClientInput[] | ProgramUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutClientInput | ProgramCreateOrConnectWithoutClientInput[]
    createMany?: ProgramCreateManyClientInputEnvelope
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
  }

  export type TagCreateNestedOneWithoutClientInput = {
    create?: XOR<TagCreateWithoutClientInput, TagUncheckedCreateWithoutClientInput>
    connectOrCreate?: TagCreateOrConnectWithoutClientInput
    connect?: TagWhereUniqueInput
  }

  export type ReferredPersonUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ReferredPersonCreateWithoutClientInput, ReferredPersonUncheckedCreateWithoutClientInput> | ReferredPersonCreateWithoutClientInput[] | ReferredPersonUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReferredPersonCreateOrConnectWithoutClientInput | ReferredPersonCreateOrConnectWithoutClientInput[]
    createMany?: ReferredPersonCreateManyClientInputEnvelope
    connect?: ReferredPersonWhereUniqueInput | ReferredPersonWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput> | TicketCreateWithoutClientInput[] | TicketUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClientInput | TicketCreateOrConnectWithoutClientInput[]
    createMany?: TicketCreateManyClientInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type ProgramUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ProgramCreateWithoutClientInput, ProgramUncheckedCreateWithoutClientInput> | ProgramCreateWithoutClientInput[] | ProgramUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutClientInput | ProgramCreateOrConnectWithoutClientInput[]
    createMany?: ProgramCreateManyClientInputEnvelope
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedOneWithoutClientInput = {
    create?: XOR<TagCreateWithoutClientInput, TagUncheckedCreateWithoutClientInput>
    connectOrCreate?: TagCreateOrConnectWithoutClientInput
    connect?: TagWhereUniqueInput
  }

  export type EnumIndustryCategoryFieldUpdateOperationsInput = {
    set?: $Enums.IndustryCategory
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ClientUpdatechartListInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutClientNestedInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientInput
    upsert?: UserUpsertWithoutClientInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientInput, UserUpdateWithoutClientInput>, UserUncheckedUpdateWithoutClientInput>
  }

  export type ReferredPersonUpdateManyWithoutClientNestedInput = {
    create?: XOR<ReferredPersonCreateWithoutClientInput, ReferredPersonUncheckedCreateWithoutClientInput> | ReferredPersonCreateWithoutClientInput[] | ReferredPersonUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReferredPersonCreateOrConnectWithoutClientInput | ReferredPersonCreateOrConnectWithoutClientInput[]
    upsert?: ReferredPersonUpsertWithWhereUniqueWithoutClientInput | ReferredPersonUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ReferredPersonCreateManyClientInputEnvelope
    set?: ReferredPersonWhereUniqueInput | ReferredPersonWhereUniqueInput[]
    disconnect?: ReferredPersonWhereUniqueInput | ReferredPersonWhereUniqueInput[]
    delete?: ReferredPersonWhereUniqueInput | ReferredPersonWhereUniqueInput[]
    connect?: ReferredPersonWhereUniqueInput | ReferredPersonWhereUniqueInput[]
    update?: ReferredPersonUpdateWithWhereUniqueWithoutClientInput | ReferredPersonUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ReferredPersonUpdateManyWithWhereWithoutClientInput | ReferredPersonUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ReferredPersonScalarWhereInput | ReferredPersonScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutClientNestedInput = {
    create?: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput> | TicketCreateWithoutClientInput[] | TicketUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClientInput | TicketCreateOrConnectWithoutClientInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutClientInput | TicketUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: TicketCreateManyClientInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutClientInput | TicketUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutClientInput | TicketUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type ProgramUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProgramCreateWithoutClientInput, ProgramUncheckedCreateWithoutClientInput> | ProgramCreateWithoutClientInput[] | ProgramUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutClientInput | ProgramCreateOrConnectWithoutClientInput[]
    upsert?: ProgramUpsertWithWhereUniqueWithoutClientInput | ProgramUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProgramCreateManyClientInputEnvelope
    set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    update?: ProgramUpdateWithWhereUniqueWithoutClientInput | ProgramUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProgramUpdateManyWithWhereWithoutClientInput | ProgramUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
  }

  export type TagUpdateOneWithoutClientNestedInput = {
    create?: XOR<TagCreateWithoutClientInput, TagUncheckedCreateWithoutClientInput>
    connectOrCreate?: TagCreateOrConnectWithoutClientInput
    upsert?: TagUpsertWithoutClientInput
    disconnect?: TagWhereInput | boolean
    delete?: TagWhereInput | boolean
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutClientInput, TagUpdateWithoutClientInput>, TagUncheckedUpdateWithoutClientInput>
  }

  export type ReferredPersonUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ReferredPersonCreateWithoutClientInput, ReferredPersonUncheckedCreateWithoutClientInput> | ReferredPersonCreateWithoutClientInput[] | ReferredPersonUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReferredPersonCreateOrConnectWithoutClientInput | ReferredPersonCreateOrConnectWithoutClientInput[]
    upsert?: ReferredPersonUpsertWithWhereUniqueWithoutClientInput | ReferredPersonUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ReferredPersonCreateManyClientInputEnvelope
    set?: ReferredPersonWhereUniqueInput | ReferredPersonWhereUniqueInput[]
    disconnect?: ReferredPersonWhereUniqueInput | ReferredPersonWhereUniqueInput[]
    delete?: ReferredPersonWhereUniqueInput | ReferredPersonWhereUniqueInput[]
    connect?: ReferredPersonWhereUniqueInput | ReferredPersonWhereUniqueInput[]
    update?: ReferredPersonUpdateWithWhereUniqueWithoutClientInput | ReferredPersonUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ReferredPersonUpdateManyWithWhereWithoutClientInput | ReferredPersonUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ReferredPersonScalarWhereInput | ReferredPersonScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput> | TicketCreateWithoutClientInput[] | TicketUncheckedCreateWithoutClientInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutClientInput | TicketCreateOrConnectWithoutClientInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutClientInput | TicketUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: TicketCreateManyClientInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutClientInput | TicketUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutClientInput | TicketUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type ProgramUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProgramCreateWithoutClientInput, ProgramUncheckedCreateWithoutClientInput> | ProgramCreateWithoutClientInput[] | ProgramUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutClientInput | ProgramCreateOrConnectWithoutClientInput[]
    upsert?: ProgramUpsertWithWhereUniqueWithoutClientInput | ProgramUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProgramCreateManyClientInputEnvelope
    set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    update?: ProgramUpdateWithWhereUniqueWithoutClientInput | ProgramUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProgramUpdateManyWithWhereWithoutClientInput | ProgramUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
  }

  export type TagUncheckedUpdateOneWithoutClientNestedInput = {
    create?: XOR<TagCreateWithoutClientInput, TagUncheckedCreateWithoutClientInput>
    connectOrCreate?: TagCreateOrConnectWithoutClientInput
    upsert?: TagUpsertWithoutClientInput
    disconnect?: TagWhereInput | boolean
    delete?: TagWhereInput | boolean
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutClientInput, TagUpdateWithoutClientInput>, TagUncheckedUpdateWithoutClientInput>
  }

  export type EmployeeCreateskillsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectEmployeeCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ProjectEmployeeCreateWithoutEmployeeInput, ProjectEmployeeUncheckedCreateWithoutEmployeeInput> | ProjectEmployeeCreateWithoutEmployeeInput[] | ProjectEmployeeUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ProjectEmployeeCreateOrConnectWithoutEmployeeInput | ProjectEmployeeCreateOrConnectWithoutEmployeeInput[]
    createMany?: ProjectEmployeeCreateManyEmployeeInputEnvelope
    connect?: ProjectEmployeeWhereUniqueInput | ProjectEmployeeWhereUniqueInput[]
  }

  export type SubmittedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<SubmittedCreateWithoutEmployeeInput, SubmittedUncheckedCreateWithoutEmployeeInput> | SubmittedCreateWithoutEmployeeInput[] | SubmittedUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SubmittedCreateOrConnectWithoutEmployeeInput | SubmittedCreateOrConnectWithoutEmployeeInput[]
    createMany?: SubmittedCreateManyEmployeeInputEnvelope
    connect?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
  }

  export type ProjectEmployeeUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ProjectEmployeeCreateWithoutEmployeeInput, ProjectEmployeeUncheckedCreateWithoutEmployeeInput> | ProjectEmployeeCreateWithoutEmployeeInput[] | ProjectEmployeeUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ProjectEmployeeCreateOrConnectWithoutEmployeeInput | ProjectEmployeeCreateOrConnectWithoutEmployeeInput[]
    createMany?: ProjectEmployeeCreateManyEmployeeInputEnvelope
    connect?: ProjectEmployeeWhereUniqueInput | ProjectEmployeeWhereUniqueInput[]
  }

  export type SubmittedUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<SubmittedCreateWithoutEmployeeInput, SubmittedUncheckedCreateWithoutEmployeeInput> | SubmittedCreateWithoutEmployeeInput[] | SubmittedUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SubmittedCreateOrConnectWithoutEmployeeInput | SubmittedCreateOrConnectWithoutEmployeeInput[]
    createMany?: SubmittedCreateManyEmployeeInputEnvelope
    connect?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
  }

  export type EmployeeUpdateskillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutEmployeeNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    upsert?: UserUpsertWithoutEmployeeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeInput, UserUpdateWithoutEmployeeInput>, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type ProjectEmployeeUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ProjectEmployeeCreateWithoutEmployeeInput, ProjectEmployeeUncheckedCreateWithoutEmployeeInput> | ProjectEmployeeCreateWithoutEmployeeInput[] | ProjectEmployeeUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ProjectEmployeeCreateOrConnectWithoutEmployeeInput | ProjectEmployeeCreateOrConnectWithoutEmployeeInput[]
    upsert?: ProjectEmployeeUpsertWithWhereUniqueWithoutEmployeeInput | ProjectEmployeeUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ProjectEmployeeCreateManyEmployeeInputEnvelope
    set?: ProjectEmployeeWhereUniqueInput | ProjectEmployeeWhereUniqueInput[]
    disconnect?: ProjectEmployeeWhereUniqueInput | ProjectEmployeeWhereUniqueInput[]
    delete?: ProjectEmployeeWhereUniqueInput | ProjectEmployeeWhereUniqueInput[]
    connect?: ProjectEmployeeWhereUniqueInput | ProjectEmployeeWhereUniqueInput[]
    update?: ProjectEmployeeUpdateWithWhereUniqueWithoutEmployeeInput | ProjectEmployeeUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ProjectEmployeeUpdateManyWithWhereWithoutEmployeeInput | ProjectEmployeeUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ProjectEmployeeScalarWhereInput | ProjectEmployeeScalarWhereInput[]
  }

  export type SubmittedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<SubmittedCreateWithoutEmployeeInput, SubmittedUncheckedCreateWithoutEmployeeInput> | SubmittedCreateWithoutEmployeeInput[] | SubmittedUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SubmittedCreateOrConnectWithoutEmployeeInput | SubmittedCreateOrConnectWithoutEmployeeInput[]
    upsert?: SubmittedUpsertWithWhereUniqueWithoutEmployeeInput | SubmittedUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: SubmittedCreateManyEmployeeInputEnvelope
    set?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    disconnect?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    delete?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    connect?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    update?: SubmittedUpdateWithWhereUniqueWithoutEmployeeInput | SubmittedUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: SubmittedUpdateManyWithWhereWithoutEmployeeInput | SubmittedUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: SubmittedScalarWhereInput | SubmittedScalarWhereInput[]
  }

  export type ProjectEmployeeUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ProjectEmployeeCreateWithoutEmployeeInput, ProjectEmployeeUncheckedCreateWithoutEmployeeInput> | ProjectEmployeeCreateWithoutEmployeeInput[] | ProjectEmployeeUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ProjectEmployeeCreateOrConnectWithoutEmployeeInput | ProjectEmployeeCreateOrConnectWithoutEmployeeInput[]
    upsert?: ProjectEmployeeUpsertWithWhereUniqueWithoutEmployeeInput | ProjectEmployeeUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ProjectEmployeeCreateManyEmployeeInputEnvelope
    set?: ProjectEmployeeWhereUniqueInput | ProjectEmployeeWhereUniqueInput[]
    disconnect?: ProjectEmployeeWhereUniqueInput | ProjectEmployeeWhereUniqueInput[]
    delete?: ProjectEmployeeWhereUniqueInput | ProjectEmployeeWhereUniqueInput[]
    connect?: ProjectEmployeeWhereUniqueInput | ProjectEmployeeWhereUniqueInput[]
    update?: ProjectEmployeeUpdateWithWhereUniqueWithoutEmployeeInput | ProjectEmployeeUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ProjectEmployeeUpdateManyWithWhereWithoutEmployeeInput | ProjectEmployeeUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ProjectEmployeeScalarWhereInput | ProjectEmployeeScalarWhereInput[]
  }

  export type SubmittedUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<SubmittedCreateWithoutEmployeeInput, SubmittedUncheckedCreateWithoutEmployeeInput> | SubmittedCreateWithoutEmployeeInput[] | SubmittedUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SubmittedCreateOrConnectWithoutEmployeeInput | SubmittedCreateOrConnectWithoutEmployeeInput[]
    upsert?: SubmittedUpsertWithWhereUniqueWithoutEmployeeInput | SubmittedUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: SubmittedCreateManyEmployeeInputEnvelope
    set?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    disconnect?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    delete?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    connect?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    update?: SubmittedUpdateWithWhereUniqueWithoutEmployeeInput | SubmittedUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: SubmittedUpdateManyWithWhereWithoutEmployeeInput | SubmittedUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: SubmittedScalarWhereInput | SubmittedScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOtpVerificationInput = {
    create?: XOR<UserCreateWithoutOtpVerificationInput, UserUncheckedCreateWithoutOtpVerificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpVerificationInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOtpVerificationNestedInput = {
    create?: XOR<UserCreateWithoutOtpVerificationInput, UserUncheckedCreateWithoutOtpVerificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpVerificationInput
    upsert?: UserUpsertWithoutOtpVerificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOtpVerificationInput, UserUpdateWithoutOtpVerificationInput>, UserUncheckedUpdateWithoutOtpVerificationInput>
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type ManagerCreateskillsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutManagerInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedManyWithoutManagerInput = {
    create?: XOR<ProjectCreateWithoutManagerInput, ProjectUncheckedCreateWithoutManagerInput> | ProjectCreateWithoutManagerInput[] | ProjectUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutManagerInput | ProjectCreateOrConnectWithoutManagerInput[]
    createMany?: ProjectCreateManyManagerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type RequestToAddProjectMemberCreateNestedManyWithoutManagerInput = {
    create?: XOR<RequestToAddProjectMemberCreateWithoutManagerInput, RequestToAddProjectMemberUncheckedCreateWithoutManagerInput> | RequestToAddProjectMemberCreateWithoutManagerInput[] | RequestToAddProjectMemberUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: RequestToAddProjectMemberCreateOrConnectWithoutManagerInput | RequestToAddProjectMemberCreateOrConnectWithoutManagerInput[]
    createMany?: RequestToAddProjectMemberCreateManyManagerInputEnvelope
    connect?: RequestToAddProjectMemberWhereUniqueInput | RequestToAddProjectMemberWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<ProjectCreateWithoutManagerInput, ProjectUncheckedCreateWithoutManagerInput> | ProjectCreateWithoutManagerInput[] | ProjectUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutManagerInput | ProjectCreateOrConnectWithoutManagerInput[]
    createMany?: ProjectCreateManyManagerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type RequestToAddProjectMemberUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<RequestToAddProjectMemberCreateWithoutManagerInput, RequestToAddProjectMemberUncheckedCreateWithoutManagerInput> | RequestToAddProjectMemberCreateWithoutManagerInput[] | RequestToAddProjectMemberUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: RequestToAddProjectMemberCreateOrConnectWithoutManagerInput | RequestToAddProjectMemberCreateOrConnectWithoutManagerInput[]
    createMany?: RequestToAddProjectMemberCreateManyManagerInputEnvelope
    connect?: RequestToAddProjectMemberWhereUniqueInput | RequestToAddProjectMemberWhereUniqueInput[]
  }

  export type ManagerUpdateskillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutManagerNestedInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput
    upsert?: UserUpsertWithoutManagerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutManagerInput, UserUpdateWithoutManagerInput>, UserUncheckedUpdateWithoutManagerInput>
  }

  export type ProjectUpdateManyWithoutManagerNestedInput = {
    create?: XOR<ProjectCreateWithoutManagerInput, ProjectUncheckedCreateWithoutManagerInput> | ProjectCreateWithoutManagerInput[] | ProjectUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutManagerInput | ProjectCreateOrConnectWithoutManagerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutManagerInput | ProjectUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: ProjectCreateManyManagerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutManagerInput | ProjectUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutManagerInput | ProjectUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type RequestToAddProjectMemberUpdateManyWithoutManagerNestedInput = {
    create?: XOR<RequestToAddProjectMemberCreateWithoutManagerInput, RequestToAddProjectMemberUncheckedCreateWithoutManagerInput> | RequestToAddProjectMemberCreateWithoutManagerInput[] | RequestToAddProjectMemberUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: RequestToAddProjectMemberCreateOrConnectWithoutManagerInput | RequestToAddProjectMemberCreateOrConnectWithoutManagerInput[]
    upsert?: RequestToAddProjectMemberUpsertWithWhereUniqueWithoutManagerInput | RequestToAddProjectMemberUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: RequestToAddProjectMemberCreateManyManagerInputEnvelope
    set?: RequestToAddProjectMemberWhereUniqueInput | RequestToAddProjectMemberWhereUniqueInput[]
    disconnect?: RequestToAddProjectMemberWhereUniqueInput | RequestToAddProjectMemberWhereUniqueInput[]
    delete?: RequestToAddProjectMemberWhereUniqueInput | RequestToAddProjectMemberWhereUniqueInput[]
    connect?: RequestToAddProjectMemberWhereUniqueInput | RequestToAddProjectMemberWhereUniqueInput[]
    update?: RequestToAddProjectMemberUpdateWithWhereUniqueWithoutManagerInput | RequestToAddProjectMemberUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: RequestToAddProjectMemberUpdateManyWithWhereWithoutManagerInput | RequestToAddProjectMemberUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: RequestToAddProjectMemberScalarWhereInput | RequestToAddProjectMemberScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<ProjectCreateWithoutManagerInput, ProjectUncheckedCreateWithoutManagerInput> | ProjectCreateWithoutManagerInput[] | ProjectUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutManagerInput | ProjectCreateOrConnectWithoutManagerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutManagerInput | ProjectUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: ProjectCreateManyManagerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutManagerInput | ProjectUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutManagerInput | ProjectUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type RequestToAddProjectMemberUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<RequestToAddProjectMemberCreateWithoutManagerInput, RequestToAddProjectMemberUncheckedCreateWithoutManagerInput> | RequestToAddProjectMemberCreateWithoutManagerInput[] | RequestToAddProjectMemberUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: RequestToAddProjectMemberCreateOrConnectWithoutManagerInput | RequestToAddProjectMemberCreateOrConnectWithoutManagerInput[]
    upsert?: RequestToAddProjectMemberUpsertWithWhereUniqueWithoutManagerInput | RequestToAddProjectMemberUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: RequestToAddProjectMemberCreateManyManagerInputEnvelope
    set?: RequestToAddProjectMemberWhereUniqueInput | RequestToAddProjectMemberWhereUniqueInput[]
    disconnect?: RequestToAddProjectMemberWhereUniqueInput | RequestToAddProjectMemberWhereUniqueInput[]
    delete?: RequestToAddProjectMemberWhereUniqueInput | RequestToAddProjectMemberWhereUniqueInput[]
    connect?: RequestToAddProjectMemberWhereUniqueInput | RequestToAddProjectMemberWhereUniqueInput[]
    update?: RequestToAddProjectMemberUpdateWithWhereUniqueWithoutManagerInput | RequestToAddProjectMemberUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: RequestToAddProjectMemberUpdateManyWithWhereWithoutManagerInput | RequestToAddProjectMemberUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: RequestToAddProjectMemberScalarWhereInput | RequestToAddProjectMemberScalarWhereInput[]
  }

  export type NotificationCreatereceiverIdsInput = {
    set: string[]
  }

  export type NotificationProvisionCreateNestedManyWithoutNotificationInput = {
    create?: XOR<NotificationProvisionCreateWithoutNotificationInput, NotificationProvisionUncheckedCreateWithoutNotificationInput> | NotificationProvisionCreateWithoutNotificationInput[] | NotificationProvisionUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationProvisionCreateOrConnectWithoutNotificationInput | NotificationProvisionCreateOrConnectWithoutNotificationInput[]
    createMany?: NotificationProvisionCreateManyNotificationInputEnvelope
    connect?: NotificationProvisionWhereUniqueInput | NotificationProvisionWhereUniqueInput[]
  }

  export type NotificationProvisionUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<NotificationProvisionCreateWithoutNotificationInput, NotificationProvisionUncheckedCreateWithoutNotificationInput> | NotificationProvisionCreateWithoutNotificationInput[] | NotificationProvisionUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationProvisionCreateOrConnectWithoutNotificationInput | NotificationProvisionCreateOrConnectWithoutNotificationInput[]
    createMany?: NotificationProvisionCreateManyNotificationInputEnvelope
    connect?: NotificationProvisionWhereUniqueInput | NotificationProvisionWhereUniqueInput[]
  }

  export type NotificationUpdatereceiverIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NotificationProvisionUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<NotificationProvisionCreateWithoutNotificationInput, NotificationProvisionUncheckedCreateWithoutNotificationInput> | NotificationProvisionCreateWithoutNotificationInput[] | NotificationProvisionUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationProvisionCreateOrConnectWithoutNotificationInput | NotificationProvisionCreateOrConnectWithoutNotificationInput[]
    upsert?: NotificationProvisionUpsertWithWhereUniqueWithoutNotificationInput | NotificationProvisionUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: NotificationProvisionCreateManyNotificationInputEnvelope
    set?: NotificationProvisionWhereUniqueInput | NotificationProvisionWhereUniqueInput[]
    disconnect?: NotificationProvisionWhereUniqueInput | NotificationProvisionWhereUniqueInput[]
    delete?: NotificationProvisionWhereUniqueInput | NotificationProvisionWhereUniqueInput[]
    connect?: NotificationProvisionWhereUniqueInput | NotificationProvisionWhereUniqueInput[]
    update?: NotificationProvisionUpdateWithWhereUniqueWithoutNotificationInput | NotificationProvisionUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: NotificationProvisionUpdateManyWithWhereWithoutNotificationInput | NotificationProvisionUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: NotificationProvisionScalarWhereInput | NotificationProvisionScalarWhereInput[]
  }

  export type NotificationProvisionUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<NotificationProvisionCreateWithoutNotificationInput, NotificationProvisionUncheckedCreateWithoutNotificationInput> | NotificationProvisionCreateWithoutNotificationInput[] | NotificationProvisionUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationProvisionCreateOrConnectWithoutNotificationInput | NotificationProvisionCreateOrConnectWithoutNotificationInput[]
    upsert?: NotificationProvisionUpsertWithWhereUniqueWithoutNotificationInput | NotificationProvisionUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: NotificationProvisionCreateManyNotificationInputEnvelope
    set?: NotificationProvisionWhereUniqueInput | NotificationProvisionWhereUniqueInput[]
    disconnect?: NotificationProvisionWhereUniqueInput | NotificationProvisionWhereUniqueInput[]
    delete?: NotificationProvisionWhereUniqueInput | NotificationProvisionWhereUniqueInput[]
    connect?: NotificationProvisionWhereUniqueInput | NotificationProvisionWhereUniqueInput[]
    update?: NotificationProvisionUpdateWithWhereUniqueWithoutNotificationInput | NotificationProvisionUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: NotificationProvisionUpdateManyWithWhereWithoutNotificationInput | NotificationProvisionUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: NotificationProvisionScalarWhereInput | NotificationProvisionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationCreateNestedOneWithoutProvisionsInput = {
    create?: XOR<NotificationCreateWithoutProvisionsInput, NotificationUncheckedCreateWithoutProvisionsInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutProvisionsInput
    connect?: NotificationWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type NotificationUpdateOneRequiredWithoutProvisionsNestedInput = {
    create?: XOR<NotificationCreateWithoutProvisionsInput, NotificationUncheckedCreateWithoutProvisionsInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutProvisionsInput
    upsert?: NotificationUpsertWithoutProvisionsInput
    connect?: NotificationWhereUniqueInput
    update?: XOR<XOR<NotificationUpdateToOneWithWhereWithoutProvisionsInput, NotificationUpdateWithoutProvisionsInput>, NotificationUncheckedUpdateWithoutProvisionsInput>
  }

  export type UserCreateNestedOneWithoutNotificationEmployeeInput = {
    create?: XOR<UserCreateWithoutNotificationEmployeeInput, UserUncheckedCreateWithoutNotificationEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationEmployeeInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationEmployeeNestedInput = {
    create?: XOR<UserCreateWithoutNotificationEmployeeInput, UserUncheckedCreateWithoutNotificationEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationEmployeeInput
    upsert?: UserUpsertWithoutNotificationEmployeeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationEmployeeInput, UserUpdateWithoutNotificationEmployeeInput>, UserUncheckedUpdateWithoutNotificationEmployeeInput>
  }

  export type UserCreateNestedOneWithoutNotificationManagerInput = {
    create?: XOR<UserCreateWithoutNotificationManagerInput, UserUncheckedCreateWithoutNotificationManagerInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationManagerInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationManagerNestedInput = {
    create?: XOR<UserCreateWithoutNotificationManagerInput, UserUncheckedCreateWithoutNotificationManagerInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationManagerInput
    upsert?: UserUpsertWithoutNotificationManagerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationManagerInput, UserUpdateWithoutNotificationManagerInput>, UserUncheckedUpdateWithoutNotificationManagerInput>
  }

  export type UserCreateNestedOneWithoutNotificationClientInput = {
    create?: XOR<UserCreateWithoutNotificationClientInput, UserUncheckedCreateWithoutNotificationClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationClientInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationClientNestedInput = {
    create?: XOR<UserCreateWithoutNotificationClientInput, UserUncheckedCreateWithoutNotificationClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationClientInput
    upsert?: UserUpsertWithoutNotificationClientInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationClientInput, UserUpdateWithoutNotificationClientInput>, UserUncheckedUpdateWithoutNotificationClientInput>
  }

  export type UserCreateNestedOneWithoutNotificationSupporterInput = {
    create?: XOR<UserCreateWithoutNotificationSupporterInput, UserUncheckedCreateWithoutNotificationSupporterInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationSupporterInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationSupporterNestedInput = {
    create?: XOR<UserCreateWithoutNotificationSupporterInput, UserUncheckedCreateWithoutNotificationSupporterInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationSupporterInput
    upsert?: UserUpsertWithoutNotificationSupporterInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationSupporterInput, UserUpdateWithoutNotificationSupporterInput>, UserUncheckedUpdateWithoutNotificationSupporterInput>
  }

  export type UserCreateNestedOneWithoutNotificationAdminInput = {
    create?: XOR<UserCreateWithoutNotificationAdminInput, UserUncheckedCreateWithoutNotificationAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationAdminInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationAdminNestedInput = {
    create?: XOR<UserCreateWithoutNotificationAdminInput, UserUncheckedCreateWithoutNotificationAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationAdminInput
    upsert?: UserUpsertWithoutNotificationAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationAdminInput, UserUpdateWithoutNotificationAdminInput>, UserUncheckedUpdateWithoutNotificationAdminInput>
  }

  export type SuperAdminCreateNestedOneWithoutNotificationPermissionSuperAdminInput = {
    create?: XOR<SuperAdminCreateWithoutNotificationPermissionSuperAdminInput, SuperAdminUncheckedCreateWithoutNotificationPermissionSuperAdminInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutNotificationPermissionSuperAdminInput
    connect?: SuperAdminWhereUniqueInput
  }

  export type SuperAdminUpdateOneRequiredWithoutNotificationPermissionSuperAdminNestedInput = {
    create?: XOR<SuperAdminCreateWithoutNotificationPermissionSuperAdminInput, SuperAdminUncheckedCreateWithoutNotificationPermissionSuperAdminInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutNotificationPermissionSuperAdminInput
    upsert?: SuperAdminUpsertWithoutNotificationPermissionSuperAdminInput
    connect?: SuperAdminWhereUniqueInput
    update?: XOR<XOR<SuperAdminUpdateToOneWithWhereWithoutNotificationPermissionSuperAdminInput, SuperAdminUpdateWithoutNotificationPermissionSuperAdminInput>, SuperAdminUncheckedUpdateWithoutNotificationPermissionSuperAdminInput>
  }

  export type ClientCreateNestedOneWithoutProgramsInput = {
    create?: XOR<ClientCreateWithoutProgramsInput, ClientUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutProgramsInput
    connect?: ClientWhereUniqueInput
  }

  export type ProjectCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProjectCreateWithoutProgramInput, ProjectUncheckedCreateWithoutProgramInput> | ProjectCreateWithoutProgramInput[] | ProjectUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProgramInput | ProjectCreateOrConnectWithoutProgramInput[]
    createMany?: ProjectCreateManyProgramInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProjectCreateWithoutProgramInput, ProjectUncheckedCreateWithoutProgramInput> | ProjectCreateWithoutProgramInput[] | ProjectUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProgramInput | ProjectCreateOrConnectWithoutProgramInput[]
    createMany?: ProjectCreateManyProgramInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ClientUpdateOneRequiredWithoutProgramsNestedInput = {
    create?: XOR<ClientCreateWithoutProgramsInput, ClientUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutProgramsInput
    upsert?: ClientUpsertWithoutProgramsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutProgramsInput, ClientUpdateWithoutProgramsInput>, ClientUncheckedUpdateWithoutProgramsInput>
  }

  export type ProjectUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProjectCreateWithoutProgramInput, ProjectUncheckedCreateWithoutProgramInput> | ProjectCreateWithoutProgramInput[] | ProjectUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProgramInput | ProjectCreateOrConnectWithoutProgramInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutProgramInput | ProjectUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProjectCreateManyProgramInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutProgramInput | ProjectUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutProgramInput | ProjectUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProjectCreateWithoutProgramInput, ProjectUncheckedCreateWithoutProgramInput> | ProjectCreateWithoutProgramInput[] | ProjectUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProgramInput | ProjectCreateOrConnectWithoutProgramInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutProgramInput | ProjectUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProjectCreateManyProgramInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutProgramInput | ProjectUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutProgramInput | ProjectUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectCreateweakuploadDataInput = {
    set: string[]
  }

  export type ProjectCreatemonthlyuploadDataInput = {
    set: string[]
  }

  export type ProjectCreatechartListInput = {
    set: string[]
  }

  export type ProgramCreateNestedOneWithoutProjectsInput = {
    create?: XOR<ProgramCreateWithoutProjectsInput, ProgramUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutProjectsInput
    connect?: ProgramWhereUniqueInput
  }

  export type ManagerCreateNestedOneWithoutProjectsInput = {
    create?: XOR<ManagerCreateWithoutProjectsInput, ManagerUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutProjectsInput
    connect?: ManagerWhereUniqueInput
  }

  export type ProjectEmployeeCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectEmployeeCreateWithoutProjectInput, ProjectEmployeeUncheckedCreateWithoutProjectInput> | ProjectEmployeeCreateWithoutProjectInput[] | ProjectEmployeeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectEmployeeCreateOrConnectWithoutProjectInput | ProjectEmployeeCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectEmployeeCreateManyProjectInputEnvelope
    connect?: ProjectEmployeeWhereUniqueInput | ProjectEmployeeWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutProjectInput = {
    create?: XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput> | ActivityCreateWithoutProjectInput[] | ActivityUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutProjectInput | ActivityCreateOrConnectWithoutProjectInput[]
    createMany?: ActivityCreateManyProjectInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutProjectInput = {
    create?: XOR<ReviewCreateWithoutProjectInput, ReviewUncheckedCreateWithoutProjectInput> | ReviewCreateWithoutProjectInput[] | ReviewUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProjectInput | ReviewCreateOrConnectWithoutProjectInput[]
    createMany?: ReviewCreateManyProjectInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type RequestToAddProjectMemberCreateNestedManyWithoutProjectInput = {
    create?: XOR<RequestToAddProjectMemberCreateWithoutProjectInput, RequestToAddProjectMemberUncheckedCreateWithoutProjectInput> | RequestToAddProjectMemberCreateWithoutProjectInput[] | RequestToAddProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RequestToAddProjectMemberCreateOrConnectWithoutProjectInput | RequestToAddProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: RequestToAddProjectMemberCreateManyProjectInputEnvelope
    connect?: RequestToAddProjectMemberWhereUniqueInput | RequestToAddProjectMemberWhereUniqueInput[]
  }

  export type SubmittedCreateNestedManyWithoutProjectInput = {
    create?: XOR<SubmittedCreateWithoutProjectInput, SubmittedUncheckedCreateWithoutProjectInput> | SubmittedCreateWithoutProjectInput[] | SubmittedUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SubmittedCreateOrConnectWithoutProjectInput | SubmittedCreateOrConnectWithoutProjectInput[]
    createMany?: SubmittedCreateManyProjectInputEnvelope
    connect?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
  }

  export type ProjectEmployeeUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectEmployeeCreateWithoutProjectInput, ProjectEmployeeUncheckedCreateWithoutProjectInput> | ProjectEmployeeCreateWithoutProjectInput[] | ProjectEmployeeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectEmployeeCreateOrConnectWithoutProjectInput | ProjectEmployeeCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectEmployeeCreateManyProjectInputEnvelope
    connect?: ProjectEmployeeWhereUniqueInput | ProjectEmployeeWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput> | ActivityCreateWithoutProjectInput[] | ActivityUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutProjectInput | ActivityCreateOrConnectWithoutProjectInput[]
    createMany?: ActivityCreateManyProjectInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ReviewCreateWithoutProjectInput, ReviewUncheckedCreateWithoutProjectInput> | ReviewCreateWithoutProjectInput[] | ReviewUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProjectInput | ReviewCreateOrConnectWithoutProjectInput[]
    createMany?: ReviewCreateManyProjectInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type RequestToAddProjectMemberUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<RequestToAddProjectMemberCreateWithoutProjectInput, RequestToAddProjectMemberUncheckedCreateWithoutProjectInput> | RequestToAddProjectMemberCreateWithoutProjectInput[] | RequestToAddProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RequestToAddProjectMemberCreateOrConnectWithoutProjectInput | RequestToAddProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: RequestToAddProjectMemberCreateManyProjectInputEnvelope
    connect?: RequestToAddProjectMemberWhereUniqueInput | RequestToAddProjectMemberWhereUniqueInput[]
  }

  export type SubmittedUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<SubmittedCreateWithoutProjectInput, SubmittedUncheckedCreateWithoutProjectInput> | SubmittedCreateWithoutProjectInput[] | SubmittedUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SubmittedCreateOrConnectWithoutProjectInput | SubmittedCreateOrConnectWithoutProjectInput[]
    createMany?: SubmittedCreateManyProjectInputEnvelope
    connect?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
  }

  export type EnumProjectCycleFieldUpdateOperationsInput = {
    set?: $Enums.ProjectCycle
  }

  export type ProjectUpdateweakuploadDataInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdatemonthlyuploadDataInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumProjectStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProjectStatus
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ProjectUpdatechartListInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProgramUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<ProgramCreateWithoutProjectsInput, ProgramUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutProjectsInput
    upsert?: ProgramUpsertWithoutProjectsInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutProjectsInput, ProgramUpdateWithoutProjectsInput>, ProgramUncheckedUpdateWithoutProjectsInput>
  }

  export type ManagerUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<ManagerCreateWithoutProjectsInput, ManagerUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutProjectsInput
    upsert?: ManagerUpsertWithoutProjectsInput
    connect?: ManagerWhereUniqueInput
    update?: XOR<XOR<ManagerUpdateToOneWithWhereWithoutProjectsInput, ManagerUpdateWithoutProjectsInput>, ManagerUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectEmployeeUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectEmployeeCreateWithoutProjectInput, ProjectEmployeeUncheckedCreateWithoutProjectInput> | ProjectEmployeeCreateWithoutProjectInput[] | ProjectEmployeeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectEmployeeCreateOrConnectWithoutProjectInput | ProjectEmployeeCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectEmployeeUpsertWithWhereUniqueWithoutProjectInput | ProjectEmployeeUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectEmployeeCreateManyProjectInputEnvelope
    set?: ProjectEmployeeWhereUniqueInput | ProjectEmployeeWhereUniqueInput[]
    disconnect?: ProjectEmployeeWhereUniqueInput | ProjectEmployeeWhereUniqueInput[]
    delete?: ProjectEmployeeWhereUniqueInput | ProjectEmployeeWhereUniqueInput[]
    connect?: ProjectEmployeeWhereUniqueInput | ProjectEmployeeWhereUniqueInput[]
    update?: ProjectEmployeeUpdateWithWhereUniqueWithoutProjectInput | ProjectEmployeeUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectEmployeeUpdateManyWithWhereWithoutProjectInput | ProjectEmployeeUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectEmployeeScalarWhereInput | ProjectEmployeeScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput> | ActivityCreateWithoutProjectInput[] | ActivityUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutProjectInput | ActivityCreateOrConnectWithoutProjectInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutProjectInput | ActivityUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ActivityCreateManyProjectInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutProjectInput | ActivityUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutProjectInput | ActivityUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ReviewCreateWithoutProjectInput, ReviewUncheckedCreateWithoutProjectInput> | ReviewCreateWithoutProjectInput[] | ReviewUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProjectInput | ReviewCreateOrConnectWithoutProjectInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutProjectInput | ReviewUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ReviewCreateManyProjectInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutProjectInput | ReviewUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutProjectInput | ReviewUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type RequestToAddProjectMemberUpdateManyWithoutProjectNestedInput = {
    create?: XOR<RequestToAddProjectMemberCreateWithoutProjectInput, RequestToAddProjectMemberUncheckedCreateWithoutProjectInput> | RequestToAddProjectMemberCreateWithoutProjectInput[] | RequestToAddProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RequestToAddProjectMemberCreateOrConnectWithoutProjectInput | RequestToAddProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: RequestToAddProjectMemberUpsertWithWhereUniqueWithoutProjectInput | RequestToAddProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: RequestToAddProjectMemberCreateManyProjectInputEnvelope
    set?: RequestToAddProjectMemberWhereUniqueInput | RequestToAddProjectMemberWhereUniqueInput[]
    disconnect?: RequestToAddProjectMemberWhereUniqueInput | RequestToAddProjectMemberWhereUniqueInput[]
    delete?: RequestToAddProjectMemberWhereUniqueInput | RequestToAddProjectMemberWhereUniqueInput[]
    connect?: RequestToAddProjectMemberWhereUniqueInput | RequestToAddProjectMemberWhereUniqueInput[]
    update?: RequestToAddProjectMemberUpdateWithWhereUniqueWithoutProjectInput | RequestToAddProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: RequestToAddProjectMemberUpdateManyWithWhereWithoutProjectInput | RequestToAddProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: RequestToAddProjectMemberScalarWhereInput | RequestToAddProjectMemberScalarWhereInput[]
  }

  export type SubmittedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SubmittedCreateWithoutProjectInput, SubmittedUncheckedCreateWithoutProjectInput> | SubmittedCreateWithoutProjectInput[] | SubmittedUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SubmittedCreateOrConnectWithoutProjectInput | SubmittedCreateOrConnectWithoutProjectInput[]
    upsert?: SubmittedUpsertWithWhereUniqueWithoutProjectInput | SubmittedUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SubmittedCreateManyProjectInputEnvelope
    set?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    disconnect?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    delete?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    connect?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    update?: SubmittedUpdateWithWhereUniqueWithoutProjectInput | SubmittedUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SubmittedUpdateManyWithWhereWithoutProjectInput | SubmittedUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SubmittedScalarWhereInput | SubmittedScalarWhereInput[]
  }

  export type ProjectEmployeeUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectEmployeeCreateWithoutProjectInput, ProjectEmployeeUncheckedCreateWithoutProjectInput> | ProjectEmployeeCreateWithoutProjectInput[] | ProjectEmployeeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectEmployeeCreateOrConnectWithoutProjectInput | ProjectEmployeeCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectEmployeeUpsertWithWhereUniqueWithoutProjectInput | ProjectEmployeeUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectEmployeeCreateManyProjectInputEnvelope
    set?: ProjectEmployeeWhereUniqueInput | ProjectEmployeeWhereUniqueInput[]
    disconnect?: ProjectEmployeeWhereUniqueInput | ProjectEmployeeWhereUniqueInput[]
    delete?: ProjectEmployeeWhereUniqueInput | ProjectEmployeeWhereUniqueInput[]
    connect?: ProjectEmployeeWhereUniqueInput | ProjectEmployeeWhereUniqueInput[]
    update?: ProjectEmployeeUpdateWithWhereUniqueWithoutProjectInput | ProjectEmployeeUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectEmployeeUpdateManyWithWhereWithoutProjectInput | ProjectEmployeeUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectEmployeeScalarWhereInput | ProjectEmployeeScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput> | ActivityCreateWithoutProjectInput[] | ActivityUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutProjectInput | ActivityCreateOrConnectWithoutProjectInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutProjectInput | ActivityUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ActivityCreateManyProjectInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutProjectInput | ActivityUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutProjectInput | ActivityUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ReviewCreateWithoutProjectInput, ReviewUncheckedCreateWithoutProjectInput> | ReviewCreateWithoutProjectInput[] | ReviewUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProjectInput | ReviewCreateOrConnectWithoutProjectInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutProjectInput | ReviewUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ReviewCreateManyProjectInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutProjectInput | ReviewUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutProjectInput | ReviewUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type RequestToAddProjectMemberUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<RequestToAddProjectMemberCreateWithoutProjectInput, RequestToAddProjectMemberUncheckedCreateWithoutProjectInput> | RequestToAddProjectMemberCreateWithoutProjectInput[] | RequestToAddProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RequestToAddProjectMemberCreateOrConnectWithoutProjectInput | RequestToAddProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: RequestToAddProjectMemberUpsertWithWhereUniqueWithoutProjectInput | RequestToAddProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: RequestToAddProjectMemberCreateManyProjectInputEnvelope
    set?: RequestToAddProjectMemberWhereUniqueInput | RequestToAddProjectMemberWhereUniqueInput[]
    disconnect?: RequestToAddProjectMemberWhereUniqueInput | RequestToAddProjectMemberWhereUniqueInput[]
    delete?: RequestToAddProjectMemberWhereUniqueInput | RequestToAddProjectMemberWhereUniqueInput[]
    connect?: RequestToAddProjectMemberWhereUniqueInput | RequestToAddProjectMemberWhereUniqueInput[]
    update?: RequestToAddProjectMemberUpdateWithWhereUniqueWithoutProjectInput | RequestToAddProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: RequestToAddProjectMemberUpdateManyWithWhereWithoutProjectInput | RequestToAddProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: RequestToAddProjectMemberScalarWhereInput | RequestToAddProjectMemberScalarWhereInput[]
  }

  export type SubmittedUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SubmittedCreateWithoutProjectInput, SubmittedUncheckedCreateWithoutProjectInput> | SubmittedCreateWithoutProjectInput[] | SubmittedUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SubmittedCreateOrConnectWithoutProjectInput | SubmittedCreateOrConnectWithoutProjectInput[]
    upsert?: SubmittedUpsertWithWhereUniqueWithoutProjectInput | SubmittedUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SubmittedCreateManyProjectInputEnvelope
    set?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    disconnect?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    delete?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    connect?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    update?: SubmittedUpdateWithWhereUniqueWithoutProjectInput | SubmittedUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SubmittedUpdateManyWithWhereWithoutProjectInput | SubmittedUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SubmittedScalarWhereInput | SubmittedScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutProjectEmployeesInput = {
    create?: XOR<ProjectCreateWithoutProjectEmployeesInput, ProjectUncheckedCreateWithoutProjectEmployeesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectEmployeesInput
    connect?: ProjectWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutProjectEmployeesInput = {
    create?: XOR<EmployeeCreateWithoutProjectEmployeesInput, EmployeeUncheckedCreateWithoutProjectEmployeesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutProjectEmployeesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutProjectEmployeesNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectEmployeesInput, ProjectUncheckedCreateWithoutProjectEmployeesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectEmployeesInput
    upsert?: ProjectUpsertWithoutProjectEmployeesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutProjectEmployeesInput, ProjectUpdateWithoutProjectEmployeesInput>, ProjectUncheckedUpdateWithoutProjectEmployeesInput>
  }

  export type EmployeeUpdateOneRequiredWithoutProjectEmployeesNestedInput = {
    create?: XOR<EmployeeCreateWithoutProjectEmployeesInput, EmployeeUncheckedCreateWithoutProjectEmployeesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutProjectEmployeesInput
    upsert?: EmployeeUpsertWithoutProjectEmployeesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutProjectEmployeesInput, EmployeeUpdateWithoutProjectEmployeesInput>, EmployeeUncheckedUpdateWithoutProjectEmployeesInput>
  }

  export type ProjectCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ProjectCreateWithoutReviewsInput, ProjectUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutReviewsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ProjectCreateWithoutReviewsInput, ProjectUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutReviewsInput
    upsert?: ProjectUpsertWithoutReviewsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutReviewsInput, ProjectUpdateWithoutReviewsInput>, ProjectUncheckedUpdateWithoutReviewsInput>
  }

  export type SubmittedCreateNestedManyWithoutSheetInput = {
    create?: XOR<SubmittedCreateWithoutSheetInput, SubmittedUncheckedCreateWithoutSheetInput> | SubmittedCreateWithoutSheetInput[] | SubmittedUncheckedCreateWithoutSheetInput[]
    connectOrCreate?: SubmittedCreateOrConnectWithoutSheetInput | SubmittedCreateOrConnectWithoutSheetInput[]
    createMany?: SubmittedCreateManySheetInputEnvelope
    connect?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
  }

  export type SubmittedUncheckedCreateNestedManyWithoutSheetInput = {
    create?: XOR<SubmittedCreateWithoutSheetInput, SubmittedUncheckedCreateWithoutSheetInput> | SubmittedCreateWithoutSheetInput[] | SubmittedUncheckedCreateWithoutSheetInput[]
    connectOrCreate?: SubmittedCreateOrConnectWithoutSheetInput | SubmittedCreateOrConnectWithoutSheetInput[]
    createMany?: SubmittedCreateManySheetInputEnvelope
    connect?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
  }

  export type SubmittedUpdateManyWithoutSheetNestedInput = {
    create?: XOR<SubmittedCreateWithoutSheetInput, SubmittedUncheckedCreateWithoutSheetInput> | SubmittedCreateWithoutSheetInput[] | SubmittedUncheckedCreateWithoutSheetInput[]
    connectOrCreate?: SubmittedCreateOrConnectWithoutSheetInput | SubmittedCreateOrConnectWithoutSheetInput[]
    upsert?: SubmittedUpsertWithWhereUniqueWithoutSheetInput | SubmittedUpsertWithWhereUniqueWithoutSheetInput[]
    createMany?: SubmittedCreateManySheetInputEnvelope
    set?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    disconnect?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    delete?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    connect?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    update?: SubmittedUpdateWithWhereUniqueWithoutSheetInput | SubmittedUpdateWithWhereUniqueWithoutSheetInput[]
    updateMany?: SubmittedUpdateManyWithWhereWithoutSheetInput | SubmittedUpdateManyWithWhereWithoutSheetInput[]
    deleteMany?: SubmittedScalarWhereInput | SubmittedScalarWhereInput[]
  }

  export type SubmittedUncheckedUpdateManyWithoutSheetNestedInput = {
    create?: XOR<SubmittedCreateWithoutSheetInput, SubmittedUncheckedCreateWithoutSheetInput> | SubmittedCreateWithoutSheetInput[] | SubmittedUncheckedCreateWithoutSheetInput[]
    connectOrCreate?: SubmittedCreateOrConnectWithoutSheetInput | SubmittedCreateOrConnectWithoutSheetInput[]
    upsert?: SubmittedUpsertWithWhereUniqueWithoutSheetInput | SubmittedUpsertWithWhereUniqueWithoutSheetInput[]
    createMany?: SubmittedCreateManySheetInputEnvelope
    set?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    disconnect?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    delete?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    connect?: SubmittedWhereUniqueInput | SubmittedWhereUniqueInput[]
    update?: SubmittedUpdateWithWhereUniqueWithoutSheetInput | SubmittedUpdateWithWhereUniqueWithoutSheetInput[]
    updateMany?: SubmittedUpdateManyWithWhereWithoutSheetInput | SubmittedUpdateManyWithWhereWithoutSheetInput[]
    deleteMany?: SubmittedScalarWhereInput | SubmittedScalarWhereInput[]
  }

  export type SubmittedCreateNestedOneWithoutSubmissionReturnInput = {
    create?: XOR<SubmittedCreateWithoutSubmissionReturnInput, SubmittedUncheckedCreateWithoutSubmissionReturnInput>
    connectOrCreate?: SubmittedCreateOrConnectWithoutSubmissionReturnInput
    connect?: SubmittedWhereUniqueInput
  }

  export type SubmittedUpdateOneRequiredWithoutSubmissionReturnNestedInput = {
    create?: XOR<SubmittedCreateWithoutSubmissionReturnInput, SubmittedUncheckedCreateWithoutSubmissionReturnInput>
    connectOrCreate?: SubmittedCreateOrConnectWithoutSubmissionReturnInput
    upsert?: SubmittedUpsertWithoutSubmissionReturnInput
    connect?: SubmittedWhereUniqueInput
    update?: XOR<XOR<SubmittedUpdateToOneWithWhereWithoutSubmissionReturnInput, SubmittedUpdateWithoutSubmissionReturnInput>, SubmittedUncheckedUpdateWithoutSubmissionReturnInput>
  }

  export type EmployeeCreateNestedOneWithoutSubmittedInput = {
    create?: XOR<EmployeeCreateWithoutSubmittedInput, EmployeeUncheckedCreateWithoutSubmittedInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutSubmittedInput
    connect?: EmployeeWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutSubmittedInput = {
    create?: XOR<ProjectCreateWithoutSubmittedInput, ProjectUncheckedCreateWithoutSubmittedInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSubmittedInput
    connect?: ProjectWhereUniqueInput
  }

  export type SheetCreateNestedOneWithoutSubmittedInput = {
    create?: XOR<SheetCreateWithoutSubmittedInput, SheetUncheckedCreateWithoutSubmittedInput>
    connectOrCreate?: SheetCreateOrConnectWithoutSubmittedInput
    connect?: SheetWhereUniqueInput
  }

  export type SubmissionReturnCreateNestedOneWithoutSubmittedInput = {
    create?: XOR<SubmissionReturnCreateWithoutSubmittedInput, SubmissionReturnUncheckedCreateWithoutSubmittedInput>
    connectOrCreate?: SubmissionReturnCreateOrConnectWithoutSubmittedInput
    connect?: SubmissionReturnWhereUniqueInput
  }

  export type SubmissionReturnUncheckedCreateNestedOneWithoutSubmittedInput = {
    create?: XOR<SubmissionReturnCreateWithoutSubmittedInput, SubmissionReturnUncheckedCreateWithoutSubmittedInput>
    connectOrCreate?: SubmissionReturnCreateOrConnectWithoutSubmittedInput
    connect?: SubmissionReturnWhereUniqueInput
  }

  export type EnumSubmittedStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubmittedStatus
  }

  export type EmployeeUpdateOneRequiredWithoutSubmittedNestedInput = {
    create?: XOR<EmployeeCreateWithoutSubmittedInput, EmployeeUncheckedCreateWithoutSubmittedInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutSubmittedInput
    upsert?: EmployeeUpsertWithoutSubmittedInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutSubmittedInput, EmployeeUpdateWithoutSubmittedInput>, EmployeeUncheckedUpdateWithoutSubmittedInput>
  }

  export type ProjectUpdateOneRequiredWithoutSubmittedNestedInput = {
    create?: XOR<ProjectCreateWithoutSubmittedInput, ProjectUncheckedCreateWithoutSubmittedInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSubmittedInput
    upsert?: ProjectUpsertWithoutSubmittedInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSubmittedInput, ProjectUpdateWithoutSubmittedInput>, ProjectUncheckedUpdateWithoutSubmittedInput>
  }

  export type SheetUpdateOneRequiredWithoutSubmittedNestedInput = {
    create?: XOR<SheetCreateWithoutSubmittedInput, SheetUncheckedCreateWithoutSubmittedInput>
    connectOrCreate?: SheetCreateOrConnectWithoutSubmittedInput
    upsert?: SheetUpsertWithoutSubmittedInput
    connect?: SheetWhereUniqueInput
    update?: XOR<XOR<SheetUpdateToOneWithWhereWithoutSubmittedInput, SheetUpdateWithoutSubmittedInput>, SheetUncheckedUpdateWithoutSubmittedInput>
  }

  export type SubmissionReturnUpdateOneWithoutSubmittedNestedInput = {
    create?: XOR<SubmissionReturnCreateWithoutSubmittedInput, SubmissionReturnUncheckedCreateWithoutSubmittedInput>
    connectOrCreate?: SubmissionReturnCreateOrConnectWithoutSubmittedInput
    upsert?: SubmissionReturnUpsertWithoutSubmittedInput
    disconnect?: SubmissionReturnWhereInput | boolean
    delete?: SubmissionReturnWhereInput | boolean
    connect?: SubmissionReturnWhereUniqueInput
    update?: XOR<XOR<SubmissionReturnUpdateToOneWithWhereWithoutSubmittedInput, SubmissionReturnUpdateWithoutSubmittedInput>, SubmissionReturnUncheckedUpdateWithoutSubmittedInput>
  }

  export type SubmissionReturnUncheckedUpdateOneWithoutSubmittedNestedInput = {
    create?: XOR<SubmissionReturnCreateWithoutSubmittedInput, SubmissionReturnUncheckedCreateWithoutSubmittedInput>
    connectOrCreate?: SubmissionReturnCreateOrConnectWithoutSubmittedInput
    upsert?: SubmissionReturnUpsertWithoutSubmittedInput
    disconnect?: SubmissionReturnWhereInput | boolean
    delete?: SubmissionReturnWhereInput | boolean
    connect?: SubmissionReturnWhereUniqueInput
    update?: XOR<XOR<SubmissionReturnUpdateToOneWithWhereWithoutSubmittedInput, SubmissionReturnUpdateWithoutSubmittedInput>, SubmissionReturnUncheckedUpdateWithoutSubmittedInput>
  }

  export type UserCreateNestedOneWithoutSuperAdminInput = {
    create?: XOR<UserCreateWithoutSuperAdminInput, UserUncheckedCreateWithoutSuperAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutSuperAdminInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationPermissionSuperAdminCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPermissionSuperAdminCreateWithoutUserInput, NotificationPermissionSuperAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionSuperAdminCreateOrConnectWithoutUserInput
    connect?: NotificationPermissionSuperAdminWhereUniqueInput
  }

  export type NotificationPermissionSuperAdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPermissionSuperAdminCreateWithoutUserInput, NotificationPermissionSuperAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionSuperAdminCreateOrConnectWithoutUserInput
    connect?: NotificationPermissionSuperAdminWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSuperAdminNestedInput = {
    create?: XOR<UserCreateWithoutSuperAdminInput, UserUncheckedCreateWithoutSuperAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutSuperAdminInput
    upsert?: UserUpsertWithoutSuperAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSuperAdminInput, UserUpdateWithoutSuperAdminInput>, UserUncheckedUpdateWithoutSuperAdminInput>
  }

  export type NotificationPermissionSuperAdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPermissionSuperAdminCreateWithoutUserInput, NotificationPermissionSuperAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionSuperAdminCreateOrConnectWithoutUserInput
    upsert?: NotificationPermissionSuperAdminUpsertWithoutUserInput
    disconnect?: NotificationPermissionSuperAdminWhereInput | boolean
    delete?: NotificationPermissionSuperAdminWhereInput | boolean
    connect?: NotificationPermissionSuperAdminWhereUniqueInput
    update?: XOR<XOR<NotificationPermissionSuperAdminUpdateToOneWithWhereWithoutUserInput, NotificationPermissionSuperAdminUpdateWithoutUserInput>, NotificationPermissionSuperAdminUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPermissionSuperAdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPermissionSuperAdminCreateWithoutUserInput, NotificationPermissionSuperAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionSuperAdminCreateOrConnectWithoutUserInput
    upsert?: NotificationPermissionSuperAdminUpsertWithoutUserInput
    disconnect?: NotificationPermissionSuperAdminWhereInput | boolean
    delete?: NotificationPermissionSuperAdminWhereInput | boolean
    connect?: NotificationPermissionSuperAdminWhereUniqueInput
    update?: XOR<XOR<NotificationPermissionSuperAdminUpdateToOneWithWhereWithoutUserInput, NotificationPermissionSuperAdminUpdateWithoutUserInput>, NotificationPermissionSuperAdminUncheckedUpdateWithoutUserInput>
  }

  export type SupporterCreateskillsInput = {
    set: string[]
  }

  export type SupporterCreateworkItemsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutSupporterInput = {
    create?: XOR<UserCreateWithoutSupporterInput, UserUncheckedCreateWithoutSupporterInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupporterInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSupporterRoleFieldUpdateOperationsInput = {
    set?: $Enums.SupporterRole
  }

  export type SupporterUpdateskillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SupporterUpdateworkItemsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutSupporterNestedInput = {
    create?: XOR<UserCreateWithoutSupporterInput, UserUncheckedCreateWithoutSupporterInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupporterInput
    upsert?: UserUpsertWithoutSupporterInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSupporterInput, UserUpdateWithoutSupporterInput>, UserUncheckedUpdateWithoutSupporterInput>
  }

  export type ProjectCreateNestedOneWithoutTasksInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    connect?: ProjectWhereUniqueInput
  }

  export type NullableEnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus | null
  }

  export type ProjectUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    upsert?: ProjectUpsertWithoutTasksInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTasksInput, ProjectUpdateWithoutTasksInput>, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type TicketCreatesupporterIdsInput = {
    set: string[]
  }

  export type TicketCreateadminIdsInput = {
    set: string[]
  }

  export type ClientCreateNestedOneWithoutTicketsInput = {
    create?: XOR<ClientCreateWithoutTicketsInput, ClientUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutTicketsInput
    connect?: ClientWhereUniqueInput
  }

  export type TicketUpdatesupporterIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TicketUpdateadminIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumTicketStatusFieldUpdateOperationsInput = {
    set?: $Enums.TicketStatus
  }

  export type EnumIssueTypeFieldUpdateOperationsInput = {
    set?: $Enums.IssueType
  }

  export type ClientUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<ClientCreateWithoutTicketsInput, ClientUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutTicketsInput
    upsert?: ClientUpsertWithoutTicketsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutTicketsInput, ClientUpdateWithoutTicketsInput>, ClientUncheckedUpdateWithoutTicketsInput>
  }

  export type ClientCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    connect?: ClientWhereUniqueInput
  }

  export type ManagerCreateNestedOneWithoutUserInput = {
    create?: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutUserInput
    connect?: ManagerWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    connect?: EmployeeWhereUniqueInput
  }

  export type ViewerCreateNestedOneWithoutUserInput = {
    create?: XOR<ViewerCreateWithoutUserInput, ViewerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ViewerCreateOrConnectWithoutUserInput
    connect?: ViewerWhereUniqueInput
  }

  export type SupporterCreateNestedOneWithoutUserInput = {
    create?: XOR<SupporterCreateWithoutUserInput, SupporterUncheckedCreateWithoutUserInput>
    connectOrCreate?: SupporterCreateOrConnectWithoutUserInput
    connect?: SupporterWhereUniqueInput
  }

  export type SuperAdminCreateNestedOneWithoutUserInput = {
    create?: XOR<SuperAdminCreateWithoutUserInput, SuperAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutUserInput
    connect?: SuperAdminWhereUniqueInput
  }

  export type NotificationPermissionEmployeeCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPermissionEmployeeCreateWithoutUserInput, NotificationPermissionEmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionEmployeeCreateOrConnectWithoutUserInput
    connect?: NotificationPermissionEmployeeWhereUniqueInput
  }

  export type NotificationPermissionManagerCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPermissionManagerCreateWithoutUserInput, NotificationPermissionManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionManagerCreateOrConnectWithoutUserInput
    connect?: NotificationPermissionManagerWhereUniqueInput
  }

  export type NotificationPermissionClientCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPermissionClientCreateWithoutUserInput, NotificationPermissionClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionClientCreateOrConnectWithoutUserInput
    connect?: NotificationPermissionClientWhereUniqueInput
  }

  export type NotificationPermissionSupporterCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPermissionSupporterCreateWithoutUserInput, NotificationPermissionSupporterUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionSupporterCreateOrConnectWithoutUserInput
    connect?: NotificationPermissionSupporterWhereUniqueInput
  }

  export type NotificationPermissionAdminCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPermissionAdminCreateWithoutUserInput, NotificationPermissionAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionAdminCreateOrConnectWithoutUserInput
    connect?: NotificationPermissionAdminWhereUniqueInput
  }

  export type NotificationProvisionCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationProvisionCreateWithoutUserInput, NotificationProvisionUncheckedCreateWithoutUserInput> | NotificationProvisionCreateWithoutUserInput[] | NotificationProvisionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationProvisionCreateOrConnectWithoutUserInput | NotificationProvisionCreateOrConnectWithoutUserInput[]
    createMany?: NotificationProvisionCreateManyUserInputEnvelope
    connect?: NotificationProvisionWhereUniqueInput | NotificationProvisionWhereUniqueInput[]
  }

  export type OtpVerificationCreateNestedOneWithoutUserInput = {
    create?: XOR<OtpVerificationCreateWithoutUserInput, OtpVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: OtpVerificationCreateOrConnectWithoutUserInput
    connect?: OtpVerificationWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    connect?: ClientWhereUniqueInput
  }

  export type ManagerUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutUserInput
    connect?: ManagerWhereUniqueInput
  }

  export type EmployeeUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    connect?: EmployeeWhereUniqueInput
  }

  export type ViewerUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ViewerCreateWithoutUserInput, ViewerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ViewerCreateOrConnectWithoutUserInput
    connect?: ViewerWhereUniqueInput
  }

  export type SupporterUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SupporterCreateWithoutUserInput, SupporterUncheckedCreateWithoutUserInput>
    connectOrCreate?: SupporterCreateOrConnectWithoutUserInput
    connect?: SupporterWhereUniqueInput
  }

  export type SuperAdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SuperAdminCreateWithoutUserInput, SuperAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutUserInput
    connect?: SuperAdminWhereUniqueInput
  }

  export type NotificationPermissionEmployeeUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPermissionEmployeeCreateWithoutUserInput, NotificationPermissionEmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionEmployeeCreateOrConnectWithoutUserInput
    connect?: NotificationPermissionEmployeeWhereUniqueInput
  }

  export type NotificationPermissionManagerUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPermissionManagerCreateWithoutUserInput, NotificationPermissionManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionManagerCreateOrConnectWithoutUserInput
    connect?: NotificationPermissionManagerWhereUniqueInput
  }

  export type NotificationPermissionClientUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPermissionClientCreateWithoutUserInput, NotificationPermissionClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionClientCreateOrConnectWithoutUserInput
    connect?: NotificationPermissionClientWhereUniqueInput
  }

  export type NotificationPermissionSupporterUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPermissionSupporterCreateWithoutUserInput, NotificationPermissionSupporterUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionSupporterCreateOrConnectWithoutUserInput
    connect?: NotificationPermissionSupporterWhereUniqueInput
  }

  export type NotificationPermissionAdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPermissionAdminCreateWithoutUserInput, NotificationPermissionAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionAdminCreateOrConnectWithoutUserInput
    connect?: NotificationPermissionAdminWhereUniqueInput
  }

  export type NotificationProvisionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationProvisionCreateWithoutUserInput, NotificationProvisionUncheckedCreateWithoutUserInput> | NotificationProvisionCreateWithoutUserInput[] | NotificationProvisionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationProvisionCreateOrConnectWithoutUserInput | NotificationProvisionCreateOrConnectWithoutUserInput[]
    createMany?: NotificationProvisionCreateManyUserInputEnvelope
    connect?: NotificationProvisionWhereUniqueInput | NotificationProvisionWhereUniqueInput[]
  }

  export type OtpVerificationUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<OtpVerificationCreateWithoutUserInput, OtpVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: OtpVerificationCreateOrConnectWithoutUserInput
    connect?: OtpVerificationWhereUniqueInput
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type EnumLanguageFieldUpdateOperationsInput = {
    set?: $Enums.Language
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type ClientUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    upsert?: ClientUpsertWithoutUserInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutUserInput, ClientUpdateWithoutUserInput>, ClientUncheckedUpdateWithoutUserInput>
  }

  export type ManagerUpdateOneWithoutUserNestedInput = {
    create?: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutUserInput
    upsert?: ManagerUpsertWithoutUserInput
    disconnect?: ManagerWhereInput | boolean
    delete?: ManagerWhereInput | boolean
    connect?: ManagerWhereUniqueInput
    update?: XOR<XOR<ManagerUpdateToOneWithWhereWithoutUserInput, ManagerUpdateWithoutUserInput>, ManagerUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    upsert?: EmployeeUpsertWithoutUserInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutUserInput, EmployeeUpdateWithoutUserInput>, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type ViewerUpdateOneWithoutUserNestedInput = {
    create?: XOR<ViewerCreateWithoutUserInput, ViewerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ViewerCreateOrConnectWithoutUserInput
    upsert?: ViewerUpsertWithoutUserInput
    disconnect?: ViewerWhereInput | boolean
    delete?: ViewerWhereInput | boolean
    connect?: ViewerWhereUniqueInput
    update?: XOR<XOR<ViewerUpdateToOneWithWhereWithoutUserInput, ViewerUpdateWithoutUserInput>, ViewerUncheckedUpdateWithoutUserInput>
  }

  export type SupporterUpdateOneWithoutUserNestedInput = {
    create?: XOR<SupporterCreateWithoutUserInput, SupporterUncheckedCreateWithoutUserInput>
    connectOrCreate?: SupporterCreateOrConnectWithoutUserInput
    upsert?: SupporterUpsertWithoutUserInput
    disconnect?: SupporterWhereInput | boolean
    delete?: SupporterWhereInput | boolean
    connect?: SupporterWhereUniqueInput
    update?: XOR<XOR<SupporterUpdateToOneWithWhereWithoutUserInput, SupporterUpdateWithoutUserInput>, SupporterUncheckedUpdateWithoutUserInput>
  }

  export type SuperAdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<SuperAdminCreateWithoutUserInput, SuperAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutUserInput
    upsert?: SuperAdminUpsertWithoutUserInput
    disconnect?: SuperAdminWhereInput | boolean
    delete?: SuperAdminWhereInput | boolean
    connect?: SuperAdminWhereUniqueInput
    update?: XOR<XOR<SuperAdminUpdateToOneWithWhereWithoutUserInput, SuperAdminUpdateWithoutUserInput>, SuperAdminUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPermissionEmployeeUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPermissionEmployeeCreateWithoutUserInput, NotificationPermissionEmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionEmployeeCreateOrConnectWithoutUserInput
    upsert?: NotificationPermissionEmployeeUpsertWithoutUserInput
    disconnect?: NotificationPermissionEmployeeWhereInput | boolean
    delete?: NotificationPermissionEmployeeWhereInput | boolean
    connect?: NotificationPermissionEmployeeWhereUniqueInput
    update?: XOR<XOR<NotificationPermissionEmployeeUpdateToOneWithWhereWithoutUserInput, NotificationPermissionEmployeeUpdateWithoutUserInput>, NotificationPermissionEmployeeUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPermissionManagerUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPermissionManagerCreateWithoutUserInput, NotificationPermissionManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionManagerCreateOrConnectWithoutUserInput
    upsert?: NotificationPermissionManagerUpsertWithoutUserInput
    disconnect?: NotificationPermissionManagerWhereInput | boolean
    delete?: NotificationPermissionManagerWhereInput | boolean
    connect?: NotificationPermissionManagerWhereUniqueInput
    update?: XOR<XOR<NotificationPermissionManagerUpdateToOneWithWhereWithoutUserInput, NotificationPermissionManagerUpdateWithoutUserInput>, NotificationPermissionManagerUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPermissionClientUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPermissionClientCreateWithoutUserInput, NotificationPermissionClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionClientCreateOrConnectWithoutUserInput
    upsert?: NotificationPermissionClientUpsertWithoutUserInput
    disconnect?: NotificationPermissionClientWhereInput | boolean
    delete?: NotificationPermissionClientWhereInput | boolean
    connect?: NotificationPermissionClientWhereUniqueInput
    update?: XOR<XOR<NotificationPermissionClientUpdateToOneWithWhereWithoutUserInput, NotificationPermissionClientUpdateWithoutUserInput>, NotificationPermissionClientUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPermissionSupporterUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPermissionSupporterCreateWithoutUserInput, NotificationPermissionSupporterUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionSupporterCreateOrConnectWithoutUserInput
    upsert?: NotificationPermissionSupporterUpsertWithoutUserInput
    disconnect?: NotificationPermissionSupporterWhereInput | boolean
    delete?: NotificationPermissionSupporterWhereInput | boolean
    connect?: NotificationPermissionSupporterWhereUniqueInput
    update?: XOR<XOR<NotificationPermissionSupporterUpdateToOneWithWhereWithoutUserInput, NotificationPermissionSupporterUpdateWithoutUserInput>, NotificationPermissionSupporterUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPermissionAdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPermissionAdminCreateWithoutUserInput, NotificationPermissionAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionAdminCreateOrConnectWithoutUserInput
    upsert?: NotificationPermissionAdminUpsertWithoutUserInput
    disconnect?: NotificationPermissionAdminWhereInput | boolean
    delete?: NotificationPermissionAdminWhereInput | boolean
    connect?: NotificationPermissionAdminWhereUniqueInput
    update?: XOR<XOR<NotificationPermissionAdminUpdateToOneWithWhereWithoutUserInput, NotificationPermissionAdminUpdateWithoutUserInput>, NotificationPermissionAdminUncheckedUpdateWithoutUserInput>
  }

  export type NotificationProvisionUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationProvisionCreateWithoutUserInput, NotificationProvisionUncheckedCreateWithoutUserInput> | NotificationProvisionCreateWithoutUserInput[] | NotificationProvisionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationProvisionCreateOrConnectWithoutUserInput | NotificationProvisionCreateOrConnectWithoutUserInput[]
    upsert?: NotificationProvisionUpsertWithWhereUniqueWithoutUserInput | NotificationProvisionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationProvisionCreateManyUserInputEnvelope
    set?: NotificationProvisionWhereUniqueInput | NotificationProvisionWhereUniqueInput[]
    disconnect?: NotificationProvisionWhereUniqueInput | NotificationProvisionWhereUniqueInput[]
    delete?: NotificationProvisionWhereUniqueInput | NotificationProvisionWhereUniqueInput[]
    connect?: NotificationProvisionWhereUniqueInput | NotificationProvisionWhereUniqueInput[]
    update?: NotificationProvisionUpdateWithWhereUniqueWithoutUserInput | NotificationProvisionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationProvisionUpdateManyWithWhereWithoutUserInput | NotificationProvisionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationProvisionScalarWhereInput | NotificationProvisionScalarWhereInput[]
  }

  export type OtpVerificationUpdateOneWithoutUserNestedInput = {
    create?: XOR<OtpVerificationCreateWithoutUserInput, OtpVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: OtpVerificationCreateOrConnectWithoutUserInput
    upsert?: OtpVerificationUpsertWithoutUserInput
    disconnect?: OtpVerificationWhereInput | boolean
    delete?: OtpVerificationWhereInput | boolean
    connect?: OtpVerificationWhereUniqueInput
    update?: XOR<XOR<OtpVerificationUpdateToOneWithWhereWithoutUserInput, OtpVerificationUpdateWithoutUserInput>, OtpVerificationUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutUserInput | ActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutUserInput | ActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutUserInput | ActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ClientUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput
    upsert?: ClientUpsertWithoutUserInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutUserInput, ClientUpdateWithoutUserInput>, ClientUncheckedUpdateWithoutUserInput>
  }

  export type ManagerUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutUserInput
    upsert?: ManagerUpsertWithoutUserInput
    disconnect?: ManagerWhereInput | boolean
    delete?: ManagerWhereInput | boolean
    connect?: ManagerWhereUniqueInput
    update?: XOR<XOR<ManagerUpdateToOneWithWhereWithoutUserInput, ManagerUpdateWithoutUserInput>, ManagerUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    upsert?: EmployeeUpsertWithoutUserInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutUserInput, EmployeeUpdateWithoutUserInput>, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type ViewerUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ViewerCreateWithoutUserInput, ViewerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ViewerCreateOrConnectWithoutUserInput
    upsert?: ViewerUpsertWithoutUserInput
    disconnect?: ViewerWhereInput | boolean
    delete?: ViewerWhereInput | boolean
    connect?: ViewerWhereUniqueInput
    update?: XOR<XOR<ViewerUpdateToOneWithWhereWithoutUserInput, ViewerUpdateWithoutUserInput>, ViewerUncheckedUpdateWithoutUserInput>
  }

  export type SupporterUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SupporterCreateWithoutUserInput, SupporterUncheckedCreateWithoutUserInput>
    connectOrCreate?: SupporterCreateOrConnectWithoutUserInput
    upsert?: SupporterUpsertWithoutUserInput
    disconnect?: SupporterWhereInput | boolean
    delete?: SupporterWhereInput | boolean
    connect?: SupporterWhereUniqueInput
    update?: XOR<XOR<SupporterUpdateToOneWithWhereWithoutUserInput, SupporterUpdateWithoutUserInput>, SupporterUncheckedUpdateWithoutUserInput>
  }

  export type SuperAdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SuperAdminCreateWithoutUserInput, SuperAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutUserInput
    upsert?: SuperAdminUpsertWithoutUserInput
    disconnect?: SuperAdminWhereInput | boolean
    delete?: SuperAdminWhereInput | boolean
    connect?: SuperAdminWhereUniqueInput
    update?: XOR<XOR<SuperAdminUpdateToOneWithWhereWithoutUserInput, SuperAdminUpdateWithoutUserInput>, SuperAdminUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPermissionEmployeeUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPermissionEmployeeCreateWithoutUserInput, NotificationPermissionEmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionEmployeeCreateOrConnectWithoutUserInput
    upsert?: NotificationPermissionEmployeeUpsertWithoutUserInput
    disconnect?: NotificationPermissionEmployeeWhereInput | boolean
    delete?: NotificationPermissionEmployeeWhereInput | boolean
    connect?: NotificationPermissionEmployeeWhereUniqueInput
    update?: XOR<XOR<NotificationPermissionEmployeeUpdateToOneWithWhereWithoutUserInput, NotificationPermissionEmployeeUpdateWithoutUserInput>, NotificationPermissionEmployeeUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPermissionManagerUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPermissionManagerCreateWithoutUserInput, NotificationPermissionManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionManagerCreateOrConnectWithoutUserInput
    upsert?: NotificationPermissionManagerUpsertWithoutUserInput
    disconnect?: NotificationPermissionManagerWhereInput | boolean
    delete?: NotificationPermissionManagerWhereInput | boolean
    connect?: NotificationPermissionManagerWhereUniqueInput
    update?: XOR<XOR<NotificationPermissionManagerUpdateToOneWithWhereWithoutUserInput, NotificationPermissionManagerUpdateWithoutUserInput>, NotificationPermissionManagerUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPermissionClientUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPermissionClientCreateWithoutUserInput, NotificationPermissionClientUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionClientCreateOrConnectWithoutUserInput
    upsert?: NotificationPermissionClientUpsertWithoutUserInput
    disconnect?: NotificationPermissionClientWhereInput | boolean
    delete?: NotificationPermissionClientWhereInput | boolean
    connect?: NotificationPermissionClientWhereUniqueInput
    update?: XOR<XOR<NotificationPermissionClientUpdateToOneWithWhereWithoutUserInput, NotificationPermissionClientUpdateWithoutUserInput>, NotificationPermissionClientUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPermissionSupporterUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPermissionSupporterCreateWithoutUserInput, NotificationPermissionSupporterUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionSupporterCreateOrConnectWithoutUserInput
    upsert?: NotificationPermissionSupporterUpsertWithoutUserInput
    disconnect?: NotificationPermissionSupporterWhereInput | boolean
    delete?: NotificationPermissionSupporterWhereInput | boolean
    connect?: NotificationPermissionSupporterWhereUniqueInput
    update?: XOR<XOR<NotificationPermissionSupporterUpdateToOneWithWhereWithoutUserInput, NotificationPermissionSupporterUpdateWithoutUserInput>, NotificationPermissionSupporterUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPermissionAdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPermissionAdminCreateWithoutUserInput, NotificationPermissionAdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPermissionAdminCreateOrConnectWithoutUserInput
    upsert?: NotificationPermissionAdminUpsertWithoutUserInput
    disconnect?: NotificationPermissionAdminWhereInput | boolean
    delete?: NotificationPermissionAdminWhereInput | boolean
    connect?: NotificationPermissionAdminWhereUniqueInput
    update?: XOR<XOR<NotificationPermissionAdminUpdateToOneWithWhereWithoutUserInput, NotificationPermissionAdminUpdateWithoutUserInput>, NotificationPermissionAdminUncheckedUpdateWithoutUserInput>
  }

  export type NotificationProvisionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationProvisionCreateWithoutUserInput, NotificationProvisionUncheckedCreateWithoutUserInput> | NotificationProvisionCreateWithoutUserInput[] | NotificationProvisionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationProvisionCreateOrConnectWithoutUserInput | NotificationProvisionCreateOrConnectWithoutUserInput[]
    upsert?: NotificationProvisionUpsertWithWhereUniqueWithoutUserInput | NotificationProvisionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationProvisionCreateManyUserInputEnvelope
    set?: NotificationProvisionWhereUniqueInput | NotificationProvisionWhereUniqueInput[]
    disconnect?: NotificationProvisionWhereUniqueInput | NotificationProvisionWhereUniqueInput[]
    delete?: NotificationProvisionWhereUniqueInput | NotificationProvisionWhereUniqueInput[]
    connect?: NotificationProvisionWhereUniqueInput | NotificationProvisionWhereUniqueInput[]
    update?: NotificationProvisionUpdateWithWhereUniqueWithoutUserInput | NotificationProvisionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationProvisionUpdateManyWithWhereWithoutUserInput | NotificationProvisionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationProvisionScalarWhereInput | NotificationProvisionScalarWhereInput[]
  }

  export type OtpVerificationUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<OtpVerificationCreateWithoutUserInput, OtpVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: OtpVerificationCreateOrConnectWithoutUserInput
    upsert?: OtpVerificationUpsertWithoutUserInput
    disconnect?: OtpVerificationWhereInput | boolean
    delete?: OtpVerificationWhereInput | boolean
    connect?: OtpVerificationWhereUniqueInput
    update?: XOR<XOR<OtpVerificationUpdateToOneWithWhereWithoutUserInput, OtpVerificationUpdateWithoutUserInput>, OtpVerificationUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutUserInput | ActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutUserInput | ActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutUserInput | ActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type TagCreatetagsInput = {
    set: string[]
  }

  export type ClientCreateNestedOneWithoutTagsInput = {
    create?: XOR<ClientCreateWithoutTagsInput, ClientUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutTagsInput
    connect?: ClientWhereUniqueInput
  }

  export type TagUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ClientUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<ClientCreateWithoutTagsInput, ClientUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutTagsInput
    upsert?: ClientUpsertWithoutTagsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutTagsInput, ClientUpdateWithoutTagsInput>, ClientUncheckedUpdateWithoutTagsInput>
  }

  export type ClientCreateNestedOneWithoutReferredPersonsInput = {
    create?: XOR<ClientCreateWithoutReferredPersonsInput, ClientUncheckedCreateWithoutReferredPersonsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutReferredPersonsInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutReferredPersonsNestedInput = {
    create?: XOR<ClientCreateWithoutReferredPersonsInput, ClientUncheckedCreateWithoutReferredPersonsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutReferredPersonsInput
    upsert?: ClientUpsertWithoutReferredPersonsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutReferredPersonsInput, ClientUpdateWithoutReferredPersonsInput>, ClientUncheckedUpdateWithoutReferredPersonsInput>
  }

  export type ProjectCreateNestedOneWithoutRequestsToAddProjectMemberInput = {
    create?: XOR<ProjectCreateWithoutRequestsToAddProjectMemberInput, ProjectUncheckedCreateWithoutRequestsToAddProjectMemberInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRequestsToAddProjectMemberInput
    connect?: ProjectWhereUniqueInput
  }

  export type ManagerCreateNestedOneWithoutRequestsToAddProjectMemberInput = {
    create?: XOR<ManagerCreateWithoutRequestsToAddProjectMemberInput, ManagerUncheckedCreateWithoutRequestsToAddProjectMemberInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutRequestsToAddProjectMemberInput
    connect?: ManagerWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutRequestsToAddProjectMemberNestedInput = {
    create?: XOR<ProjectCreateWithoutRequestsToAddProjectMemberInput, ProjectUncheckedCreateWithoutRequestsToAddProjectMemberInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRequestsToAddProjectMemberInput
    upsert?: ProjectUpsertWithoutRequestsToAddProjectMemberInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutRequestsToAddProjectMemberInput, ProjectUpdateWithoutRequestsToAddProjectMemberInput>, ProjectUncheckedUpdateWithoutRequestsToAddProjectMemberInput>
  }

  export type ManagerUpdateOneRequiredWithoutRequestsToAddProjectMemberNestedInput = {
    create?: XOR<ManagerCreateWithoutRequestsToAddProjectMemberInput, ManagerUncheckedCreateWithoutRequestsToAddProjectMemberInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutRequestsToAddProjectMemberInput
    upsert?: ManagerUpsertWithoutRequestsToAddProjectMemberInput
    connect?: ManagerWhereUniqueInput
    update?: XOR<XOR<ManagerUpdateToOneWithWhereWithoutRequestsToAddProjectMemberInput, ManagerUpdateWithoutRequestsToAddProjectMemberInput>, ManagerUncheckedUpdateWithoutRequestsToAddProjectMemberInput>
  }

  export type UserCreateNestedOneWithoutViewerInput = {
    create?: XOR<UserCreateWithoutViewerInput, UserUncheckedCreateWithoutViewerInput>
    connectOrCreate?: UserCreateOrConnectWithoutViewerInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutViewerNestedInput = {
    create?: XOR<UserCreateWithoutViewerInput, UserUncheckedCreateWithoutViewerInput>
    connectOrCreate?: UserCreateOrConnectWithoutViewerInput
    upsert?: UserUpsertWithoutViewerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutViewerInput, UserUpdateWithoutViewerInput>, UserUncheckedUpdateWithoutViewerInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumActivityActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityActionType | EnumActivityActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityActionType[] | ListEnumActivityActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityActionType[] | ListEnumActivityActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityActionTypeFilter<$PrismaModel> | $Enums.ActivityActionType
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumActivityActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityActionType | EnumActivityActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityActionType[] | ListEnumActivityActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityActionType[] | ListEnumActivityActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityActionTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityActionTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumIndustryCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.IndustryCategory | EnumIndustryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.IndustryCategory[] | ListEnumIndustryCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.IndustryCategory[] | ListEnumIndustryCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumIndustryCategoryFilter<$PrismaModel> | $Enums.IndustryCategory
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumIndustryCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IndustryCategory | EnumIndustryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.IndustryCategory[] | ListEnumIndustryCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.IndustryCategory[] | ListEnumIndustryCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumIndustryCategoryWithAggregatesFilter<$PrismaModel> | $Enums.IndustryCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIndustryCategoryFilter<$PrismaModel>
    _max?: NestedEnumIndustryCategoryFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumProjectCycleFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectCycle | EnumProjectCycleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectCycle[] | ListEnumProjectCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectCycle[] | ListEnumProjectCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectCycleFilter<$PrismaModel> | $Enums.ProjectCycle
  }

  export type NestedEnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumProjectCycleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectCycle | EnumProjectCycleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectCycle[] | ListEnumProjectCycleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectCycle[] | ListEnumProjectCycleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectCycleWithAggregatesFilter<$PrismaModel> | $Enums.ProjectCycle
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectCycleFilter<$PrismaModel>
    _max?: NestedEnumProjectCycleFilter<$PrismaModel>
  }

  export type NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumSubmittedStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmittedStatus | EnumSubmittedStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmittedStatus[] | ListEnumSubmittedStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmittedStatus[] | ListEnumSubmittedStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmittedStatusFilter<$PrismaModel> | $Enums.SubmittedStatus
  }

  export type NestedEnumSubmittedStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmittedStatus | EnumSubmittedStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmittedStatus[] | ListEnumSubmittedStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmittedStatus[] | ListEnumSubmittedStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmittedStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubmittedStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubmittedStatusFilter<$PrismaModel>
    _max?: NestedEnumSubmittedStatusFilter<$PrismaModel>
  }

  export type NestedEnumSupporterRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.SupporterRole | EnumSupporterRoleFieldRefInput<$PrismaModel>
    in?: $Enums.SupporterRole[] | ListEnumSupporterRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupporterRole[] | ListEnumSupporterRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumSupporterRoleFilter<$PrismaModel> | $Enums.SupporterRole
  }

  export type NestedEnumSupporterRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SupporterRole | EnumSupporterRoleFieldRefInput<$PrismaModel>
    in?: $Enums.SupporterRole[] | ListEnumSupporterRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupporterRole[] | ListEnumSupporterRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumSupporterRoleWithAggregatesFilter<$PrismaModel> | $Enums.SupporterRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSupporterRoleFilter<$PrismaModel>
    _max?: NestedEnumSupporterRoleFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskStatusNullableFilter<$PrismaModel> | $Enums.TaskStatus | null
  }

  export type NestedEnumTaskStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type NestedEnumIssueTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IssueType | EnumIssueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IssueType[] | ListEnumIssueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssueType[] | ListEnumIssueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIssueTypeFilter<$PrismaModel> | $Enums.IssueType
  }

  export type NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type NestedEnumIssueTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IssueType | EnumIssueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IssueType[] | ListEnumIssueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssueType[] | ListEnumIssueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIssueTypeWithAggregatesFilter<$PrismaModel> | $Enums.IssueType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIssueTypeFilter<$PrismaModel>
    _max?: NestedEnumIssueTypeFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumLanguageFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageFilter<$PrismaModel> | $Enums.Language
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumLanguageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Language | EnumLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.Language[] | ListEnumLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumLanguageWithAggregatesFilter<$PrismaModel> | $Enums.Language
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLanguageFilter<$PrismaModel>
    _max?: NestedEnumLanguageFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type ProjectCreateWithoutActivitiesInput = {
    id?: string
    name: string
    uploadbeforeday: string
    uploadCycle: $Enums.ProjectCycle
    description: string
    dataReceivedTime?: string | null
    beforeSubmitData?: number | null
    weakuploadData?: ProjectCreateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectCreatemonthlyuploadDataInput | string[]
    status?: $Enums.ProjectStatus
    priority: $Enums.Priority
    deadline: Date | string
    startDate?: Date | string | null
    progress?: number | null
    chartList?: ProjectCreatechartListInput | string[]
    estimatedCompletedDate?: Date | string | null
    currentRate?: string | null
    budget?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    latitude?: number | null
    longitude?: number | null
    program: ProgramCreateNestedOneWithoutProjectsInput
    manager: ManagerCreateNestedOneWithoutProjectsInput
    projectEmployees?: ProjectEmployeeCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    reviews?: ReviewCreateNestedManyWithoutProjectInput
    requestsToAddProjectMember?: RequestToAddProjectMemberCreateNestedManyWithoutProjectInput
    submitted?: SubmittedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutActivitiesInput = {
    id?: string
    programId: string
    name: string
    uploadbeforeday: string
    uploadCycle: $Enums.ProjectCycle
    description: string
    dataReceivedTime?: string | null
    beforeSubmitData?: number | null
    weakuploadData?: ProjectCreateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectCreatemonthlyuploadDataInput | string[]
    status?: $Enums.ProjectStatus
    priority: $Enums.Priority
    deadline: Date | string
    managerId: string
    startDate?: Date | string | null
    progress?: number | null
    chartList?: ProjectCreatechartListInput | string[]
    estimatedCompletedDate?: Date | string | null
    currentRate?: string | null
    budget?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    latitude?: number | null
    longitude?: number | null
    projectEmployees?: ProjectEmployeeUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProjectInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    submitted?: SubmittedUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutActivitiesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutActivitiesInput, ProjectUncheckedCreateWithoutActivitiesInput>
  }

  export type UserCreateWithoutActivitiesInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientCreateNestedOneWithoutUserInput
    manager?: ManagerCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    viewer?: ViewerCreateNestedOneWithoutUserInput
    supporter?: SupporterCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivitiesInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    viewer?: ViewerUncheckedCreateNestedOneWithoutUserInput
    supporter?: SupporterUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerUncheckedCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientUncheckedCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionUncheckedCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
  }

  export type ProjectUpsertWithoutActivitiesInput = {
    update: XOR<ProjectUpdateWithoutActivitiesInput, ProjectUncheckedUpdateWithoutActivitiesInput>
    create: XOR<ProjectCreateWithoutActivitiesInput, ProjectUncheckedCreateWithoutActivitiesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutActivitiesInput, ProjectUncheckedUpdateWithoutActivitiesInput>
  }

  export type ProjectUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uploadbeforeday?: StringFieldUpdateOperationsInput | string
    uploadCycle?: EnumProjectCycleFieldUpdateOperationsInput | $Enums.ProjectCycle
    description?: StringFieldUpdateOperationsInput | string
    dataReceivedTime?: NullableStringFieldUpdateOperationsInput | string | null
    beforeSubmitData?: NullableIntFieldUpdateOperationsInput | number | null
    weakuploadData?: ProjectUpdateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectUpdatemonthlyuploadDataInput | string[]
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    chartList?: ProjectUpdatechartListInput | string[]
    estimatedCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentRate?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    program?: ProgramUpdateOneRequiredWithoutProjectsNestedInput
    manager?: ManagerUpdateOneRequiredWithoutProjectsNestedInput
    projectEmployees?: ProjectEmployeeUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    reviews?: ReviewUpdateManyWithoutProjectNestedInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUpdateManyWithoutProjectNestedInput
    submitted?: SubmittedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uploadbeforeday?: StringFieldUpdateOperationsInput | string
    uploadCycle?: EnumProjectCycleFieldUpdateOperationsInput | $Enums.ProjectCycle
    description?: StringFieldUpdateOperationsInput | string
    dataReceivedTime?: NullableStringFieldUpdateOperationsInput | string | null
    beforeSubmitData?: NullableIntFieldUpdateOperationsInput | number | null
    weakuploadData?: ProjectUpdateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectUpdatemonthlyuploadDataInput | string[]
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    chartList?: ProjectUpdatechartListInput | string[]
    estimatedCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentRate?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    projectEmployees?: ProjectEmployeeUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProjectNestedInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    submitted?: SubmittedUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutActivitiesInput = {
    update: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUpdateOneWithoutUserNestedInput
    manager?: ManagerUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    viewer?: ViewerUpdateOneWithoutUserNestedInput
    supporter?: SupporterUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    viewer?: ViewerUncheckedUpdateOneWithoutUserNestedInput
    supporter?: SupporterUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUncheckedUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUncheckedUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUncheckedUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutClientInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    manager?: ManagerCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    viewer?: ViewerCreateNestedOneWithoutUserInput
    supporter?: SupporterCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClientInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    viewer?: ViewerUncheckedCreateNestedOneWithoutUserInput
    supporter?: SupporterUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerUncheckedCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientUncheckedCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionUncheckedCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
  }

  export type ReferredPersonCreateWithoutClientInput = {
    id?: string
    name: string
    email?: string | null
    phoneNumber?: number | null
    aboutThere?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferredPersonUncheckedCreateWithoutClientInput = {
    id?: string
    name: string
    email?: string | null
    phoneNumber?: number | null
    aboutThere?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferredPersonCreateOrConnectWithoutClientInput = {
    where: ReferredPersonWhereUniqueInput
    create: XOR<ReferredPersonCreateWithoutClientInput, ReferredPersonUncheckedCreateWithoutClientInput>
  }

  export type ReferredPersonCreateManyClientInputEnvelope = {
    data: ReferredPersonCreateManyClientInput | ReferredPersonCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutClientInput = {
    id?: string
    supporterIds?: TicketCreatesupporterIdsInput | string[]
    adminIds?: TicketCreateadminIdsInput | string[]
    companyName?: string | null
    subject: string
    status?: $Enums.TicketStatus
    priority: $Enums.Priority
    issue: string
    adminNote?: string | null
    attachFile?: string | null
    issueType: $Enums.IssueType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketUncheckedCreateWithoutClientInput = {
    id?: string
    supporterIds?: TicketCreatesupporterIdsInput | string[]
    adminIds?: TicketCreateadminIdsInput | string[]
    companyName?: string | null
    subject: string
    status?: $Enums.TicketStatus
    priority: $Enums.Priority
    issue: string
    adminNote?: string | null
    attachFile?: string | null
    issueType: $Enums.IssueType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateOrConnectWithoutClientInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput>
  }

  export type TicketCreateManyClientInputEnvelope = {
    data: TicketCreateManyClientInput | TicketCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ProgramCreateWithoutClientInput = {
    id?: string
    programName: string
    datetime: string
    programDescription: string
    priority: string
    deadline: string
    progress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutClientInput = {
    id?: string
    programName: string
    datetime: string
    programDescription: string
    priority: string
    deadline: string
    progress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutClientInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutClientInput, ProgramUncheckedCreateWithoutClientInput>
  }

  export type ProgramCreateManyClientInputEnvelope = {
    data: ProgramCreateManyClientInput | ProgramCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutClientInput = {
    tags?: TagCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUncheckedCreateWithoutClientInput = {
    tags?: TagCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagCreateOrConnectWithoutClientInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutClientInput, TagUncheckedCreateWithoutClientInput>
  }

  export type UserUpsertWithoutClientInput = {
    update: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
  }

  export type UserUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    manager?: ManagerUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    viewer?: ViewerUpdateOneWithoutUserNestedInput
    supporter?: SupporterUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    viewer?: ViewerUncheckedUpdateOneWithoutUserNestedInput
    supporter?: SupporterUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUncheckedUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUncheckedUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUncheckedUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReferredPersonUpsertWithWhereUniqueWithoutClientInput = {
    where: ReferredPersonWhereUniqueInput
    update: XOR<ReferredPersonUpdateWithoutClientInput, ReferredPersonUncheckedUpdateWithoutClientInput>
    create: XOR<ReferredPersonCreateWithoutClientInput, ReferredPersonUncheckedCreateWithoutClientInput>
  }

  export type ReferredPersonUpdateWithWhereUniqueWithoutClientInput = {
    where: ReferredPersonWhereUniqueInput
    data: XOR<ReferredPersonUpdateWithoutClientInput, ReferredPersonUncheckedUpdateWithoutClientInput>
  }

  export type ReferredPersonUpdateManyWithWhereWithoutClientInput = {
    where: ReferredPersonScalarWhereInput
    data: XOR<ReferredPersonUpdateManyMutationInput, ReferredPersonUncheckedUpdateManyWithoutClientInput>
  }

  export type ReferredPersonScalarWhereInput = {
    AND?: ReferredPersonScalarWhereInput | ReferredPersonScalarWhereInput[]
    OR?: ReferredPersonScalarWhereInput[]
    NOT?: ReferredPersonScalarWhereInput | ReferredPersonScalarWhereInput[]
    id?: StringFilter<"ReferredPerson"> | string
    name?: StringFilter<"ReferredPerson"> | string
    userId?: StringFilter<"ReferredPerson"> | string
    email?: StringNullableFilter<"ReferredPerson"> | string | null
    phoneNumber?: IntNullableFilter<"ReferredPerson"> | number | null
    aboutThere?: StringNullableFilter<"ReferredPerson"> | string | null
    createdAt?: DateTimeFilter<"ReferredPerson"> | Date | string
    updatedAt?: DateTimeFilter<"ReferredPerson"> | Date | string
  }

  export type TicketUpsertWithWhereUniqueWithoutClientInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutClientInput, TicketUncheckedUpdateWithoutClientInput>
    create: XOR<TicketCreateWithoutClientInput, TicketUncheckedCreateWithoutClientInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutClientInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutClientInput, TicketUncheckedUpdateWithoutClientInput>
  }

  export type TicketUpdateManyWithWhereWithoutClientInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutClientInput>
  }

  export type TicketScalarWhereInput = {
    AND?: TicketScalarWhereInput | TicketScalarWhereInput[]
    OR?: TicketScalarWhereInput[]
    NOT?: TicketScalarWhereInput | TicketScalarWhereInput[]
    id?: StringFilter<"Ticket"> | string
    clientId?: StringFilter<"Ticket"> | string
    supporterIds?: StringNullableListFilter<"Ticket">
    adminIds?: StringNullableListFilter<"Ticket">
    companyName?: StringNullableFilter<"Ticket"> | string | null
    subject?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumPriorityFilter<"Ticket"> | $Enums.Priority
    issue?: StringFilter<"Ticket"> | string
    adminNote?: StringNullableFilter<"Ticket"> | string | null
    attachFile?: StringNullableFilter<"Ticket"> | string | null
    issueType?: EnumIssueTypeFilter<"Ticket"> | $Enums.IssueType
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
  }

  export type ProgramUpsertWithWhereUniqueWithoutClientInput = {
    where: ProgramWhereUniqueInput
    update: XOR<ProgramUpdateWithoutClientInput, ProgramUncheckedUpdateWithoutClientInput>
    create: XOR<ProgramCreateWithoutClientInput, ProgramUncheckedCreateWithoutClientInput>
  }

  export type ProgramUpdateWithWhereUniqueWithoutClientInput = {
    where: ProgramWhereUniqueInput
    data: XOR<ProgramUpdateWithoutClientInput, ProgramUncheckedUpdateWithoutClientInput>
  }

  export type ProgramUpdateManyWithWhereWithoutClientInput = {
    where: ProgramScalarWhereInput
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyWithoutClientInput>
  }

  export type ProgramScalarWhereInput = {
    AND?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
    OR?: ProgramScalarWhereInput[]
    NOT?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
    id?: StringFilter<"Program"> | string
    userId?: StringFilter<"Program"> | string
    programName?: StringFilter<"Program"> | string
    datetime?: StringFilter<"Program"> | string
    programDescription?: StringFilter<"Program"> | string
    priority?: StringFilter<"Program"> | string
    deadline?: StringFilter<"Program"> | string
    progress?: IntNullableFilter<"Program"> | number | null
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeFilter<"Program"> | Date | string
  }

  export type TagUpsertWithoutClientInput = {
    update: XOR<TagUpdateWithoutClientInput, TagUncheckedUpdateWithoutClientInput>
    create: XOR<TagCreateWithoutClientInput, TagUncheckedCreateWithoutClientInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutClientInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutClientInput, TagUncheckedUpdateWithoutClientInput>
  }

  export type TagUpdateWithoutClientInput = {
    tags?: TagUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateWithoutClientInput = {
    tags?: TagUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutEmployeeInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientCreateNestedOneWithoutUserInput
    manager?: ManagerCreateNestedOneWithoutUserInput
    viewer?: ViewerCreateNestedOneWithoutUserInput
    supporter?: SupporterCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmployeeInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    viewer?: ViewerUncheckedCreateNestedOneWithoutUserInput
    supporter?: SupporterUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerUncheckedCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientUncheckedCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionUncheckedCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmployeeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
  }

  export type ProjectEmployeeCreateWithoutEmployeeInput = {
    id?: string
    assignedAt?: Date | string
    project: ProjectCreateNestedOneWithoutProjectEmployeesInput
  }

  export type ProjectEmployeeUncheckedCreateWithoutEmployeeInput = {
    id?: string
    projectId: string
    assignedAt?: Date | string
  }

  export type ProjectEmployeeCreateOrConnectWithoutEmployeeInput = {
    where: ProjectEmployeeWhereUniqueInput
    create: XOR<ProjectEmployeeCreateWithoutEmployeeInput, ProjectEmployeeUncheckedCreateWithoutEmployeeInput>
  }

  export type ProjectEmployeeCreateManyEmployeeInputEnvelope = {
    data: ProjectEmployeeCreateManyEmployeeInput | ProjectEmployeeCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type SubmittedCreateWithoutEmployeeInput = {
    id?: string
    information: string
    submission: string
    status?: $Enums.SubmittedStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSubmittedInput
    sheet: SheetCreateNestedOneWithoutSubmittedInput
    submissionReturn?: SubmissionReturnCreateNestedOneWithoutSubmittedInput
  }

  export type SubmittedUncheckedCreateWithoutEmployeeInput = {
    id?: string
    information: string
    submission: string
    status?: $Enums.SubmittedStatus
    projectId: string
    sheetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    submissionReturn?: SubmissionReturnUncheckedCreateNestedOneWithoutSubmittedInput
  }

  export type SubmittedCreateOrConnectWithoutEmployeeInput = {
    where: SubmittedWhereUniqueInput
    create: XOR<SubmittedCreateWithoutEmployeeInput, SubmittedUncheckedCreateWithoutEmployeeInput>
  }

  export type SubmittedCreateManyEmployeeInputEnvelope = {
    data: SubmittedCreateManyEmployeeInput | SubmittedCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEmployeeInput = {
    update: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type UserUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUpdateOneWithoutUserNestedInput
    manager?: ManagerUpdateOneWithoutUserNestedInput
    viewer?: ViewerUpdateOneWithoutUserNestedInput
    supporter?: SupporterUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    viewer?: ViewerUncheckedUpdateOneWithoutUserNestedInput
    supporter?: SupporterUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUncheckedUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUncheckedUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUncheckedUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectEmployeeUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: ProjectEmployeeWhereUniqueInput
    update: XOR<ProjectEmployeeUpdateWithoutEmployeeInput, ProjectEmployeeUncheckedUpdateWithoutEmployeeInput>
    create: XOR<ProjectEmployeeCreateWithoutEmployeeInput, ProjectEmployeeUncheckedCreateWithoutEmployeeInput>
  }

  export type ProjectEmployeeUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: ProjectEmployeeWhereUniqueInput
    data: XOR<ProjectEmployeeUpdateWithoutEmployeeInput, ProjectEmployeeUncheckedUpdateWithoutEmployeeInput>
  }

  export type ProjectEmployeeUpdateManyWithWhereWithoutEmployeeInput = {
    where: ProjectEmployeeScalarWhereInput
    data: XOR<ProjectEmployeeUpdateManyMutationInput, ProjectEmployeeUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type ProjectEmployeeScalarWhereInput = {
    AND?: ProjectEmployeeScalarWhereInput | ProjectEmployeeScalarWhereInput[]
    OR?: ProjectEmployeeScalarWhereInput[]
    NOT?: ProjectEmployeeScalarWhereInput | ProjectEmployeeScalarWhereInput[]
    id?: StringFilter<"ProjectEmployee"> | string
    projectId?: StringFilter<"ProjectEmployee"> | string
    employeeId?: StringFilter<"ProjectEmployee"> | string
    assignedAt?: DateTimeFilter<"ProjectEmployee"> | Date | string
  }

  export type SubmittedUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: SubmittedWhereUniqueInput
    update: XOR<SubmittedUpdateWithoutEmployeeInput, SubmittedUncheckedUpdateWithoutEmployeeInput>
    create: XOR<SubmittedCreateWithoutEmployeeInput, SubmittedUncheckedCreateWithoutEmployeeInput>
  }

  export type SubmittedUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: SubmittedWhereUniqueInput
    data: XOR<SubmittedUpdateWithoutEmployeeInput, SubmittedUncheckedUpdateWithoutEmployeeInput>
  }

  export type SubmittedUpdateManyWithWhereWithoutEmployeeInput = {
    where: SubmittedScalarWhereInput
    data: XOR<SubmittedUpdateManyMutationInput, SubmittedUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type SubmittedScalarWhereInput = {
    AND?: SubmittedScalarWhereInput | SubmittedScalarWhereInput[]
    OR?: SubmittedScalarWhereInput[]
    NOT?: SubmittedScalarWhereInput | SubmittedScalarWhereInput[]
    id?: StringFilter<"Submitted"> | string
    information?: StringFilter<"Submitted"> | string
    submission?: StringFilter<"Submitted"> | string
    status?: EnumSubmittedStatusFilter<"Submitted"> | $Enums.SubmittedStatus
    employeeId?: StringFilter<"Submitted"> | string
    projectId?: StringFilter<"Submitted"> | string
    sheetId?: StringFilter<"Submitted"> | string
    createdAt?: DateTimeFilter<"Submitted"> | Date | string
    updatedAt?: DateTimeFilter<"Submitted"> | Date | string
  }

  export type UserCreateWithoutOtpVerificationInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientCreateNestedOneWithoutUserInput
    manager?: ManagerCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    viewer?: ViewerCreateNestedOneWithoutUserInput
    supporter?: SupporterCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOtpVerificationInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    viewer?: ViewerUncheckedCreateNestedOneWithoutUserInput
    supporter?: SupporterUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerUncheckedCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientUncheckedCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOtpVerificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOtpVerificationInput, UserUncheckedCreateWithoutOtpVerificationInput>
  }

  export type UserUpsertWithoutOtpVerificationInput = {
    update: XOR<UserUpdateWithoutOtpVerificationInput, UserUncheckedUpdateWithoutOtpVerificationInput>
    create: XOR<UserCreateWithoutOtpVerificationInput, UserUncheckedCreateWithoutOtpVerificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOtpVerificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOtpVerificationInput, UserUncheckedUpdateWithoutOtpVerificationInput>
  }

  export type UserUpdateWithoutOtpVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUpdateOneWithoutUserNestedInput
    manager?: ManagerUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    viewer?: ViewerUpdateOneWithoutUserNestedInput
    supporter?: SupporterUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOtpVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    viewer?: ViewerUncheckedUpdateOneWithoutUserNestedInput
    supporter?: SupporterUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUncheckedUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUncheckedUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPaymentsInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientCreateNestedOneWithoutUserInput
    manager?: ManagerCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    viewer?: ViewerCreateNestedOneWithoutUserInput
    supporter?: SupporterCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationCreateNestedOneWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    viewer?: ViewerUncheckedCreateNestedOneWithoutUserInput
    supporter?: SupporterUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerUncheckedCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientUncheckedCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionUncheckedCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationUncheckedCreateNestedOneWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUpdateOneWithoutUserNestedInput
    manager?: ManagerUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    viewer?: ViewerUpdateOneWithoutUserNestedInput
    supporter?: SupporterUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUpdateOneWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    viewer?: ViewerUncheckedUpdateOneWithoutUserNestedInput
    supporter?: SupporterUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUncheckedUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUncheckedUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUncheckedUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUncheckedUpdateOneWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutManagerInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    viewer?: ViewerCreateNestedOneWithoutUserInput
    supporter?: SupporterCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutManagerInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    viewer?: ViewerUncheckedCreateNestedOneWithoutUserInput
    supporter?: SupporterUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerUncheckedCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientUncheckedCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionUncheckedCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutManagerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput>
  }

  export type ProjectCreateWithoutManagerInput = {
    id?: string
    name: string
    uploadbeforeday: string
    uploadCycle: $Enums.ProjectCycle
    description: string
    dataReceivedTime?: string | null
    beforeSubmitData?: number | null
    weakuploadData?: ProjectCreateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectCreatemonthlyuploadDataInput | string[]
    status?: $Enums.ProjectStatus
    priority: $Enums.Priority
    deadline: Date | string
    startDate?: Date | string | null
    progress?: number | null
    chartList?: ProjectCreatechartListInput | string[]
    estimatedCompletedDate?: Date | string | null
    currentRate?: string | null
    budget?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    latitude?: number | null
    longitude?: number | null
    program: ProgramCreateNestedOneWithoutProjectsInput
    projectEmployees?: ProjectEmployeeCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    reviews?: ReviewCreateNestedManyWithoutProjectInput
    requestsToAddProjectMember?: RequestToAddProjectMemberCreateNestedManyWithoutProjectInput
    submitted?: SubmittedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutManagerInput = {
    id?: string
    programId: string
    name: string
    uploadbeforeday: string
    uploadCycle: $Enums.ProjectCycle
    description: string
    dataReceivedTime?: string | null
    beforeSubmitData?: number | null
    weakuploadData?: ProjectCreateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectCreatemonthlyuploadDataInput | string[]
    status?: $Enums.ProjectStatus
    priority: $Enums.Priority
    deadline: Date | string
    startDate?: Date | string | null
    progress?: number | null
    chartList?: ProjectCreatechartListInput | string[]
    estimatedCompletedDate?: Date | string | null
    currentRate?: string | null
    budget?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    latitude?: number | null
    longitude?: number | null
    projectEmployees?: ProjectEmployeeUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProjectInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    submitted?: SubmittedUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutManagerInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutManagerInput, ProjectUncheckedCreateWithoutManagerInput>
  }

  export type ProjectCreateManyManagerInputEnvelope = {
    data: ProjectCreateManyManagerInput | ProjectCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type RequestToAddProjectMemberCreateWithoutManagerInput = {
    id?: string
    clientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutRequestsToAddProjectMemberInput
  }

  export type RequestToAddProjectMemberUncheckedCreateWithoutManagerInput = {
    id?: string
    clientId?: string | null
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestToAddProjectMemberCreateOrConnectWithoutManagerInput = {
    where: RequestToAddProjectMemberWhereUniqueInput
    create: XOR<RequestToAddProjectMemberCreateWithoutManagerInput, RequestToAddProjectMemberUncheckedCreateWithoutManagerInput>
  }

  export type RequestToAddProjectMemberCreateManyManagerInputEnvelope = {
    data: RequestToAddProjectMemberCreateManyManagerInput | RequestToAddProjectMemberCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutManagerInput = {
    update: XOR<UserUpdateWithoutManagerInput, UserUncheckedUpdateWithoutManagerInput>
    create: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutManagerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutManagerInput, UserUncheckedUpdateWithoutManagerInput>
  }

  export type UserUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    viewer?: ViewerUpdateOneWithoutUserNestedInput
    supporter?: SupporterUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    viewer?: ViewerUncheckedUpdateOneWithoutUserNestedInput
    supporter?: SupporterUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUncheckedUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUncheckedUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUncheckedUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectUpsertWithWhereUniqueWithoutManagerInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutManagerInput, ProjectUncheckedUpdateWithoutManagerInput>
    create: XOR<ProjectCreateWithoutManagerInput, ProjectUncheckedCreateWithoutManagerInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutManagerInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutManagerInput, ProjectUncheckedUpdateWithoutManagerInput>
  }

  export type ProjectUpdateManyWithWhereWithoutManagerInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutManagerInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    programId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    uploadbeforeday?: StringFilter<"Project"> | string
    uploadCycle?: EnumProjectCycleFilter<"Project"> | $Enums.ProjectCycle
    description?: StringFilter<"Project"> | string
    dataReceivedTime?: StringNullableFilter<"Project"> | string | null
    beforeSubmitData?: IntNullableFilter<"Project"> | number | null
    weakuploadData?: StringNullableListFilter<"Project">
    monthlyuploadData?: StringNullableListFilter<"Project">
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    priority?: EnumPriorityFilter<"Project"> | $Enums.Priority
    deadline?: DateTimeFilter<"Project"> | Date | string
    managerId?: StringFilter<"Project"> | string
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    progress?: IntNullableFilter<"Project"> | number | null
    chartList?: StringNullableListFilter<"Project">
    estimatedCompletedDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    currentRate?: StringNullableFilter<"Project"> | string | null
    budget?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    latitude?: FloatNullableFilter<"Project"> | number | null
    longitude?: FloatNullableFilter<"Project"> | number | null
  }

  export type RequestToAddProjectMemberUpsertWithWhereUniqueWithoutManagerInput = {
    where: RequestToAddProjectMemberWhereUniqueInput
    update: XOR<RequestToAddProjectMemberUpdateWithoutManagerInput, RequestToAddProjectMemberUncheckedUpdateWithoutManagerInput>
    create: XOR<RequestToAddProjectMemberCreateWithoutManagerInput, RequestToAddProjectMemberUncheckedCreateWithoutManagerInput>
  }

  export type RequestToAddProjectMemberUpdateWithWhereUniqueWithoutManagerInput = {
    where: RequestToAddProjectMemberWhereUniqueInput
    data: XOR<RequestToAddProjectMemberUpdateWithoutManagerInput, RequestToAddProjectMemberUncheckedUpdateWithoutManagerInput>
  }

  export type RequestToAddProjectMemberUpdateManyWithWhereWithoutManagerInput = {
    where: RequestToAddProjectMemberScalarWhereInput
    data: XOR<RequestToAddProjectMemberUpdateManyMutationInput, RequestToAddProjectMemberUncheckedUpdateManyWithoutManagerInput>
  }

  export type RequestToAddProjectMemberScalarWhereInput = {
    AND?: RequestToAddProjectMemberScalarWhereInput | RequestToAddProjectMemberScalarWhereInput[]
    OR?: RequestToAddProjectMemberScalarWhereInput[]
    NOT?: RequestToAddProjectMemberScalarWhereInput | RequestToAddProjectMemberScalarWhereInput[]
    id?: StringFilter<"RequestToAddProjectMember"> | string
    clientId?: StringNullableFilter<"RequestToAddProjectMember"> | string | null
    projectId?: StringFilter<"RequestToAddProjectMember"> | string
    managerId?: StringFilter<"RequestToAddProjectMember"> | string
    createdAt?: DateTimeFilter<"RequestToAddProjectMember"> | Date | string
    updatedAt?: DateTimeFilter<"RequestToAddProjectMember"> | Date | string
  }

  export type NotificationProvisionCreateWithoutNotificationInput = {
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationProvisionUncheckedCreateWithoutNotificationInput = {
    userId: string
  }

  export type NotificationProvisionCreateOrConnectWithoutNotificationInput = {
    where: NotificationProvisionWhereUniqueInput
    create: XOR<NotificationProvisionCreateWithoutNotificationInput, NotificationProvisionUncheckedCreateWithoutNotificationInput>
  }

  export type NotificationProvisionCreateManyNotificationInputEnvelope = {
    data: NotificationProvisionCreateManyNotificationInput | NotificationProvisionCreateManyNotificationInput[]
    skipDuplicates?: boolean
  }

  export type NotificationProvisionUpsertWithWhereUniqueWithoutNotificationInput = {
    where: NotificationProvisionWhereUniqueInput
    update: XOR<NotificationProvisionUpdateWithoutNotificationInput, NotificationProvisionUncheckedUpdateWithoutNotificationInput>
    create: XOR<NotificationProvisionCreateWithoutNotificationInput, NotificationProvisionUncheckedCreateWithoutNotificationInput>
  }

  export type NotificationProvisionUpdateWithWhereUniqueWithoutNotificationInput = {
    where: NotificationProvisionWhereUniqueInput
    data: XOR<NotificationProvisionUpdateWithoutNotificationInput, NotificationProvisionUncheckedUpdateWithoutNotificationInput>
  }

  export type NotificationProvisionUpdateManyWithWhereWithoutNotificationInput = {
    where: NotificationProvisionScalarWhereInput
    data: XOR<NotificationProvisionUpdateManyMutationInput, NotificationProvisionUncheckedUpdateManyWithoutNotificationInput>
  }

  export type NotificationProvisionScalarWhereInput = {
    AND?: NotificationProvisionScalarWhereInput | NotificationProvisionScalarWhereInput[]
    OR?: NotificationProvisionScalarWhereInput[]
    NOT?: NotificationProvisionScalarWhereInput | NotificationProvisionScalarWhereInput[]
    userId?: StringFilter<"NotificationProvision"> | string
    notificationId?: StringFilter<"NotificationProvision"> | string
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientCreateNestedOneWithoutUserInput
    manager?: ManagerCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    viewer?: ViewerCreateNestedOneWithoutUserInput
    supporter?: SupporterCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminCreateNestedOneWithoutUserInput
    otpVerification?: OtpVerificationCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    viewer?: ViewerUncheckedCreateNestedOneWithoutUserInput
    supporter?: SupporterUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerUncheckedCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientUncheckedCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminUncheckedCreateNestedOneWithoutUserInput
    otpVerification?: OtpVerificationUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type NotificationCreateWithoutProvisionsInput = {
    id?: string
    senderId: string
    receiverIds?: NotificationCreatereceiverIdsInput | string[]
    context: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutProvisionsInput = {
    id?: string
    senderId: string
    receiverIds?: NotificationCreatereceiverIdsInput | string[]
    context: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutProvisionsInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutProvisionsInput, NotificationUncheckedCreateWithoutProvisionsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUpdateOneWithoutUserNestedInput
    manager?: ManagerUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    viewer?: ViewerUpdateOneWithoutUserNestedInput
    supporter?: SupporterUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUpdateOneWithoutUserNestedInput
    otpVerification?: OtpVerificationUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    viewer?: ViewerUncheckedUpdateOneWithoutUserNestedInput
    supporter?: SupporterUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUncheckedUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUncheckedUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUncheckedUpdateOneWithoutUserNestedInput
    otpVerification?: OtpVerificationUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NotificationUpsertWithoutProvisionsInput = {
    update: XOR<NotificationUpdateWithoutProvisionsInput, NotificationUncheckedUpdateWithoutProvisionsInput>
    create: XOR<NotificationCreateWithoutProvisionsInput, NotificationUncheckedCreateWithoutProvisionsInput>
    where?: NotificationWhereInput
  }

  export type NotificationUpdateToOneWithWhereWithoutProvisionsInput = {
    where?: NotificationWhereInput
    data: XOR<NotificationUpdateWithoutProvisionsInput, NotificationUncheckedUpdateWithoutProvisionsInput>
  }

  export type NotificationUpdateWithoutProvisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverIds?: NotificationUpdatereceiverIdsInput | string[]
    context?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutProvisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverIds?: NotificationUpdatereceiverIdsInput | string[]
    context?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutNotificationEmployeeInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientCreateNestedOneWithoutUserInput
    manager?: ManagerCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    viewer?: ViewerCreateNestedOneWithoutUserInput
    supporter?: SupporterCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationEmployeeInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    viewer?: ViewerUncheckedCreateNestedOneWithoutUserInput
    supporter?: SupporterUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerUncheckedCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientUncheckedCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionUncheckedCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationEmployeeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationEmployeeInput, UserUncheckedCreateWithoutNotificationEmployeeInput>
  }

  export type UserUpsertWithoutNotificationEmployeeInput = {
    update: XOR<UserUpdateWithoutNotificationEmployeeInput, UserUncheckedUpdateWithoutNotificationEmployeeInput>
    create: XOR<UserCreateWithoutNotificationEmployeeInput, UserUncheckedCreateWithoutNotificationEmployeeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationEmployeeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationEmployeeInput, UserUncheckedUpdateWithoutNotificationEmployeeInput>
  }

  export type UserUpdateWithoutNotificationEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUpdateOneWithoutUserNestedInput
    manager?: ManagerUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    viewer?: ViewerUpdateOneWithoutUserNestedInput
    supporter?: SupporterUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    viewer?: ViewerUncheckedUpdateOneWithoutUserNestedInput
    supporter?: SupporterUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUncheckedUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUncheckedUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUncheckedUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationManagerInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientCreateNestedOneWithoutUserInput
    manager?: ManagerCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    viewer?: ViewerCreateNestedOneWithoutUserInput
    supporter?: SupporterCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationManagerInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    viewer?: ViewerUncheckedCreateNestedOneWithoutUserInput
    supporter?: SupporterUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientUncheckedCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionUncheckedCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationManagerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationManagerInput, UserUncheckedCreateWithoutNotificationManagerInput>
  }

  export type UserUpsertWithoutNotificationManagerInput = {
    update: XOR<UserUpdateWithoutNotificationManagerInput, UserUncheckedUpdateWithoutNotificationManagerInput>
    create: XOR<UserCreateWithoutNotificationManagerInput, UserUncheckedCreateWithoutNotificationManagerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationManagerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationManagerInput, UserUncheckedUpdateWithoutNotificationManagerInput>
  }

  export type UserUpdateWithoutNotificationManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUpdateOneWithoutUserNestedInput
    manager?: ManagerUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    viewer?: ViewerUpdateOneWithoutUserNestedInput
    supporter?: SupporterUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    viewer?: ViewerUncheckedUpdateOneWithoutUserNestedInput
    supporter?: SupporterUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUncheckedUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUncheckedUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationClientInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientCreateNestedOneWithoutUserInput
    manager?: ManagerCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    viewer?: ViewerCreateNestedOneWithoutUserInput
    supporter?: SupporterCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationClientInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    viewer?: ViewerUncheckedCreateNestedOneWithoutUserInput
    supporter?: SupporterUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerUncheckedCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionUncheckedCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationClientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationClientInput, UserUncheckedCreateWithoutNotificationClientInput>
  }

  export type UserUpsertWithoutNotificationClientInput = {
    update: XOR<UserUpdateWithoutNotificationClientInput, UserUncheckedUpdateWithoutNotificationClientInput>
    create: XOR<UserCreateWithoutNotificationClientInput, UserUncheckedCreateWithoutNotificationClientInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationClientInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationClientInput, UserUncheckedUpdateWithoutNotificationClientInput>
  }

  export type UserUpdateWithoutNotificationClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUpdateOneWithoutUserNestedInput
    manager?: ManagerUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    viewer?: ViewerUpdateOneWithoutUserNestedInput
    supporter?: SupporterUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    viewer?: ViewerUncheckedUpdateOneWithoutUserNestedInput
    supporter?: SupporterUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUncheckedUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUncheckedUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationSupporterInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientCreateNestedOneWithoutUserInput
    manager?: ManagerCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    viewer?: ViewerCreateNestedOneWithoutUserInput
    supporter?: SupporterCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationSupporterInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    viewer?: ViewerUncheckedCreateNestedOneWithoutUserInput
    supporter?: SupporterUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerUncheckedCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientUncheckedCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionUncheckedCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationSupporterInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationSupporterInput, UserUncheckedCreateWithoutNotificationSupporterInput>
  }

  export type UserUpsertWithoutNotificationSupporterInput = {
    update: XOR<UserUpdateWithoutNotificationSupporterInput, UserUncheckedUpdateWithoutNotificationSupporterInput>
    create: XOR<UserCreateWithoutNotificationSupporterInput, UserUncheckedCreateWithoutNotificationSupporterInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationSupporterInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationSupporterInput, UserUncheckedUpdateWithoutNotificationSupporterInput>
  }

  export type UserUpdateWithoutNotificationSupporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUpdateOneWithoutUserNestedInput
    manager?: ManagerUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    viewer?: ViewerUpdateOneWithoutUserNestedInput
    supporter?: SupporterUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationSupporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    viewer?: ViewerUncheckedUpdateOneWithoutUserNestedInput
    supporter?: SupporterUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUncheckedUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUncheckedUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUncheckedUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationAdminInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientCreateNestedOneWithoutUserInput
    manager?: ManagerCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    viewer?: ViewerCreateNestedOneWithoutUserInput
    supporter?: SupporterCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationAdminInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    viewer?: ViewerUncheckedCreateNestedOneWithoutUserInput
    supporter?: SupporterUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerUncheckedCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientUncheckedCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionUncheckedCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationAdminInput, UserUncheckedCreateWithoutNotificationAdminInput>
  }

  export type UserUpsertWithoutNotificationAdminInput = {
    update: XOR<UserUpdateWithoutNotificationAdminInput, UserUncheckedUpdateWithoutNotificationAdminInput>
    create: XOR<UserCreateWithoutNotificationAdminInput, UserUncheckedCreateWithoutNotificationAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationAdminInput, UserUncheckedUpdateWithoutNotificationAdminInput>
  }

  export type UserUpdateWithoutNotificationAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUpdateOneWithoutUserNestedInput
    manager?: ManagerUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    viewer?: ViewerUpdateOneWithoutUserNestedInput
    supporter?: SupporterUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    viewer?: ViewerUncheckedUpdateOneWithoutUserNestedInput
    supporter?: SupporterUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUncheckedUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUncheckedUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUncheckedUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SuperAdminCreateWithoutNotificationPermissionSuperAdminInput = {
    id?: string
    clientLogo?: string | null
    favicon?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSuperAdminInput
  }

  export type SuperAdminUncheckedCreateWithoutNotificationPermissionSuperAdminInput = {
    id?: string
    userId: string
    clientLogo?: string | null
    favicon?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuperAdminCreateOrConnectWithoutNotificationPermissionSuperAdminInput = {
    where: SuperAdminWhereUniqueInput
    create: XOR<SuperAdminCreateWithoutNotificationPermissionSuperAdminInput, SuperAdminUncheckedCreateWithoutNotificationPermissionSuperAdminInput>
  }

  export type SuperAdminUpsertWithoutNotificationPermissionSuperAdminInput = {
    update: XOR<SuperAdminUpdateWithoutNotificationPermissionSuperAdminInput, SuperAdminUncheckedUpdateWithoutNotificationPermissionSuperAdminInput>
    create: XOR<SuperAdminCreateWithoutNotificationPermissionSuperAdminInput, SuperAdminUncheckedCreateWithoutNotificationPermissionSuperAdminInput>
    where?: SuperAdminWhereInput
  }

  export type SuperAdminUpdateToOneWithWhereWithoutNotificationPermissionSuperAdminInput = {
    where?: SuperAdminWhereInput
    data: XOR<SuperAdminUpdateWithoutNotificationPermissionSuperAdminInput, SuperAdminUncheckedUpdateWithoutNotificationPermissionSuperAdminInput>
  }

  export type SuperAdminUpdateWithoutNotificationPermissionSuperAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSuperAdminNestedInput
  }

  export type SuperAdminUncheckedUpdateWithoutNotificationPermissionSuperAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateWithoutProgramsInput = {
    id?: string
    email: string
    contactPersonName?: string | null
    clientLogo?: string | null
    favicon?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    footerText?: string | null
    supportMail?: string | null
    subdomain?: string | null
    serverLocation?: string | null
    category?: $Enums.IndustryCategory
    onboarding?: boolean
    welcomeDashboard?: boolean
    chartList?: ClientCreatechartListInput | string[]
    storage?: string | null
    threshold?: number | null
    archiveAfter?: number | null
    userWarning?: boolean
    adminNote?: string | null
    trialPeriod?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientInput
    referredPersons?: ReferredPersonCreateNestedManyWithoutClientInput
    tickets?: TicketCreateNestedManyWithoutClientInput
    tags?: TagCreateNestedOneWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutProgramsInput = {
    id?: string
    userId: string
    email: string
    contactPersonName?: string | null
    clientLogo?: string | null
    favicon?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    footerText?: string | null
    supportMail?: string | null
    subdomain?: string | null
    serverLocation?: string | null
    category?: $Enums.IndustryCategory
    onboarding?: boolean
    welcomeDashboard?: boolean
    chartList?: ClientCreatechartListInput | string[]
    storage?: string | null
    threshold?: number | null
    archiveAfter?: number | null
    userWarning?: boolean
    adminNote?: string | null
    trialPeriod?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredPersons?: ReferredPersonUncheckedCreateNestedManyWithoutClientInput
    tickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    tags?: TagUncheckedCreateNestedOneWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutProgramsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutProgramsInput, ClientUncheckedCreateWithoutProgramsInput>
  }

  export type ProjectCreateWithoutProgramInput = {
    id?: string
    name: string
    uploadbeforeday: string
    uploadCycle: $Enums.ProjectCycle
    description: string
    dataReceivedTime?: string | null
    beforeSubmitData?: number | null
    weakuploadData?: ProjectCreateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectCreatemonthlyuploadDataInput | string[]
    status?: $Enums.ProjectStatus
    priority: $Enums.Priority
    deadline: Date | string
    startDate?: Date | string | null
    progress?: number | null
    chartList?: ProjectCreatechartListInput | string[]
    estimatedCompletedDate?: Date | string | null
    currentRate?: string | null
    budget?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    latitude?: number | null
    longitude?: number | null
    manager: ManagerCreateNestedOneWithoutProjectsInput
    projectEmployees?: ProjectEmployeeCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    reviews?: ReviewCreateNestedManyWithoutProjectInput
    requestsToAddProjectMember?: RequestToAddProjectMemberCreateNestedManyWithoutProjectInput
    submitted?: SubmittedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProgramInput = {
    id?: string
    name: string
    uploadbeforeday: string
    uploadCycle: $Enums.ProjectCycle
    description: string
    dataReceivedTime?: string | null
    beforeSubmitData?: number | null
    weakuploadData?: ProjectCreateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectCreatemonthlyuploadDataInput | string[]
    status?: $Enums.ProjectStatus
    priority: $Enums.Priority
    deadline: Date | string
    managerId: string
    startDate?: Date | string | null
    progress?: number | null
    chartList?: ProjectCreatechartListInput | string[]
    estimatedCompletedDate?: Date | string | null
    currentRate?: string | null
    budget?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    latitude?: number | null
    longitude?: number | null
    projectEmployees?: ProjectEmployeeUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProjectInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    submitted?: SubmittedUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProgramInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProgramInput, ProjectUncheckedCreateWithoutProgramInput>
  }

  export type ProjectCreateManyProgramInputEnvelope = {
    data: ProjectCreateManyProgramInput | ProjectCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutProgramsInput = {
    update: XOR<ClientUpdateWithoutProgramsInput, ClientUncheckedUpdateWithoutProgramsInput>
    create: XOR<ClientCreateWithoutProgramsInput, ClientUncheckedCreateWithoutProgramsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutProgramsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutProgramsInput, ClientUncheckedUpdateWithoutProgramsInput>
  }

  export type ClientUpdateWithoutProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactPersonName?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    supportMail?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    serverLocation?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumIndustryCategoryFieldUpdateOperationsInput | $Enums.IndustryCategory
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    welcomeDashboard?: BoolFieldUpdateOperationsInput | boolean
    chartList?: ClientUpdatechartListInput | string[]
    storage?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: NullableIntFieldUpdateOperationsInput | number | null
    archiveAfter?: NullableIntFieldUpdateOperationsInput | number | null
    userWarning?: BoolFieldUpdateOperationsInput | boolean
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    trialPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientNestedInput
    referredPersons?: ReferredPersonUpdateManyWithoutClientNestedInput
    tickets?: TicketUpdateManyWithoutClientNestedInput
    tags?: TagUpdateOneWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactPersonName?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    supportMail?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    serverLocation?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumIndustryCategoryFieldUpdateOperationsInput | $Enums.IndustryCategory
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    welcomeDashboard?: BoolFieldUpdateOperationsInput | boolean
    chartList?: ClientUpdatechartListInput | string[]
    storage?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: NullableIntFieldUpdateOperationsInput | number | null
    archiveAfter?: NullableIntFieldUpdateOperationsInput | number | null
    userWarning?: BoolFieldUpdateOperationsInput | boolean
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    trialPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredPersons?: ReferredPersonUncheckedUpdateManyWithoutClientNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    tags?: TagUncheckedUpdateOneWithoutClientNestedInput
  }

  export type ProjectUpsertWithWhereUniqueWithoutProgramInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutProgramInput, ProjectUncheckedUpdateWithoutProgramInput>
    create: XOR<ProjectCreateWithoutProgramInput, ProjectUncheckedCreateWithoutProgramInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutProgramInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutProgramInput, ProjectUncheckedUpdateWithoutProgramInput>
  }

  export type ProjectUpdateManyWithWhereWithoutProgramInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutProgramInput>
  }

  export type ProgramCreateWithoutProjectsInput = {
    id?: string
    programName: string
    datetime: string
    programDescription: string
    priority: string
    deadline: string
    progress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutProgramsInput
  }

  export type ProgramUncheckedCreateWithoutProjectsInput = {
    id?: string
    userId: string
    programName: string
    datetime: string
    programDescription: string
    priority: string
    deadline: string
    progress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramCreateOrConnectWithoutProjectsInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutProjectsInput, ProgramUncheckedCreateWithoutProjectsInput>
  }

  export type ManagerCreateWithoutProjectsInput = {
    id?: string
    skills?: ManagerCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    joinedDate: string
    user: UserCreateNestedOneWithoutManagerInput
    requestsToAddProjectMember?: RequestToAddProjectMemberCreateNestedManyWithoutManagerInput
  }

  export type ManagerUncheckedCreateWithoutProjectsInput = {
    id?: string
    userId: string
    skills?: ManagerCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    joinedDate: string
    requestsToAddProjectMember?: RequestToAddProjectMemberUncheckedCreateNestedManyWithoutManagerInput
  }

  export type ManagerCreateOrConnectWithoutProjectsInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerCreateWithoutProjectsInput, ManagerUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectEmployeeCreateWithoutProjectInput = {
    id?: string
    assignedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutProjectEmployeesInput
  }

  export type ProjectEmployeeUncheckedCreateWithoutProjectInput = {
    id?: string
    employeeId: string
    assignedAt?: Date | string
  }

  export type ProjectEmployeeCreateOrConnectWithoutProjectInput = {
    where: ProjectEmployeeWhereUniqueInput
    create: XOR<ProjectEmployeeCreateWithoutProjectInput, ProjectEmployeeUncheckedCreateWithoutProjectInput>
  }

  export type ProjectEmployeeCreateManyProjectInputEnvelope = {
    data: ProjectEmployeeCreateManyProjectInput | ProjectEmployeeCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutProjectInput = {
    id?: string
    status?: $Enums.TaskStatus | null
    name: string
    progress?: number | null
    dueDate?: string | null
    assignedTo: string
    assigneeType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUncheckedCreateWithoutProjectInput = {
    id?: string
    status?: $Enums.TaskStatus | null
    name: string
    progress?: number | null
    dueDate?: string | null
    assignedTo: string
    assigneeType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutProjectInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskCreateManyProjectInputEnvelope = {
    data: TaskCreateManyProjectInput | TaskCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutProjectInput = {
    id?: string
    timestamp?: Date | string
    description: string
    ipAddress?: string | null
    actionType?: $Enums.ActivityActionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    timestamp?: Date | string
    description: string
    ipAddress?: string | null
    actionType?: $Enums.ActivityActionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutProjectInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput>
  }

  export type ActivityCreateManyProjectInputEnvelope = {
    data: ActivityCreateManyProjectInput | ActivityCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutProjectInput = {
    id?: string
    taskAssignId?: string | null
    status: $Enums.ProjectStatus
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUncheckedCreateWithoutProjectInput = {
    id?: string
    taskAssignId?: string | null
    status: $Enums.ProjectStatus
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutProjectInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutProjectInput, ReviewUncheckedCreateWithoutProjectInput>
  }

  export type ReviewCreateManyProjectInputEnvelope = {
    data: ReviewCreateManyProjectInput | ReviewCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type RequestToAddProjectMemberCreateWithoutProjectInput = {
    id?: string
    clientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager: ManagerCreateNestedOneWithoutRequestsToAddProjectMemberInput
  }

  export type RequestToAddProjectMemberUncheckedCreateWithoutProjectInput = {
    id?: string
    clientId?: string | null
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestToAddProjectMemberCreateOrConnectWithoutProjectInput = {
    where: RequestToAddProjectMemberWhereUniqueInput
    create: XOR<RequestToAddProjectMemberCreateWithoutProjectInput, RequestToAddProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type RequestToAddProjectMemberCreateManyProjectInputEnvelope = {
    data: RequestToAddProjectMemberCreateManyProjectInput | RequestToAddProjectMemberCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type SubmittedCreateWithoutProjectInput = {
    id?: string
    information: string
    submission: string
    status?: $Enums.SubmittedStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutSubmittedInput
    sheet: SheetCreateNestedOneWithoutSubmittedInput
    submissionReturn?: SubmissionReturnCreateNestedOneWithoutSubmittedInput
  }

  export type SubmittedUncheckedCreateWithoutProjectInput = {
    id?: string
    information: string
    submission: string
    status?: $Enums.SubmittedStatus
    employeeId: string
    sheetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    submissionReturn?: SubmissionReturnUncheckedCreateNestedOneWithoutSubmittedInput
  }

  export type SubmittedCreateOrConnectWithoutProjectInput = {
    where: SubmittedWhereUniqueInput
    create: XOR<SubmittedCreateWithoutProjectInput, SubmittedUncheckedCreateWithoutProjectInput>
  }

  export type SubmittedCreateManyProjectInputEnvelope = {
    data: SubmittedCreateManyProjectInput | SubmittedCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProgramUpsertWithoutProjectsInput = {
    update: XOR<ProgramUpdateWithoutProjectsInput, ProgramUncheckedUpdateWithoutProjectsInput>
    create: XOR<ProgramCreateWithoutProjectsInput, ProgramUncheckedCreateWithoutProjectsInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutProjectsInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutProjectsInput, ProgramUncheckedUpdateWithoutProjectsInput>
  }

  export type ProgramUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    programName?: StringFieldUpdateOperationsInput | string
    datetime?: StringFieldUpdateOperationsInput | string
    programDescription?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    deadline?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutProgramsNestedInput
  }

  export type ProgramUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    programName?: StringFieldUpdateOperationsInput | string
    datetime?: StringFieldUpdateOperationsInput | string
    programDescription?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    deadline?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagerUpsertWithoutProjectsInput = {
    update: XOR<ManagerUpdateWithoutProjectsInput, ManagerUncheckedUpdateWithoutProjectsInput>
    create: XOR<ManagerCreateWithoutProjectsInput, ManagerUncheckedCreateWithoutProjectsInput>
    where?: ManagerWhereInput
  }

  export type ManagerUpdateToOneWithWhereWithoutProjectsInput = {
    where?: ManagerWhereInput
    data: XOR<ManagerUpdateWithoutProjectsInput, ManagerUncheckedUpdateWithoutProjectsInput>
  }

  export type ManagerUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: ManagerUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    joinedDate?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutManagerNestedInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    skills?: ManagerUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    joinedDate?: StringFieldUpdateOperationsInput | string
    requestsToAddProjectMember?: RequestToAddProjectMemberUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type ProjectEmployeeUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectEmployeeWhereUniqueInput
    update: XOR<ProjectEmployeeUpdateWithoutProjectInput, ProjectEmployeeUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectEmployeeCreateWithoutProjectInput, ProjectEmployeeUncheckedCreateWithoutProjectInput>
  }

  export type ProjectEmployeeUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectEmployeeWhereUniqueInput
    data: XOR<ProjectEmployeeUpdateWithoutProjectInput, ProjectEmployeeUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectEmployeeUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectEmployeeScalarWhereInput
    data: XOR<ProjectEmployeeUpdateManyMutationInput, ProjectEmployeeUncheckedUpdateManyWithoutProjectInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
  }

  export type TaskUpdateManyWithWhereWithoutProjectInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutProjectInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    status?: EnumTaskStatusNullableFilter<"Task"> | $Enums.TaskStatus | null
    name?: StringFilter<"Task"> | string
    projectId?: StringFilter<"Task"> | string
    progress?: IntNullableFilter<"Task"> | number | null
    dueDate?: StringNullableFilter<"Task"> | string | null
    assignedTo?: StringFilter<"Task"> | string
    assigneeType?: StringFilter<"Task"> | string
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
  }

  export type ActivityUpsertWithWhereUniqueWithoutProjectInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutProjectInput, ActivityUncheckedUpdateWithoutProjectInput>
    create: XOR<ActivityCreateWithoutProjectInput, ActivityUncheckedCreateWithoutProjectInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutProjectInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutProjectInput, ActivityUncheckedUpdateWithoutProjectInput>
  }

  export type ActivityUpdateManyWithWhereWithoutProjectInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutProjectInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: StringFilter<"Activity"> | string
    userId?: StringFilter<"Activity"> | string
    timestamp?: DateTimeFilter<"Activity"> | Date | string
    description?: StringFilter<"Activity"> | string
    projectId?: StringFilter<"Activity"> | string
    ipAddress?: StringNullableFilter<"Activity"> | string | null
    actionType?: EnumActivityActionTypeFilter<"Activity"> | $Enums.ActivityActionType
    metadata?: JsonNullableFilter<"Activity">
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutProjectInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutProjectInput, ReviewUncheckedUpdateWithoutProjectInput>
    create: XOR<ReviewCreateWithoutProjectInput, ReviewUncheckedCreateWithoutProjectInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutProjectInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutProjectInput, ReviewUncheckedUpdateWithoutProjectInput>
  }

  export type ReviewUpdateManyWithWhereWithoutProjectInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutProjectInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    projectId?: StringFilter<"Review"> | string
    taskAssignId?: StringNullableFilter<"Review"> | string | null
    status?: EnumProjectStatusFilter<"Review"> | $Enums.ProjectStatus
    managerId?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type RequestToAddProjectMemberUpsertWithWhereUniqueWithoutProjectInput = {
    where: RequestToAddProjectMemberWhereUniqueInput
    update: XOR<RequestToAddProjectMemberUpdateWithoutProjectInput, RequestToAddProjectMemberUncheckedUpdateWithoutProjectInput>
    create: XOR<RequestToAddProjectMemberCreateWithoutProjectInput, RequestToAddProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type RequestToAddProjectMemberUpdateWithWhereUniqueWithoutProjectInput = {
    where: RequestToAddProjectMemberWhereUniqueInput
    data: XOR<RequestToAddProjectMemberUpdateWithoutProjectInput, RequestToAddProjectMemberUncheckedUpdateWithoutProjectInput>
  }

  export type RequestToAddProjectMemberUpdateManyWithWhereWithoutProjectInput = {
    where: RequestToAddProjectMemberScalarWhereInput
    data: XOR<RequestToAddProjectMemberUpdateManyMutationInput, RequestToAddProjectMemberUncheckedUpdateManyWithoutProjectInput>
  }

  export type SubmittedUpsertWithWhereUniqueWithoutProjectInput = {
    where: SubmittedWhereUniqueInput
    update: XOR<SubmittedUpdateWithoutProjectInput, SubmittedUncheckedUpdateWithoutProjectInput>
    create: XOR<SubmittedCreateWithoutProjectInput, SubmittedUncheckedCreateWithoutProjectInput>
  }

  export type SubmittedUpdateWithWhereUniqueWithoutProjectInput = {
    where: SubmittedWhereUniqueInput
    data: XOR<SubmittedUpdateWithoutProjectInput, SubmittedUncheckedUpdateWithoutProjectInput>
  }

  export type SubmittedUpdateManyWithWhereWithoutProjectInput = {
    where: SubmittedScalarWhereInput
    data: XOR<SubmittedUpdateManyMutationInput, SubmittedUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectCreateWithoutProjectEmployeesInput = {
    id?: string
    name: string
    uploadbeforeday: string
    uploadCycle: $Enums.ProjectCycle
    description: string
    dataReceivedTime?: string | null
    beforeSubmitData?: number | null
    weakuploadData?: ProjectCreateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectCreatemonthlyuploadDataInput | string[]
    status?: $Enums.ProjectStatus
    priority: $Enums.Priority
    deadline: Date | string
    startDate?: Date | string | null
    progress?: number | null
    chartList?: ProjectCreatechartListInput | string[]
    estimatedCompletedDate?: Date | string | null
    currentRate?: string | null
    budget?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    latitude?: number | null
    longitude?: number | null
    program: ProgramCreateNestedOneWithoutProjectsInput
    manager: ManagerCreateNestedOneWithoutProjectsInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    reviews?: ReviewCreateNestedManyWithoutProjectInput
    requestsToAddProjectMember?: RequestToAddProjectMemberCreateNestedManyWithoutProjectInput
    submitted?: SubmittedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProjectEmployeesInput = {
    id?: string
    programId: string
    name: string
    uploadbeforeday: string
    uploadCycle: $Enums.ProjectCycle
    description: string
    dataReceivedTime?: string | null
    beforeSubmitData?: number | null
    weakuploadData?: ProjectCreateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectCreatemonthlyuploadDataInput | string[]
    status?: $Enums.ProjectStatus
    priority: $Enums.Priority
    deadline: Date | string
    managerId: string
    startDate?: Date | string | null
    progress?: number | null
    chartList?: ProjectCreatechartListInput | string[]
    estimatedCompletedDate?: Date | string | null
    currentRate?: string | null
    budget?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    latitude?: number | null
    longitude?: number | null
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProjectInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    submitted?: SubmittedUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectEmployeesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectEmployeesInput, ProjectUncheckedCreateWithoutProjectEmployeesInput>
  }

  export type EmployeeCreateWithoutProjectEmployeesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    joinedDate: string
    skills?: EmployeeCreateskillsInput | string[]
    user: UserCreateNestedOneWithoutEmployeeInput
    submitted?: SubmittedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutProjectEmployeesInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    joinedDate: string
    skills?: EmployeeCreateskillsInput | string[]
    submitted?: SubmittedUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutProjectEmployeesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutProjectEmployeesInput, EmployeeUncheckedCreateWithoutProjectEmployeesInput>
  }

  export type ProjectUpsertWithoutProjectEmployeesInput = {
    update: XOR<ProjectUpdateWithoutProjectEmployeesInput, ProjectUncheckedUpdateWithoutProjectEmployeesInput>
    create: XOR<ProjectCreateWithoutProjectEmployeesInput, ProjectUncheckedCreateWithoutProjectEmployeesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutProjectEmployeesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutProjectEmployeesInput, ProjectUncheckedUpdateWithoutProjectEmployeesInput>
  }

  export type ProjectUpdateWithoutProjectEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uploadbeforeday?: StringFieldUpdateOperationsInput | string
    uploadCycle?: EnumProjectCycleFieldUpdateOperationsInput | $Enums.ProjectCycle
    description?: StringFieldUpdateOperationsInput | string
    dataReceivedTime?: NullableStringFieldUpdateOperationsInput | string | null
    beforeSubmitData?: NullableIntFieldUpdateOperationsInput | number | null
    weakuploadData?: ProjectUpdateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectUpdatemonthlyuploadDataInput | string[]
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    chartList?: ProjectUpdatechartListInput | string[]
    estimatedCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentRate?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    program?: ProgramUpdateOneRequiredWithoutProjectsNestedInput
    manager?: ManagerUpdateOneRequiredWithoutProjectsNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    reviews?: ReviewUpdateManyWithoutProjectNestedInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUpdateManyWithoutProjectNestedInput
    submitted?: SubmittedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uploadbeforeday?: StringFieldUpdateOperationsInput | string
    uploadCycle?: EnumProjectCycleFieldUpdateOperationsInput | $Enums.ProjectCycle
    description?: StringFieldUpdateOperationsInput | string
    dataReceivedTime?: NullableStringFieldUpdateOperationsInput | string | null
    beforeSubmitData?: NullableIntFieldUpdateOperationsInput | number | null
    weakuploadData?: ProjectUpdateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectUpdatemonthlyuploadDataInput | string[]
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    chartList?: ProjectUpdatechartListInput | string[]
    estimatedCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentRate?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProjectNestedInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    submitted?: SubmittedUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type EmployeeUpsertWithoutProjectEmployeesInput = {
    update: XOR<EmployeeUpdateWithoutProjectEmployeesInput, EmployeeUncheckedUpdateWithoutProjectEmployeesInput>
    create: XOR<EmployeeCreateWithoutProjectEmployeesInput, EmployeeUncheckedCreateWithoutProjectEmployeesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutProjectEmployeesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutProjectEmployeesInput, EmployeeUncheckedUpdateWithoutProjectEmployeesInput>
  }

  export type EmployeeUpdateWithoutProjectEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    joinedDate?: StringFieldUpdateOperationsInput | string
    skills?: EmployeeUpdateskillsInput | string[]
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    submitted?: SubmittedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutProjectEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    joinedDate?: StringFieldUpdateOperationsInput | string
    skills?: EmployeeUpdateskillsInput | string[]
    submitted?: SubmittedUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type ProjectCreateWithoutReviewsInput = {
    id?: string
    name: string
    uploadbeforeday: string
    uploadCycle: $Enums.ProjectCycle
    description: string
    dataReceivedTime?: string | null
    beforeSubmitData?: number | null
    weakuploadData?: ProjectCreateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectCreatemonthlyuploadDataInput | string[]
    status?: $Enums.ProjectStatus
    priority: $Enums.Priority
    deadline: Date | string
    startDate?: Date | string | null
    progress?: number | null
    chartList?: ProjectCreatechartListInput | string[]
    estimatedCompletedDate?: Date | string | null
    currentRate?: string | null
    budget?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    latitude?: number | null
    longitude?: number | null
    program: ProgramCreateNestedOneWithoutProjectsInput
    manager: ManagerCreateNestedOneWithoutProjectsInput
    projectEmployees?: ProjectEmployeeCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    requestsToAddProjectMember?: RequestToAddProjectMemberCreateNestedManyWithoutProjectInput
    submitted?: SubmittedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutReviewsInput = {
    id?: string
    programId: string
    name: string
    uploadbeforeday: string
    uploadCycle: $Enums.ProjectCycle
    description: string
    dataReceivedTime?: string | null
    beforeSubmitData?: number | null
    weakuploadData?: ProjectCreateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectCreatemonthlyuploadDataInput | string[]
    status?: $Enums.ProjectStatus
    priority: $Enums.Priority
    deadline: Date | string
    managerId: string
    startDate?: Date | string | null
    progress?: number | null
    chartList?: ProjectCreatechartListInput | string[]
    estimatedCompletedDate?: Date | string | null
    currentRate?: string | null
    budget?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    latitude?: number | null
    longitude?: number | null
    projectEmployees?: ProjectEmployeeUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    submitted?: SubmittedUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutReviewsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutReviewsInput, ProjectUncheckedCreateWithoutReviewsInput>
  }

  export type ProjectUpsertWithoutReviewsInput = {
    update: XOR<ProjectUpdateWithoutReviewsInput, ProjectUncheckedUpdateWithoutReviewsInput>
    create: XOR<ProjectCreateWithoutReviewsInput, ProjectUncheckedCreateWithoutReviewsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutReviewsInput, ProjectUncheckedUpdateWithoutReviewsInput>
  }

  export type ProjectUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uploadbeforeday?: StringFieldUpdateOperationsInput | string
    uploadCycle?: EnumProjectCycleFieldUpdateOperationsInput | $Enums.ProjectCycle
    description?: StringFieldUpdateOperationsInput | string
    dataReceivedTime?: NullableStringFieldUpdateOperationsInput | string | null
    beforeSubmitData?: NullableIntFieldUpdateOperationsInput | number | null
    weakuploadData?: ProjectUpdateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectUpdatemonthlyuploadDataInput | string[]
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    chartList?: ProjectUpdatechartListInput | string[]
    estimatedCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentRate?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    program?: ProgramUpdateOneRequiredWithoutProjectsNestedInput
    manager?: ManagerUpdateOneRequiredWithoutProjectsNestedInput
    projectEmployees?: ProjectEmployeeUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUpdateManyWithoutProjectNestedInput
    submitted?: SubmittedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uploadbeforeday?: StringFieldUpdateOperationsInput | string
    uploadCycle?: EnumProjectCycleFieldUpdateOperationsInput | $Enums.ProjectCycle
    description?: StringFieldUpdateOperationsInput | string
    dataReceivedTime?: NullableStringFieldUpdateOperationsInput | string | null
    beforeSubmitData?: NullableIntFieldUpdateOperationsInput | number | null
    weakuploadData?: ProjectUpdateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectUpdatemonthlyuploadDataInput | string[]
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    chartList?: ProjectUpdatechartListInput | string[]
    estimatedCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentRate?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    projectEmployees?: ProjectEmployeeUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    submitted?: SubmittedUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type SubmittedCreateWithoutSheetInput = {
    id?: string
    information: string
    submission: string
    status?: $Enums.SubmittedStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutSubmittedInput
    project: ProjectCreateNestedOneWithoutSubmittedInput
    submissionReturn?: SubmissionReturnCreateNestedOneWithoutSubmittedInput
  }

  export type SubmittedUncheckedCreateWithoutSheetInput = {
    id?: string
    information: string
    submission: string
    status?: $Enums.SubmittedStatus
    employeeId: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    submissionReturn?: SubmissionReturnUncheckedCreateNestedOneWithoutSubmittedInput
  }

  export type SubmittedCreateOrConnectWithoutSheetInput = {
    where: SubmittedWhereUniqueInput
    create: XOR<SubmittedCreateWithoutSheetInput, SubmittedUncheckedCreateWithoutSheetInput>
  }

  export type SubmittedCreateManySheetInputEnvelope = {
    data: SubmittedCreateManySheetInput | SubmittedCreateManySheetInput[]
    skipDuplicates?: boolean
  }

  export type SubmittedUpsertWithWhereUniqueWithoutSheetInput = {
    where: SubmittedWhereUniqueInput
    update: XOR<SubmittedUpdateWithoutSheetInput, SubmittedUncheckedUpdateWithoutSheetInput>
    create: XOR<SubmittedCreateWithoutSheetInput, SubmittedUncheckedCreateWithoutSheetInput>
  }

  export type SubmittedUpdateWithWhereUniqueWithoutSheetInput = {
    where: SubmittedWhereUniqueInput
    data: XOR<SubmittedUpdateWithoutSheetInput, SubmittedUncheckedUpdateWithoutSheetInput>
  }

  export type SubmittedUpdateManyWithWhereWithoutSheetInput = {
    where: SubmittedScalarWhereInput
    data: XOR<SubmittedUpdateManyMutationInput, SubmittedUncheckedUpdateManyWithoutSheetInput>
  }

  export type SubmittedCreateWithoutSubmissionReturnInput = {
    id?: string
    information: string
    submission: string
    status?: $Enums.SubmittedStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutSubmittedInput
    project: ProjectCreateNestedOneWithoutSubmittedInput
    sheet: SheetCreateNestedOneWithoutSubmittedInput
  }

  export type SubmittedUncheckedCreateWithoutSubmissionReturnInput = {
    id?: string
    information: string
    submission: string
    status?: $Enums.SubmittedStatus
    employeeId: string
    projectId: string
    sheetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubmittedCreateOrConnectWithoutSubmissionReturnInput = {
    where: SubmittedWhereUniqueInput
    create: XOR<SubmittedCreateWithoutSubmissionReturnInput, SubmittedUncheckedCreateWithoutSubmissionReturnInput>
  }

  export type SubmittedUpsertWithoutSubmissionReturnInput = {
    update: XOR<SubmittedUpdateWithoutSubmissionReturnInput, SubmittedUncheckedUpdateWithoutSubmissionReturnInput>
    create: XOR<SubmittedCreateWithoutSubmissionReturnInput, SubmittedUncheckedCreateWithoutSubmissionReturnInput>
    where?: SubmittedWhereInput
  }

  export type SubmittedUpdateToOneWithWhereWithoutSubmissionReturnInput = {
    where?: SubmittedWhereInput
    data: XOR<SubmittedUpdateWithoutSubmissionReturnInput, SubmittedUncheckedUpdateWithoutSubmissionReturnInput>
  }

  export type SubmittedUpdateWithoutSubmissionReturnInput = {
    id?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    submission?: StringFieldUpdateOperationsInput | string
    status?: EnumSubmittedStatusFieldUpdateOperationsInput | $Enums.SubmittedStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutSubmittedNestedInput
    project?: ProjectUpdateOneRequiredWithoutSubmittedNestedInput
    sheet?: SheetUpdateOneRequiredWithoutSubmittedNestedInput
  }

  export type SubmittedUncheckedUpdateWithoutSubmissionReturnInput = {
    id?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    submission?: StringFieldUpdateOperationsInput | string
    status?: EnumSubmittedStatusFieldUpdateOperationsInput | $Enums.SubmittedStatus
    employeeId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sheetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateWithoutSubmittedInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    joinedDate: string
    skills?: EmployeeCreateskillsInput | string[]
    user: UserCreateNestedOneWithoutEmployeeInput
    projectEmployees?: ProjectEmployeeCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutSubmittedInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    joinedDate: string
    skills?: EmployeeCreateskillsInput | string[]
    projectEmployees?: ProjectEmployeeUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutSubmittedInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutSubmittedInput, EmployeeUncheckedCreateWithoutSubmittedInput>
  }

  export type ProjectCreateWithoutSubmittedInput = {
    id?: string
    name: string
    uploadbeforeday: string
    uploadCycle: $Enums.ProjectCycle
    description: string
    dataReceivedTime?: string | null
    beforeSubmitData?: number | null
    weakuploadData?: ProjectCreateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectCreatemonthlyuploadDataInput | string[]
    status?: $Enums.ProjectStatus
    priority: $Enums.Priority
    deadline: Date | string
    startDate?: Date | string | null
    progress?: number | null
    chartList?: ProjectCreatechartListInput | string[]
    estimatedCompletedDate?: Date | string | null
    currentRate?: string | null
    budget?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    latitude?: number | null
    longitude?: number | null
    program: ProgramCreateNestedOneWithoutProjectsInput
    manager: ManagerCreateNestedOneWithoutProjectsInput
    projectEmployees?: ProjectEmployeeCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    reviews?: ReviewCreateNestedManyWithoutProjectInput
    requestsToAddProjectMember?: RequestToAddProjectMemberCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSubmittedInput = {
    id?: string
    programId: string
    name: string
    uploadbeforeday: string
    uploadCycle: $Enums.ProjectCycle
    description: string
    dataReceivedTime?: string | null
    beforeSubmitData?: number | null
    weakuploadData?: ProjectCreateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectCreatemonthlyuploadDataInput | string[]
    status?: $Enums.ProjectStatus
    priority: $Enums.Priority
    deadline: Date | string
    managerId: string
    startDate?: Date | string | null
    progress?: number | null
    chartList?: ProjectCreatechartListInput | string[]
    estimatedCompletedDate?: Date | string | null
    currentRate?: string | null
    budget?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    latitude?: number | null
    longitude?: number | null
    projectEmployees?: ProjectEmployeeUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProjectInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSubmittedInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSubmittedInput, ProjectUncheckedCreateWithoutSubmittedInput>
  }

  export type SheetCreateWithoutSubmittedInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SheetUncheckedCreateWithoutSubmittedInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SheetCreateOrConnectWithoutSubmittedInput = {
    where: SheetWhereUniqueInput
    create: XOR<SheetCreateWithoutSubmittedInput, SheetUncheckedCreateWithoutSubmittedInput>
  }

  export type SubmissionReturnCreateWithoutSubmittedInput = {
    id?: string
    returnedAt?: Date | string
  }

  export type SubmissionReturnUncheckedCreateWithoutSubmittedInput = {
    id?: string
    returnedAt?: Date | string
  }

  export type SubmissionReturnCreateOrConnectWithoutSubmittedInput = {
    where: SubmissionReturnWhereUniqueInput
    create: XOR<SubmissionReturnCreateWithoutSubmittedInput, SubmissionReturnUncheckedCreateWithoutSubmittedInput>
  }

  export type EmployeeUpsertWithoutSubmittedInput = {
    update: XOR<EmployeeUpdateWithoutSubmittedInput, EmployeeUncheckedUpdateWithoutSubmittedInput>
    create: XOR<EmployeeCreateWithoutSubmittedInput, EmployeeUncheckedCreateWithoutSubmittedInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutSubmittedInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutSubmittedInput, EmployeeUncheckedUpdateWithoutSubmittedInput>
  }

  export type EmployeeUpdateWithoutSubmittedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    joinedDate?: StringFieldUpdateOperationsInput | string
    skills?: EmployeeUpdateskillsInput | string[]
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    projectEmployees?: ProjectEmployeeUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutSubmittedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    joinedDate?: StringFieldUpdateOperationsInput | string
    skills?: EmployeeUpdateskillsInput | string[]
    projectEmployees?: ProjectEmployeeUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type ProjectUpsertWithoutSubmittedInput = {
    update: XOR<ProjectUpdateWithoutSubmittedInput, ProjectUncheckedUpdateWithoutSubmittedInput>
    create: XOR<ProjectCreateWithoutSubmittedInput, ProjectUncheckedCreateWithoutSubmittedInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSubmittedInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSubmittedInput, ProjectUncheckedUpdateWithoutSubmittedInput>
  }

  export type ProjectUpdateWithoutSubmittedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uploadbeforeday?: StringFieldUpdateOperationsInput | string
    uploadCycle?: EnumProjectCycleFieldUpdateOperationsInput | $Enums.ProjectCycle
    description?: StringFieldUpdateOperationsInput | string
    dataReceivedTime?: NullableStringFieldUpdateOperationsInput | string | null
    beforeSubmitData?: NullableIntFieldUpdateOperationsInput | number | null
    weakuploadData?: ProjectUpdateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectUpdatemonthlyuploadDataInput | string[]
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    chartList?: ProjectUpdatechartListInput | string[]
    estimatedCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentRate?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    program?: ProgramUpdateOneRequiredWithoutProjectsNestedInput
    manager?: ManagerUpdateOneRequiredWithoutProjectsNestedInput
    projectEmployees?: ProjectEmployeeUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    reviews?: ReviewUpdateManyWithoutProjectNestedInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSubmittedInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uploadbeforeday?: StringFieldUpdateOperationsInput | string
    uploadCycle?: EnumProjectCycleFieldUpdateOperationsInput | $Enums.ProjectCycle
    description?: StringFieldUpdateOperationsInput | string
    dataReceivedTime?: NullableStringFieldUpdateOperationsInput | string | null
    beforeSubmitData?: NullableIntFieldUpdateOperationsInput | number | null
    weakuploadData?: ProjectUpdateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectUpdatemonthlyuploadDataInput | string[]
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    chartList?: ProjectUpdatechartListInput | string[]
    estimatedCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentRate?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    projectEmployees?: ProjectEmployeeUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProjectNestedInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type SheetUpsertWithoutSubmittedInput = {
    update: XOR<SheetUpdateWithoutSubmittedInput, SheetUncheckedUpdateWithoutSubmittedInput>
    create: XOR<SheetCreateWithoutSubmittedInput, SheetUncheckedCreateWithoutSubmittedInput>
    where?: SheetWhereInput
  }

  export type SheetUpdateToOneWithWhereWithoutSubmittedInput = {
    where?: SheetWhereInput
    data: XOR<SheetUpdateWithoutSubmittedInput, SheetUncheckedUpdateWithoutSubmittedInput>
  }

  export type SheetUpdateWithoutSubmittedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SheetUncheckedUpdateWithoutSubmittedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionReturnUpsertWithoutSubmittedInput = {
    update: XOR<SubmissionReturnUpdateWithoutSubmittedInput, SubmissionReturnUncheckedUpdateWithoutSubmittedInput>
    create: XOR<SubmissionReturnCreateWithoutSubmittedInput, SubmissionReturnUncheckedCreateWithoutSubmittedInput>
    where?: SubmissionReturnWhereInput
  }

  export type SubmissionReturnUpdateToOneWithWhereWithoutSubmittedInput = {
    where?: SubmissionReturnWhereInput
    data: XOR<SubmissionReturnUpdateWithoutSubmittedInput, SubmissionReturnUncheckedUpdateWithoutSubmittedInput>
  }

  export type SubmissionReturnUpdateWithoutSubmittedInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionReturnUncheckedUpdateWithoutSubmittedInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutSuperAdminInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientCreateNestedOneWithoutUserInput
    manager?: ManagerCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    viewer?: ViewerCreateNestedOneWithoutUserInput
    supporter?: SupporterCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSuperAdminInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    viewer?: ViewerUncheckedCreateNestedOneWithoutUserInput
    supporter?: SupporterUncheckedCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerUncheckedCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientUncheckedCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionUncheckedCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSuperAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSuperAdminInput, UserUncheckedCreateWithoutSuperAdminInput>
  }

  export type NotificationPermissionSuperAdminCreateWithoutUserInput = {
    id?: string
    storageLimit?: boolean
    receivedPayment?: boolean
    createClient?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionSuperAdminUncheckedCreateWithoutUserInput = {
    id?: string
    storageLimit?: boolean
    receivedPayment?: boolean
    createClient?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionSuperAdminCreateOrConnectWithoutUserInput = {
    where: NotificationPermissionSuperAdminWhereUniqueInput
    create: XOR<NotificationPermissionSuperAdminCreateWithoutUserInput, NotificationPermissionSuperAdminUncheckedCreateWithoutUserInput>
  }

  export type UserUpsertWithoutSuperAdminInput = {
    update: XOR<UserUpdateWithoutSuperAdminInput, UserUncheckedUpdateWithoutSuperAdminInput>
    create: XOR<UserCreateWithoutSuperAdminInput, UserUncheckedCreateWithoutSuperAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSuperAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSuperAdminInput, UserUncheckedUpdateWithoutSuperAdminInput>
  }

  export type UserUpdateWithoutSuperAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUpdateOneWithoutUserNestedInput
    manager?: ManagerUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    viewer?: ViewerUpdateOneWithoutUserNestedInput
    supporter?: SupporterUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSuperAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    viewer?: ViewerUncheckedUpdateOneWithoutUserNestedInput
    supporter?: SupporterUncheckedUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUncheckedUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUncheckedUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUncheckedUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NotificationPermissionSuperAdminUpsertWithoutUserInput = {
    update: XOR<NotificationPermissionSuperAdminUpdateWithoutUserInput, NotificationPermissionSuperAdminUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPermissionSuperAdminCreateWithoutUserInput, NotificationPermissionSuperAdminUncheckedCreateWithoutUserInput>
    where?: NotificationPermissionSuperAdminWhereInput
  }

  export type NotificationPermissionSuperAdminUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationPermissionSuperAdminWhereInput
    data: XOR<NotificationPermissionSuperAdminUpdateWithoutUserInput, NotificationPermissionSuperAdminUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPermissionSuperAdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageLimit?: BoolFieldUpdateOperationsInput | boolean
    receivedPayment?: BoolFieldUpdateOperationsInput | boolean
    createClient?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionSuperAdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageLimit?: BoolFieldUpdateOperationsInput | boolean
    receivedPayment?: BoolFieldUpdateOperationsInput | boolean
    createClient?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutSupporterInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientCreateNestedOneWithoutUserInput
    manager?: ManagerCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    viewer?: ViewerCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSupporterInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    viewer?: ViewerUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerUncheckedCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientUncheckedCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionUncheckedCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSupporterInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSupporterInput, UserUncheckedCreateWithoutSupporterInput>
  }

  export type UserUpsertWithoutSupporterInput = {
    update: XOR<UserUpdateWithoutSupporterInput, UserUncheckedUpdateWithoutSupporterInput>
    create: XOR<UserCreateWithoutSupporterInput, UserUncheckedCreateWithoutSupporterInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSupporterInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSupporterInput, UserUncheckedUpdateWithoutSupporterInput>
  }

  export type UserUpdateWithoutSupporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUpdateOneWithoutUserNestedInput
    manager?: ManagerUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    viewer?: ViewerUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSupporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    viewer?: ViewerUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUncheckedUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUncheckedUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUncheckedUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectCreateWithoutTasksInput = {
    id?: string
    name: string
    uploadbeforeday: string
    uploadCycle: $Enums.ProjectCycle
    description: string
    dataReceivedTime?: string | null
    beforeSubmitData?: number | null
    weakuploadData?: ProjectCreateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectCreatemonthlyuploadDataInput | string[]
    status?: $Enums.ProjectStatus
    priority: $Enums.Priority
    deadline: Date | string
    startDate?: Date | string | null
    progress?: number | null
    chartList?: ProjectCreatechartListInput | string[]
    estimatedCompletedDate?: Date | string | null
    currentRate?: string | null
    budget?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    latitude?: number | null
    longitude?: number | null
    program: ProgramCreateNestedOneWithoutProjectsInput
    manager: ManagerCreateNestedOneWithoutProjectsInput
    projectEmployees?: ProjectEmployeeCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    reviews?: ReviewCreateNestedManyWithoutProjectInput
    requestsToAddProjectMember?: RequestToAddProjectMemberCreateNestedManyWithoutProjectInput
    submitted?: SubmittedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTasksInput = {
    id?: string
    programId: string
    name: string
    uploadbeforeday: string
    uploadCycle: $Enums.ProjectCycle
    description: string
    dataReceivedTime?: string | null
    beforeSubmitData?: number | null
    weakuploadData?: ProjectCreateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectCreatemonthlyuploadDataInput | string[]
    status?: $Enums.ProjectStatus
    priority: $Enums.Priority
    deadline: Date | string
    managerId: string
    startDate?: Date | string | null
    progress?: number | null
    chartList?: ProjectCreatechartListInput | string[]
    estimatedCompletedDate?: Date | string | null
    currentRate?: string | null
    budget?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    latitude?: number | null
    longitude?: number | null
    projectEmployees?: ProjectEmployeeUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProjectInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    submitted?: SubmittedUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTasksInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
  }

  export type ProjectUpsertWithoutTasksInput = {
    update: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTasksInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type ProjectUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uploadbeforeday?: StringFieldUpdateOperationsInput | string
    uploadCycle?: EnumProjectCycleFieldUpdateOperationsInput | $Enums.ProjectCycle
    description?: StringFieldUpdateOperationsInput | string
    dataReceivedTime?: NullableStringFieldUpdateOperationsInput | string | null
    beforeSubmitData?: NullableIntFieldUpdateOperationsInput | number | null
    weakuploadData?: ProjectUpdateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectUpdatemonthlyuploadDataInput | string[]
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    chartList?: ProjectUpdatechartListInput | string[]
    estimatedCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentRate?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    program?: ProgramUpdateOneRequiredWithoutProjectsNestedInput
    manager?: ManagerUpdateOneRequiredWithoutProjectsNestedInput
    projectEmployees?: ProjectEmployeeUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    reviews?: ReviewUpdateManyWithoutProjectNestedInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUpdateManyWithoutProjectNestedInput
    submitted?: SubmittedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uploadbeforeday?: StringFieldUpdateOperationsInput | string
    uploadCycle?: EnumProjectCycleFieldUpdateOperationsInput | $Enums.ProjectCycle
    description?: StringFieldUpdateOperationsInput | string
    dataReceivedTime?: NullableStringFieldUpdateOperationsInput | string | null
    beforeSubmitData?: NullableIntFieldUpdateOperationsInput | number | null
    weakuploadData?: ProjectUpdateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectUpdatemonthlyuploadDataInput | string[]
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    chartList?: ProjectUpdatechartListInput | string[]
    estimatedCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentRate?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    projectEmployees?: ProjectEmployeeUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProjectNestedInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    submitted?: SubmittedUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ClientCreateWithoutTicketsInput = {
    id?: string
    email: string
    contactPersonName?: string | null
    clientLogo?: string | null
    favicon?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    footerText?: string | null
    supportMail?: string | null
    subdomain?: string | null
    serverLocation?: string | null
    category?: $Enums.IndustryCategory
    onboarding?: boolean
    welcomeDashboard?: boolean
    chartList?: ClientCreatechartListInput | string[]
    storage?: string | null
    threshold?: number | null
    archiveAfter?: number | null
    userWarning?: boolean
    adminNote?: string | null
    trialPeriod?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientInput
    referredPersons?: ReferredPersonCreateNestedManyWithoutClientInput
    programs?: ProgramCreateNestedManyWithoutClientInput
    tags?: TagCreateNestedOneWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutTicketsInput = {
    id?: string
    userId: string
    email: string
    contactPersonName?: string | null
    clientLogo?: string | null
    favicon?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    footerText?: string | null
    supportMail?: string | null
    subdomain?: string | null
    serverLocation?: string | null
    category?: $Enums.IndustryCategory
    onboarding?: boolean
    welcomeDashboard?: boolean
    chartList?: ClientCreatechartListInput | string[]
    storage?: string | null
    threshold?: number | null
    archiveAfter?: number | null
    userWarning?: boolean
    adminNote?: string | null
    trialPeriod?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredPersons?: ReferredPersonUncheckedCreateNestedManyWithoutClientInput
    programs?: ProgramUncheckedCreateNestedManyWithoutClientInput
    tags?: TagUncheckedCreateNestedOneWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutTicketsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutTicketsInput, ClientUncheckedCreateWithoutTicketsInput>
  }

  export type ClientUpsertWithoutTicketsInput = {
    update: XOR<ClientUpdateWithoutTicketsInput, ClientUncheckedUpdateWithoutTicketsInput>
    create: XOR<ClientCreateWithoutTicketsInput, ClientUncheckedCreateWithoutTicketsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutTicketsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutTicketsInput, ClientUncheckedUpdateWithoutTicketsInput>
  }

  export type ClientUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactPersonName?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    supportMail?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    serverLocation?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumIndustryCategoryFieldUpdateOperationsInput | $Enums.IndustryCategory
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    welcomeDashboard?: BoolFieldUpdateOperationsInput | boolean
    chartList?: ClientUpdatechartListInput | string[]
    storage?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: NullableIntFieldUpdateOperationsInput | number | null
    archiveAfter?: NullableIntFieldUpdateOperationsInput | number | null
    userWarning?: BoolFieldUpdateOperationsInput | boolean
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    trialPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientNestedInput
    referredPersons?: ReferredPersonUpdateManyWithoutClientNestedInput
    programs?: ProgramUpdateManyWithoutClientNestedInput
    tags?: TagUpdateOneWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactPersonName?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    supportMail?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    serverLocation?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumIndustryCategoryFieldUpdateOperationsInput | $Enums.IndustryCategory
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    welcomeDashboard?: BoolFieldUpdateOperationsInput | boolean
    chartList?: ClientUpdatechartListInput | string[]
    storage?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: NullableIntFieldUpdateOperationsInput | number | null
    archiveAfter?: NullableIntFieldUpdateOperationsInput | number | null
    userWarning?: BoolFieldUpdateOperationsInput | boolean
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    trialPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredPersons?: ReferredPersonUncheckedUpdateManyWithoutClientNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutClientNestedInput
    tags?: TagUncheckedUpdateOneWithoutClientNestedInput
  }

  export type ClientCreateWithoutUserInput = {
    id?: string
    email: string
    contactPersonName?: string | null
    clientLogo?: string | null
    favicon?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    footerText?: string | null
    supportMail?: string | null
    subdomain?: string | null
    serverLocation?: string | null
    category?: $Enums.IndustryCategory
    onboarding?: boolean
    welcomeDashboard?: boolean
    chartList?: ClientCreatechartListInput | string[]
    storage?: string | null
    threshold?: number | null
    archiveAfter?: number | null
    userWarning?: boolean
    adminNote?: string | null
    trialPeriod?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredPersons?: ReferredPersonCreateNestedManyWithoutClientInput
    tickets?: TicketCreateNestedManyWithoutClientInput
    programs?: ProgramCreateNestedManyWithoutClientInput
    tags?: TagCreateNestedOneWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutUserInput = {
    id?: string
    email: string
    contactPersonName?: string | null
    clientLogo?: string | null
    favicon?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    footerText?: string | null
    supportMail?: string | null
    subdomain?: string | null
    serverLocation?: string | null
    category?: $Enums.IndustryCategory
    onboarding?: boolean
    welcomeDashboard?: boolean
    chartList?: ClientCreatechartListInput | string[]
    storage?: string | null
    threshold?: number | null
    archiveAfter?: number | null
    userWarning?: boolean
    adminNote?: string | null
    trialPeriod?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredPersons?: ReferredPersonUncheckedCreateNestedManyWithoutClientInput
    tickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    programs?: ProgramUncheckedCreateNestedManyWithoutClientInput
    tags?: TagUncheckedCreateNestedOneWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutUserInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
  }

  export type ManagerCreateWithoutUserInput = {
    id?: string
    skills?: ManagerCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    joinedDate: string
    projects?: ProjectCreateNestedManyWithoutManagerInput
    requestsToAddProjectMember?: RequestToAddProjectMemberCreateNestedManyWithoutManagerInput
  }

  export type ManagerUncheckedCreateWithoutUserInput = {
    id?: string
    skills?: ManagerCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    joinedDate: string
    projects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUncheckedCreateNestedManyWithoutManagerInput
  }

  export type ManagerCreateOrConnectWithoutUserInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
  }

  export type EmployeeCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    joinedDate: string
    skills?: EmployeeCreateskillsInput | string[]
    projectEmployees?: ProjectEmployeeCreateNestedManyWithoutEmployeeInput
    submitted?: SubmittedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    joinedDate: string
    skills?: EmployeeCreateskillsInput | string[]
    projectEmployees?: ProjectEmployeeUncheckedCreateNestedManyWithoutEmployeeInput
    submitted?: SubmittedUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
  }

  export type ViewerCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViewerUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViewerCreateOrConnectWithoutUserInput = {
    where: ViewerWhereUniqueInput
    create: XOR<ViewerCreateWithoutUserInput, ViewerUncheckedCreateWithoutUserInput>
  }

  export type SupporterCreateWithoutUserInput = {
    id?: string
    supporterRole: $Enums.SupporterRole
    skills?: SupporterCreateskillsInput | string[]
    workload?: number | null
    workItems?: SupporterCreateworkItemsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupporterUncheckedCreateWithoutUserInput = {
    id?: string
    supporterRole: $Enums.SupporterRole
    skills?: SupporterCreateskillsInput | string[]
    workload?: number | null
    workItems?: SupporterCreateworkItemsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupporterCreateOrConnectWithoutUserInput = {
    where: SupporterWhereUniqueInput
    create: XOR<SupporterCreateWithoutUserInput, SupporterUncheckedCreateWithoutUserInput>
  }

  export type SuperAdminCreateWithoutUserInput = {
    id?: string
    clientLogo?: string | null
    favicon?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationPermissionSuperAdmin?: NotificationPermissionSuperAdminCreateNestedOneWithoutUserInput
  }

  export type SuperAdminUncheckedCreateWithoutUserInput = {
    id?: string
    clientLogo?: string | null
    favicon?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationPermissionSuperAdmin?: NotificationPermissionSuperAdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type SuperAdminCreateOrConnectWithoutUserInput = {
    where: SuperAdminWhereUniqueInput
    create: XOR<SuperAdminCreateWithoutUserInput, SuperAdminUncheckedCreateWithoutUserInput>
  }

  export type NotificationPermissionEmployeeCreateWithoutUserInput = {
    id?: string
    returnProject?: boolean
    assignNewProject?: boolean
    projectPublish?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionEmployeeUncheckedCreateWithoutUserInput = {
    id?: string
    returnProject?: boolean
    assignNewProject?: boolean
    projectPublish?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionEmployeeCreateOrConnectWithoutUserInput = {
    where: NotificationPermissionEmployeeWhereUniqueInput
    create: XOR<NotificationPermissionEmployeeCreateWithoutUserInput, NotificationPermissionEmployeeUncheckedCreateWithoutUserInput>
  }

  export type NotificationPermissionManagerCreateWithoutUserInput = {
    id?: string
    fileImportByEmployees?: boolean
    weeklySummary?: boolean
    createNewProject?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionManagerUncheckedCreateWithoutUserInput = {
    id?: string
    fileImportByEmployees?: boolean
    weeklySummary?: boolean
    createNewProject?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionManagerCreateOrConnectWithoutUserInput = {
    where: NotificationPermissionManagerWhereUniqueInput
    create: XOR<NotificationPermissionManagerCreateWithoutUserInput, NotificationPermissionManagerUncheckedCreateWithoutUserInput>
  }

  export type NotificationPermissionClientCreateWithoutUserInput = {
    id?: string
    onProjectApproval?: boolean
    onProjectRejection?: boolean
    fileImportByEmployees?: boolean
    weeklySummary?: boolean
    storageLimit?: boolean
    billPayment?: boolean
    overdueProject?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionClientUncheckedCreateWithoutUserInput = {
    id?: string
    onProjectApproval?: boolean
    onProjectRejection?: boolean
    fileImportByEmployees?: boolean
    weeklySummary?: boolean
    storageLimit?: boolean
    billPayment?: boolean
    overdueProject?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionClientCreateOrConnectWithoutUserInput = {
    where: NotificationPermissionClientWhereUniqueInput
    create: XOR<NotificationPermissionClientCreateWithoutUserInput, NotificationPermissionClientUncheckedCreateWithoutUserInput>
  }

  export type NotificationPermissionSupporterCreateWithoutUserInput = {
    id?: string
    assignNewProject?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionSupporterUncheckedCreateWithoutUserInput = {
    id?: string
    assignNewProject?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionSupporterCreateOrConnectWithoutUserInput = {
    where: NotificationPermissionSupporterWhereUniqueInput
    create: XOR<NotificationPermissionSupporterCreateWithoutUserInput, NotificationPermissionSupporterUncheckedCreateWithoutUserInput>
  }

  export type NotificationPermissionAdminCreateWithoutUserInput = {
    id?: string
    storageLimit?: boolean
    receivedPayment?: boolean
    createClient?: boolean
    createTicket?: boolean
    paymentCycleChange?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionAdminUncheckedCreateWithoutUserInput = {
    id?: string
    storageLimit?: boolean
    receivedPayment?: boolean
    createClient?: boolean
    createTicket?: boolean
    paymentCycleChange?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPermissionAdminCreateOrConnectWithoutUserInput = {
    where: NotificationPermissionAdminWhereUniqueInput
    create: XOR<NotificationPermissionAdminCreateWithoutUserInput, NotificationPermissionAdminUncheckedCreateWithoutUserInput>
  }

  export type NotificationProvisionCreateWithoutUserInput = {
    notification: NotificationCreateNestedOneWithoutProvisionsInput
  }

  export type NotificationProvisionUncheckedCreateWithoutUserInput = {
    notificationId: string
  }

  export type NotificationProvisionCreateOrConnectWithoutUserInput = {
    where: NotificationProvisionWhereUniqueInput
    create: XOR<NotificationProvisionCreateWithoutUserInput, NotificationProvisionUncheckedCreateWithoutUserInput>
  }

  export type NotificationProvisionCreateManyUserInputEnvelope = {
    data: NotificationProvisionCreateManyUserInput | NotificationProvisionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OtpVerificationCreateWithoutUserInput = {
    id?: string
    otp: string
    expiresAt: Date | string
    verified?: boolean
    createdAt?: Date | string
  }

  export type OtpVerificationUncheckedCreateWithoutUserInput = {
    id?: string
    otp: string
    expiresAt: Date | string
    verified?: boolean
    createdAt?: Date | string
  }

  export type OtpVerificationCreateOrConnectWithoutUserInput = {
    where: OtpVerificationWhereUniqueInput
    create: XOR<OtpVerificationCreateWithoutUserInput, OtpVerificationUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateWithoutUserInput = {
    id?: string
    amount: number
    transactionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string
    amount: number
    transactionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutUserInput = {
    id?: string
    timestamp?: Date | string
    description: string
    ipAddress?: string | null
    actionType?: $Enums.ActivityActionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutUserInput = {
    id?: string
    timestamp?: Date | string
    description: string
    projectId: string
    ipAddress?: string | null
    actionType?: $Enums.ActivityActionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutUserInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityCreateManyUserInputEnvelope = {
    data: ActivityCreateManyUserInput | ActivityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutUserInput = {
    update: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutUserInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
  }

  export type ClientUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactPersonName?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    supportMail?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    serverLocation?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumIndustryCategoryFieldUpdateOperationsInput | $Enums.IndustryCategory
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    welcomeDashboard?: BoolFieldUpdateOperationsInput | boolean
    chartList?: ClientUpdatechartListInput | string[]
    storage?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: NullableIntFieldUpdateOperationsInput | number | null
    archiveAfter?: NullableIntFieldUpdateOperationsInput | number | null
    userWarning?: BoolFieldUpdateOperationsInput | boolean
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    trialPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredPersons?: ReferredPersonUpdateManyWithoutClientNestedInput
    tickets?: TicketUpdateManyWithoutClientNestedInput
    programs?: ProgramUpdateManyWithoutClientNestedInput
    tags?: TagUpdateOneWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactPersonName?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    supportMail?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    serverLocation?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumIndustryCategoryFieldUpdateOperationsInput | $Enums.IndustryCategory
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    welcomeDashboard?: BoolFieldUpdateOperationsInput | boolean
    chartList?: ClientUpdatechartListInput | string[]
    storage?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: NullableIntFieldUpdateOperationsInput | number | null
    archiveAfter?: NullableIntFieldUpdateOperationsInput | number | null
    userWarning?: BoolFieldUpdateOperationsInput | boolean
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    trialPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredPersons?: ReferredPersonUncheckedUpdateManyWithoutClientNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutClientNestedInput
    tags?: TagUncheckedUpdateOneWithoutClientNestedInput
  }

  export type ManagerUpsertWithoutUserInput = {
    update: XOR<ManagerUpdateWithoutUserInput, ManagerUncheckedUpdateWithoutUserInput>
    create: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
    where?: ManagerWhereInput
  }

  export type ManagerUpdateToOneWithWhereWithoutUserInput = {
    where?: ManagerWhereInput
    data: XOR<ManagerUpdateWithoutUserInput, ManagerUncheckedUpdateWithoutUserInput>
  }

  export type ManagerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: ManagerUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    joinedDate?: StringFieldUpdateOperationsInput | string
    projects?: ProjectUpdateManyWithoutManagerNestedInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: ManagerUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    joinedDate?: StringFieldUpdateOperationsInput | string
    projects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type EmployeeUpsertWithoutUserInput = {
    update: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutUserInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    joinedDate?: StringFieldUpdateOperationsInput | string
    skills?: EmployeeUpdateskillsInput | string[]
    projectEmployees?: ProjectEmployeeUpdateManyWithoutEmployeeNestedInput
    submitted?: SubmittedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    joinedDate?: StringFieldUpdateOperationsInput | string
    skills?: EmployeeUpdateskillsInput | string[]
    projectEmployees?: ProjectEmployeeUncheckedUpdateManyWithoutEmployeeNestedInput
    submitted?: SubmittedUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type ViewerUpsertWithoutUserInput = {
    update: XOR<ViewerUpdateWithoutUserInput, ViewerUncheckedUpdateWithoutUserInput>
    create: XOR<ViewerCreateWithoutUserInput, ViewerUncheckedCreateWithoutUserInput>
    where?: ViewerWhereInput
  }

  export type ViewerUpdateToOneWithWhereWithoutUserInput = {
    where?: ViewerWhereInput
    data: XOR<ViewerUpdateWithoutUserInput, ViewerUncheckedUpdateWithoutUserInput>
  }

  export type ViewerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupporterUpsertWithoutUserInput = {
    update: XOR<SupporterUpdateWithoutUserInput, SupporterUncheckedUpdateWithoutUserInput>
    create: XOR<SupporterCreateWithoutUserInput, SupporterUncheckedCreateWithoutUserInput>
    where?: SupporterWhereInput
  }

  export type SupporterUpdateToOneWithWhereWithoutUserInput = {
    where?: SupporterWhereInput
    data: XOR<SupporterUpdateWithoutUserInput, SupporterUncheckedUpdateWithoutUserInput>
  }

  export type SupporterUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    supporterRole?: EnumSupporterRoleFieldUpdateOperationsInput | $Enums.SupporterRole
    skills?: SupporterUpdateskillsInput | string[]
    workload?: NullableIntFieldUpdateOperationsInput | number | null
    workItems?: SupporterUpdateworkItemsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupporterUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    supporterRole?: EnumSupporterRoleFieldUpdateOperationsInput | $Enums.SupporterRole
    skills?: SupporterUpdateskillsInput | string[]
    workload?: NullableIntFieldUpdateOperationsInput | number | null
    workItems?: SupporterUpdateworkItemsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuperAdminUpsertWithoutUserInput = {
    update: XOR<SuperAdminUpdateWithoutUserInput, SuperAdminUncheckedUpdateWithoutUserInput>
    create: XOR<SuperAdminCreateWithoutUserInput, SuperAdminUncheckedCreateWithoutUserInput>
    where?: SuperAdminWhereInput
  }

  export type SuperAdminUpdateToOneWithWhereWithoutUserInput = {
    where?: SuperAdminWhereInput
    data: XOR<SuperAdminUpdateWithoutUserInput, SuperAdminUncheckedUpdateWithoutUserInput>
  }

  export type SuperAdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationPermissionSuperAdmin?: NotificationPermissionSuperAdminUpdateOneWithoutUserNestedInput
  }

  export type SuperAdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationPermissionSuperAdmin?: NotificationPermissionSuperAdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type NotificationPermissionEmployeeUpsertWithoutUserInput = {
    update: XOR<NotificationPermissionEmployeeUpdateWithoutUserInput, NotificationPermissionEmployeeUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPermissionEmployeeCreateWithoutUserInput, NotificationPermissionEmployeeUncheckedCreateWithoutUserInput>
    where?: NotificationPermissionEmployeeWhereInput
  }

  export type NotificationPermissionEmployeeUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationPermissionEmployeeWhereInput
    data: XOR<NotificationPermissionEmployeeUpdateWithoutUserInput, NotificationPermissionEmployeeUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPermissionEmployeeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnProject?: BoolFieldUpdateOperationsInput | boolean
    assignNewProject?: BoolFieldUpdateOperationsInput | boolean
    projectPublish?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionEmployeeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnProject?: BoolFieldUpdateOperationsInput | boolean
    assignNewProject?: BoolFieldUpdateOperationsInput | boolean
    projectPublish?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionManagerUpsertWithoutUserInput = {
    update: XOR<NotificationPermissionManagerUpdateWithoutUserInput, NotificationPermissionManagerUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPermissionManagerCreateWithoutUserInput, NotificationPermissionManagerUncheckedCreateWithoutUserInput>
    where?: NotificationPermissionManagerWhereInput
  }

  export type NotificationPermissionManagerUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationPermissionManagerWhereInput
    data: XOR<NotificationPermissionManagerUpdateWithoutUserInput, NotificationPermissionManagerUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPermissionManagerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileImportByEmployees?: BoolFieldUpdateOperationsInput | boolean
    weeklySummary?: BoolFieldUpdateOperationsInput | boolean
    createNewProject?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionManagerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileImportByEmployees?: BoolFieldUpdateOperationsInput | boolean
    weeklySummary?: BoolFieldUpdateOperationsInput | boolean
    createNewProject?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionClientUpsertWithoutUserInput = {
    update: XOR<NotificationPermissionClientUpdateWithoutUserInput, NotificationPermissionClientUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPermissionClientCreateWithoutUserInput, NotificationPermissionClientUncheckedCreateWithoutUserInput>
    where?: NotificationPermissionClientWhereInput
  }

  export type NotificationPermissionClientUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationPermissionClientWhereInput
    data: XOR<NotificationPermissionClientUpdateWithoutUserInput, NotificationPermissionClientUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPermissionClientUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    onProjectApproval?: BoolFieldUpdateOperationsInput | boolean
    onProjectRejection?: BoolFieldUpdateOperationsInput | boolean
    fileImportByEmployees?: BoolFieldUpdateOperationsInput | boolean
    weeklySummary?: BoolFieldUpdateOperationsInput | boolean
    storageLimit?: BoolFieldUpdateOperationsInput | boolean
    billPayment?: BoolFieldUpdateOperationsInput | boolean
    overdueProject?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionClientUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    onProjectApproval?: BoolFieldUpdateOperationsInput | boolean
    onProjectRejection?: BoolFieldUpdateOperationsInput | boolean
    fileImportByEmployees?: BoolFieldUpdateOperationsInput | boolean
    weeklySummary?: BoolFieldUpdateOperationsInput | boolean
    storageLimit?: BoolFieldUpdateOperationsInput | boolean
    billPayment?: BoolFieldUpdateOperationsInput | boolean
    overdueProject?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionSupporterUpsertWithoutUserInput = {
    update: XOR<NotificationPermissionSupporterUpdateWithoutUserInput, NotificationPermissionSupporterUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPermissionSupporterCreateWithoutUserInput, NotificationPermissionSupporterUncheckedCreateWithoutUserInput>
    where?: NotificationPermissionSupporterWhereInput
  }

  export type NotificationPermissionSupporterUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationPermissionSupporterWhereInput
    data: XOR<NotificationPermissionSupporterUpdateWithoutUserInput, NotificationPermissionSupporterUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPermissionSupporterUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignNewProject?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionSupporterUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignNewProject?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionAdminUpsertWithoutUserInput = {
    update: XOR<NotificationPermissionAdminUpdateWithoutUserInput, NotificationPermissionAdminUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPermissionAdminCreateWithoutUserInput, NotificationPermissionAdminUncheckedCreateWithoutUserInput>
    where?: NotificationPermissionAdminWhereInput
  }

  export type NotificationPermissionAdminUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationPermissionAdminWhereInput
    data: XOR<NotificationPermissionAdminUpdateWithoutUserInput, NotificationPermissionAdminUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPermissionAdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageLimit?: BoolFieldUpdateOperationsInput | boolean
    receivedPayment?: BoolFieldUpdateOperationsInput | boolean
    createClient?: BoolFieldUpdateOperationsInput | boolean
    createTicket?: BoolFieldUpdateOperationsInput | boolean
    paymentCycleChange?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPermissionAdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageLimit?: BoolFieldUpdateOperationsInput | boolean
    receivedPayment?: BoolFieldUpdateOperationsInput | boolean
    createClient?: BoolFieldUpdateOperationsInput | boolean
    createTicket?: BoolFieldUpdateOperationsInput | boolean
    paymentCycleChange?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationProvisionUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationProvisionWhereUniqueInput
    update: XOR<NotificationProvisionUpdateWithoutUserInput, NotificationProvisionUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationProvisionCreateWithoutUserInput, NotificationProvisionUncheckedCreateWithoutUserInput>
  }

  export type NotificationProvisionUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationProvisionWhereUniqueInput
    data: XOR<NotificationProvisionUpdateWithoutUserInput, NotificationProvisionUncheckedUpdateWithoutUserInput>
  }

  export type NotificationProvisionUpdateManyWithWhereWithoutUserInput = {
    where: NotificationProvisionScalarWhereInput
    data: XOR<NotificationProvisionUpdateManyMutationInput, NotificationProvisionUncheckedUpdateManyWithoutUserInput>
  }

  export type OtpVerificationUpsertWithoutUserInput = {
    update: XOR<OtpVerificationUpdateWithoutUserInput, OtpVerificationUncheckedUpdateWithoutUserInput>
    create: XOR<OtpVerificationCreateWithoutUserInput, OtpVerificationUncheckedCreateWithoutUserInput>
    where?: OtpVerificationWhereInput
  }

  export type OtpVerificationUpdateToOneWithWhereWithoutUserInput = {
    where?: OtpVerificationWhereInput
    data: XOR<OtpVerificationUpdateWithoutUserInput, OtpVerificationUncheckedUpdateWithoutUserInput>
  }

  export type OtpVerificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpVerificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    transactionId?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type ActivityUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
  }

  export type ActivityUpdateManyWithWhereWithoutUserInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutUserInput>
  }

  export type ClientCreateWithoutTagsInput = {
    id?: string
    email: string
    contactPersonName?: string | null
    clientLogo?: string | null
    favicon?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    footerText?: string | null
    supportMail?: string | null
    subdomain?: string | null
    serverLocation?: string | null
    category?: $Enums.IndustryCategory
    onboarding?: boolean
    welcomeDashboard?: boolean
    chartList?: ClientCreatechartListInput | string[]
    storage?: string | null
    threshold?: number | null
    archiveAfter?: number | null
    userWarning?: boolean
    adminNote?: string | null
    trialPeriod?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientInput
    referredPersons?: ReferredPersonCreateNestedManyWithoutClientInput
    tickets?: TicketCreateNestedManyWithoutClientInput
    programs?: ProgramCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutTagsInput = {
    id?: string
    userId: string
    email: string
    contactPersonName?: string | null
    clientLogo?: string | null
    favicon?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    footerText?: string | null
    supportMail?: string | null
    subdomain?: string | null
    serverLocation?: string | null
    category?: $Enums.IndustryCategory
    onboarding?: boolean
    welcomeDashboard?: boolean
    chartList?: ClientCreatechartListInput | string[]
    storage?: string | null
    threshold?: number | null
    archiveAfter?: number | null
    userWarning?: boolean
    adminNote?: string | null
    trialPeriod?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referredPersons?: ReferredPersonUncheckedCreateNestedManyWithoutClientInput
    tickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    programs?: ProgramUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutTagsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutTagsInput, ClientUncheckedCreateWithoutTagsInput>
  }

  export type ClientUpsertWithoutTagsInput = {
    update: XOR<ClientUpdateWithoutTagsInput, ClientUncheckedUpdateWithoutTagsInput>
    create: XOR<ClientCreateWithoutTagsInput, ClientUncheckedCreateWithoutTagsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutTagsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutTagsInput, ClientUncheckedUpdateWithoutTagsInput>
  }

  export type ClientUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactPersonName?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    supportMail?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    serverLocation?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumIndustryCategoryFieldUpdateOperationsInput | $Enums.IndustryCategory
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    welcomeDashboard?: BoolFieldUpdateOperationsInput | boolean
    chartList?: ClientUpdatechartListInput | string[]
    storage?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: NullableIntFieldUpdateOperationsInput | number | null
    archiveAfter?: NullableIntFieldUpdateOperationsInput | number | null
    userWarning?: BoolFieldUpdateOperationsInput | boolean
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    trialPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientNestedInput
    referredPersons?: ReferredPersonUpdateManyWithoutClientNestedInput
    tickets?: TicketUpdateManyWithoutClientNestedInput
    programs?: ProgramUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactPersonName?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    supportMail?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    serverLocation?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumIndustryCategoryFieldUpdateOperationsInput | $Enums.IndustryCategory
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    welcomeDashboard?: BoolFieldUpdateOperationsInput | boolean
    chartList?: ClientUpdatechartListInput | string[]
    storage?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: NullableIntFieldUpdateOperationsInput | number | null
    archiveAfter?: NullableIntFieldUpdateOperationsInput | number | null
    userWarning?: BoolFieldUpdateOperationsInput | boolean
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    trialPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referredPersons?: ReferredPersonUncheckedUpdateManyWithoutClientNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateWithoutReferredPersonsInput = {
    id?: string
    email: string
    contactPersonName?: string | null
    clientLogo?: string | null
    favicon?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    footerText?: string | null
    supportMail?: string | null
    subdomain?: string | null
    serverLocation?: string | null
    category?: $Enums.IndustryCategory
    onboarding?: boolean
    welcomeDashboard?: boolean
    chartList?: ClientCreatechartListInput | string[]
    storage?: string | null
    threshold?: number | null
    archiveAfter?: number | null
    userWarning?: boolean
    adminNote?: string | null
    trialPeriod?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientInput
    tickets?: TicketCreateNestedManyWithoutClientInput
    programs?: ProgramCreateNestedManyWithoutClientInput
    tags?: TagCreateNestedOneWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutReferredPersonsInput = {
    id?: string
    userId: string
    email: string
    contactPersonName?: string | null
    clientLogo?: string | null
    favicon?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    footerText?: string | null
    supportMail?: string | null
    subdomain?: string | null
    serverLocation?: string | null
    category?: $Enums.IndustryCategory
    onboarding?: boolean
    welcomeDashboard?: boolean
    chartList?: ClientCreatechartListInput | string[]
    storage?: string | null
    threshold?: number | null
    archiveAfter?: number | null
    userWarning?: boolean
    adminNote?: string | null
    trialPeriod?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutClientInput
    programs?: ProgramUncheckedCreateNestedManyWithoutClientInput
    tags?: TagUncheckedCreateNestedOneWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutReferredPersonsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutReferredPersonsInput, ClientUncheckedCreateWithoutReferredPersonsInput>
  }

  export type ClientUpsertWithoutReferredPersonsInput = {
    update: XOR<ClientUpdateWithoutReferredPersonsInput, ClientUncheckedUpdateWithoutReferredPersonsInput>
    create: XOR<ClientCreateWithoutReferredPersonsInput, ClientUncheckedCreateWithoutReferredPersonsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutReferredPersonsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutReferredPersonsInput, ClientUncheckedUpdateWithoutReferredPersonsInput>
  }

  export type ClientUpdateWithoutReferredPersonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactPersonName?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    supportMail?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    serverLocation?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumIndustryCategoryFieldUpdateOperationsInput | $Enums.IndustryCategory
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    welcomeDashboard?: BoolFieldUpdateOperationsInput | boolean
    chartList?: ClientUpdatechartListInput | string[]
    storage?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: NullableIntFieldUpdateOperationsInput | number | null
    archiveAfter?: NullableIntFieldUpdateOperationsInput | number | null
    userWarning?: BoolFieldUpdateOperationsInput | boolean
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    trialPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientNestedInput
    tickets?: TicketUpdateManyWithoutClientNestedInput
    programs?: ProgramUpdateManyWithoutClientNestedInput
    tags?: TagUpdateOneWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutReferredPersonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactPersonName?: NullableStringFieldUpdateOperationsInput | string | null
    clientLogo?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    supportMail?: NullableStringFieldUpdateOperationsInput | string | null
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    serverLocation?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumIndustryCategoryFieldUpdateOperationsInput | $Enums.IndustryCategory
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    welcomeDashboard?: BoolFieldUpdateOperationsInput | boolean
    chartList?: ClientUpdatechartListInput | string[]
    storage?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: NullableIntFieldUpdateOperationsInput | number | null
    archiveAfter?: NullableIntFieldUpdateOperationsInput | number | null
    userWarning?: BoolFieldUpdateOperationsInput | boolean
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    trialPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutClientNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutClientNestedInput
    tags?: TagUncheckedUpdateOneWithoutClientNestedInput
  }

  export type ProjectCreateWithoutRequestsToAddProjectMemberInput = {
    id?: string
    name: string
    uploadbeforeday: string
    uploadCycle: $Enums.ProjectCycle
    description: string
    dataReceivedTime?: string | null
    beforeSubmitData?: number | null
    weakuploadData?: ProjectCreateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectCreatemonthlyuploadDataInput | string[]
    status?: $Enums.ProjectStatus
    priority: $Enums.Priority
    deadline: Date | string
    startDate?: Date | string | null
    progress?: number | null
    chartList?: ProjectCreatechartListInput | string[]
    estimatedCompletedDate?: Date | string | null
    currentRate?: string | null
    budget?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    latitude?: number | null
    longitude?: number | null
    program: ProgramCreateNestedOneWithoutProjectsInput
    manager: ManagerCreateNestedOneWithoutProjectsInput
    projectEmployees?: ProjectEmployeeCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    activities?: ActivityCreateNestedManyWithoutProjectInput
    reviews?: ReviewCreateNestedManyWithoutProjectInput
    submitted?: SubmittedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutRequestsToAddProjectMemberInput = {
    id?: string
    programId: string
    name: string
    uploadbeforeday: string
    uploadCycle: $Enums.ProjectCycle
    description: string
    dataReceivedTime?: string | null
    beforeSubmitData?: number | null
    weakuploadData?: ProjectCreateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectCreatemonthlyuploadDataInput | string[]
    status?: $Enums.ProjectStatus
    priority: $Enums.Priority
    deadline: Date | string
    managerId: string
    startDate?: Date | string | null
    progress?: number | null
    chartList?: ProjectCreatechartListInput | string[]
    estimatedCompletedDate?: Date | string | null
    currentRate?: string | null
    budget?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    latitude?: number | null
    longitude?: number | null
    projectEmployees?: ProjectEmployeeUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    activities?: ActivityUncheckedCreateNestedManyWithoutProjectInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProjectInput
    submitted?: SubmittedUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutRequestsToAddProjectMemberInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutRequestsToAddProjectMemberInput, ProjectUncheckedCreateWithoutRequestsToAddProjectMemberInput>
  }

  export type ManagerCreateWithoutRequestsToAddProjectMemberInput = {
    id?: string
    skills?: ManagerCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    joinedDate: string
    user: UserCreateNestedOneWithoutManagerInput
    projects?: ProjectCreateNestedManyWithoutManagerInput
  }

  export type ManagerUncheckedCreateWithoutRequestsToAddProjectMemberInput = {
    id?: string
    userId: string
    skills?: ManagerCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    joinedDate: string
    projects?: ProjectUncheckedCreateNestedManyWithoutManagerInput
  }

  export type ManagerCreateOrConnectWithoutRequestsToAddProjectMemberInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerCreateWithoutRequestsToAddProjectMemberInput, ManagerUncheckedCreateWithoutRequestsToAddProjectMemberInput>
  }

  export type ProjectUpsertWithoutRequestsToAddProjectMemberInput = {
    update: XOR<ProjectUpdateWithoutRequestsToAddProjectMemberInput, ProjectUncheckedUpdateWithoutRequestsToAddProjectMemberInput>
    create: XOR<ProjectCreateWithoutRequestsToAddProjectMemberInput, ProjectUncheckedCreateWithoutRequestsToAddProjectMemberInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutRequestsToAddProjectMemberInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutRequestsToAddProjectMemberInput, ProjectUncheckedUpdateWithoutRequestsToAddProjectMemberInput>
  }

  export type ProjectUpdateWithoutRequestsToAddProjectMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uploadbeforeday?: StringFieldUpdateOperationsInput | string
    uploadCycle?: EnumProjectCycleFieldUpdateOperationsInput | $Enums.ProjectCycle
    description?: StringFieldUpdateOperationsInput | string
    dataReceivedTime?: NullableStringFieldUpdateOperationsInput | string | null
    beforeSubmitData?: NullableIntFieldUpdateOperationsInput | number | null
    weakuploadData?: ProjectUpdateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectUpdatemonthlyuploadDataInput | string[]
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    chartList?: ProjectUpdatechartListInput | string[]
    estimatedCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentRate?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    program?: ProgramUpdateOneRequiredWithoutProjectsNestedInput
    manager?: ManagerUpdateOneRequiredWithoutProjectsNestedInput
    projectEmployees?: ProjectEmployeeUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    reviews?: ReviewUpdateManyWithoutProjectNestedInput
    submitted?: SubmittedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutRequestsToAddProjectMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uploadbeforeday?: StringFieldUpdateOperationsInput | string
    uploadCycle?: EnumProjectCycleFieldUpdateOperationsInput | $Enums.ProjectCycle
    description?: StringFieldUpdateOperationsInput | string
    dataReceivedTime?: NullableStringFieldUpdateOperationsInput | string | null
    beforeSubmitData?: NullableIntFieldUpdateOperationsInput | number | null
    weakuploadData?: ProjectUpdateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectUpdatemonthlyuploadDataInput | string[]
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    chartList?: ProjectUpdatechartListInput | string[]
    estimatedCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentRate?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    projectEmployees?: ProjectEmployeeUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProjectNestedInput
    submitted?: SubmittedUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ManagerUpsertWithoutRequestsToAddProjectMemberInput = {
    update: XOR<ManagerUpdateWithoutRequestsToAddProjectMemberInput, ManagerUncheckedUpdateWithoutRequestsToAddProjectMemberInput>
    create: XOR<ManagerCreateWithoutRequestsToAddProjectMemberInput, ManagerUncheckedCreateWithoutRequestsToAddProjectMemberInput>
    where?: ManagerWhereInput
  }

  export type ManagerUpdateToOneWithWhereWithoutRequestsToAddProjectMemberInput = {
    where?: ManagerWhereInput
    data: XOR<ManagerUpdateWithoutRequestsToAddProjectMemberInput, ManagerUncheckedUpdateWithoutRequestsToAddProjectMemberInput>
  }

  export type ManagerUpdateWithoutRequestsToAddProjectMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: ManagerUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    joinedDate?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutManagerNestedInput
    projects?: ProjectUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateWithoutRequestsToAddProjectMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    skills?: ManagerUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    joinedDate?: StringFieldUpdateOperationsInput | string
    projects?: ProjectUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type UserCreateWithoutViewerInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientCreateNestedOneWithoutUserInput
    manager?: ManagerCreateNestedOneWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    supporter?: SupporterCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationCreateNestedOneWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutViewerInput = {
    id?: string
    email: string
    phoneNumber: string
    password: string
    name: string
    role?: $Enums.Role
    profileImage?: string | null
    language?: $Enums.Language
    timezone?: Date | string | null
    verification2FA?: boolean
    status?: boolean
    lastActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userStatus?: $Enums.UserStatus
    client?: ClientUncheckedCreateNestedOneWithoutUserInput
    manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    supporter?: SupporterUncheckedCreateNestedOneWithoutUserInput
    superAdmin?: SuperAdminUncheckedCreateNestedOneWithoutUserInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedCreateNestedOneWithoutUserInput
    notificationManager?: NotificationPermissionManagerUncheckedCreateNestedOneWithoutUserInput
    notificationClient?: NotificationPermissionClientUncheckedCreateNestedOneWithoutUserInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedCreateNestedOneWithoutUserInput
    notificationAdmin?: NotificationPermissionAdminUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationProvisionUncheckedCreateNestedManyWithoutUserInput
    otpVerification?: OtpVerificationUncheckedCreateNestedOneWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutViewerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutViewerInput, UserUncheckedCreateWithoutViewerInput>
  }

  export type UserUpsertWithoutViewerInput = {
    update: XOR<UserUpdateWithoutViewerInput, UserUncheckedUpdateWithoutViewerInput>
    create: XOR<UserCreateWithoutViewerInput, UserUncheckedCreateWithoutViewerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutViewerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutViewerInput, UserUncheckedUpdateWithoutViewerInput>
  }

  export type UserUpdateWithoutViewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUpdateOneWithoutUserNestedInput
    manager?: ManagerUpdateOneWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    supporter?: SupporterUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUpdateOneWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutViewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumLanguageFieldUpdateOperationsInput | $Enums.Language
    timezone?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verification2FA?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    client?: ClientUncheckedUpdateOneWithoutUserNestedInput
    manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    supporter?: SupporterUncheckedUpdateOneWithoutUserNestedInput
    superAdmin?: SuperAdminUncheckedUpdateOneWithoutUserNestedInput
    notificationEmployee?: NotificationPermissionEmployeeUncheckedUpdateOneWithoutUserNestedInput
    notificationManager?: NotificationPermissionManagerUncheckedUpdateOneWithoutUserNestedInput
    notificationClient?: NotificationPermissionClientUncheckedUpdateOneWithoutUserNestedInput
    notificationSupporter?: NotificationPermissionSupporterUncheckedUpdateOneWithoutUserNestedInput
    notificationAdmin?: NotificationPermissionAdminUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationProvisionUncheckedUpdateManyWithoutUserNestedInput
    otpVerification?: OtpVerificationUncheckedUpdateOneWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReferredPersonCreateManyClientInput = {
    id?: string
    name: string
    email?: string | null
    phoneNumber?: number | null
    aboutThere?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateManyClientInput = {
    id?: string
    supporterIds?: TicketCreatesupporterIdsInput | string[]
    adminIds?: TicketCreateadminIdsInput | string[]
    companyName?: string | null
    subject: string
    status?: $Enums.TicketStatus
    priority: $Enums.Priority
    issue: string
    adminNote?: string | null
    attachFile?: string | null
    issueType: $Enums.IssueType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramCreateManyClientInput = {
    id?: string
    programName: string
    datetime: string
    programDescription: string
    priority: string
    deadline: string
    progress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferredPersonUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    aboutThere?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferredPersonUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    aboutThere?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferredPersonUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableIntFieldUpdateOperationsInput | number | null
    aboutThere?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    supporterIds?: TicketUpdatesupporterIdsInput | string[]
    adminIds?: TicketUpdateadminIdsInput | string[]
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    issue?: StringFieldUpdateOperationsInput | string
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    attachFile?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    supporterIds?: TicketUpdatesupporterIdsInput | string[]
    adminIds?: TicketUpdateadminIdsInput | string[]
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    issue?: StringFieldUpdateOperationsInput | string
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    attachFile?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    supporterIds?: TicketUpdatesupporterIdsInput | string[]
    adminIds?: TicketUpdateadminIdsInput | string[]
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    issue?: StringFieldUpdateOperationsInput | string
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    attachFile?: NullableStringFieldUpdateOperationsInput | string | null
    issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    programName?: StringFieldUpdateOperationsInput | string
    datetime?: StringFieldUpdateOperationsInput | string
    programDescription?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    deadline?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    programName?: StringFieldUpdateOperationsInput | string
    datetime?: StringFieldUpdateOperationsInput | string
    programDescription?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    deadline?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    programName?: StringFieldUpdateOperationsInput | string
    datetime?: StringFieldUpdateOperationsInput | string
    programDescription?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    deadline?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectEmployeeCreateManyEmployeeInput = {
    id?: string
    projectId: string
    assignedAt?: Date | string
  }

  export type SubmittedCreateManyEmployeeInput = {
    id?: string
    information: string
    submission: string
    status?: $Enums.SubmittedStatus
    projectId: string
    sheetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectEmployeeUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutProjectEmployeesNestedInput
  }

  export type ProjectEmployeeUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectEmployeeUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmittedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    submission?: StringFieldUpdateOperationsInput | string
    status?: EnumSubmittedStatusFieldUpdateOperationsInput | $Enums.SubmittedStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSubmittedNestedInput
    sheet?: SheetUpdateOneRequiredWithoutSubmittedNestedInput
    submissionReturn?: SubmissionReturnUpdateOneWithoutSubmittedNestedInput
  }

  export type SubmittedUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    submission?: StringFieldUpdateOperationsInput | string
    status?: EnumSubmittedStatusFieldUpdateOperationsInput | $Enums.SubmittedStatus
    projectId?: StringFieldUpdateOperationsInput | string
    sheetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionReturn?: SubmissionReturnUncheckedUpdateOneWithoutSubmittedNestedInput
  }

  export type SubmittedUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    submission?: StringFieldUpdateOperationsInput | string
    status?: EnumSubmittedStatusFieldUpdateOperationsInput | $Enums.SubmittedStatus
    projectId?: StringFieldUpdateOperationsInput | string
    sheetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateManyManagerInput = {
    id?: string
    programId: string
    name: string
    uploadbeforeday: string
    uploadCycle: $Enums.ProjectCycle
    description: string
    dataReceivedTime?: string | null
    beforeSubmitData?: number | null
    weakuploadData?: ProjectCreateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectCreatemonthlyuploadDataInput | string[]
    status?: $Enums.ProjectStatus
    priority: $Enums.Priority
    deadline: Date | string
    startDate?: Date | string | null
    progress?: number | null
    chartList?: ProjectCreatechartListInput | string[]
    estimatedCompletedDate?: Date | string | null
    currentRate?: string | null
    budget?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    latitude?: number | null
    longitude?: number | null
  }

  export type RequestToAddProjectMemberCreateManyManagerInput = {
    id?: string
    clientId?: string | null
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uploadbeforeday?: StringFieldUpdateOperationsInput | string
    uploadCycle?: EnumProjectCycleFieldUpdateOperationsInput | $Enums.ProjectCycle
    description?: StringFieldUpdateOperationsInput | string
    dataReceivedTime?: NullableStringFieldUpdateOperationsInput | string | null
    beforeSubmitData?: NullableIntFieldUpdateOperationsInput | number | null
    weakuploadData?: ProjectUpdateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectUpdatemonthlyuploadDataInput | string[]
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    chartList?: ProjectUpdatechartListInput | string[]
    estimatedCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentRate?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    program?: ProgramUpdateOneRequiredWithoutProjectsNestedInput
    projectEmployees?: ProjectEmployeeUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    reviews?: ReviewUpdateManyWithoutProjectNestedInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUpdateManyWithoutProjectNestedInput
    submitted?: SubmittedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uploadbeforeday?: StringFieldUpdateOperationsInput | string
    uploadCycle?: EnumProjectCycleFieldUpdateOperationsInput | $Enums.ProjectCycle
    description?: StringFieldUpdateOperationsInput | string
    dataReceivedTime?: NullableStringFieldUpdateOperationsInput | string | null
    beforeSubmitData?: NullableIntFieldUpdateOperationsInput | number | null
    weakuploadData?: ProjectUpdateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectUpdatemonthlyuploadDataInput | string[]
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    chartList?: ProjectUpdatechartListInput | string[]
    estimatedCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentRate?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    projectEmployees?: ProjectEmployeeUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProjectNestedInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    submitted?: SubmittedUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uploadbeforeday?: StringFieldUpdateOperationsInput | string
    uploadCycle?: EnumProjectCycleFieldUpdateOperationsInput | $Enums.ProjectCycle
    description?: StringFieldUpdateOperationsInput | string
    dataReceivedTime?: NullableStringFieldUpdateOperationsInput | string | null
    beforeSubmitData?: NullableIntFieldUpdateOperationsInput | number | null
    weakuploadData?: ProjectUpdateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectUpdatemonthlyuploadDataInput | string[]
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    chartList?: ProjectUpdatechartListInput | string[]
    estimatedCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentRate?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RequestToAddProjectMemberUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutRequestsToAddProjectMemberNestedInput
  }

  export type RequestToAddProjectMemberUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestToAddProjectMemberUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationProvisionCreateManyNotificationInput = {
    userId: string
  }

  export type NotificationProvisionUpdateWithoutNotificationInput = {
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationProvisionUncheckedUpdateWithoutNotificationInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationProvisionUncheckedUpdateManyWithoutNotificationInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCreateManyProgramInput = {
    id?: string
    name: string
    uploadbeforeday: string
    uploadCycle: $Enums.ProjectCycle
    description: string
    dataReceivedTime?: string | null
    beforeSubmitData?: number | null
    weakuploadData?: ProjectCreateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectCreatemonthlyuploadDataInput | string[]
    status?: $Enums.ProjectStatus
    priority: $Enums.Priority
    deadline: Date | string
    managerId: string
    startDate?: Date | string | null
    progress?: number | null
    chartList?: ProjectCreatechartListInput | string[]
    estimatedCompletedDate?: Date | string | null
    currentRate?: string | null
    budget?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    latitude?: number | null
    longitude?: number | null
  }

  export type ProjectUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uploadbeforeday?: StringFieldUpdateOperationsInput | string
    uploadCycle?: EnumProjectCycleFieldUpdateOperationsInput | $Enums.ProjectCycle
    description?: StringFieldUpdateOperationsInput | string
    dataReceivedTime?: NullableStringFieldUpdateOperationsInput | string | null
    beforeSubmitData?: NullableIntFieldUpdateOperationsInput | number | null
    weakuploadData?: ProjectUpdateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectUpdatemonthlyuploadDataInput | string[]
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    chartList?: ProjectUpdatechartListInput | string[]
    estimatedCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentRate?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    manager?: ManagerUpdateOneRequiredWithoutProjectsNestedInput
    projectEmployees?: ProjectEmployeeUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    activities?: ActivityUpdateManyWithoutProjectNestedInput
    reviews?: ReviewUpdateManyWithoutProjectNestedInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUpdateManyWithoutProjectNestedInput
    submitted?: SubmittedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uploadbeforeday?: StringFieldUpdateOperationsInput | string
    uploadCycle?: EnumProjectCycleFieldUpdateOperationsInput | $Enums.ProjectCycle
    description?: StringFieldUpdateOperationsInput | string
    dataReceivedTime?: NullableStringFieldUpdateOperationsInput | string | null
    beforeSubmitData?: NullableIntFieldUpdateOperationsInput | number | null
    weakuploadData?: ProjectUpdateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectUpdatemonthlyuploadDataInput | string[]
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    chartList?: ProjectUpdatechartListInput | string[]
    estimatedCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentRate?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    projectEmployees?: ProjectEmployeeUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutProjectNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProjectNestedInput
    requestsToAddProjectMember?: RequestToAddProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    submitted?: SubmittedUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uploadbeforeday?: StringFieldUpdateOperationsInput | string
    uploadCycle?: EnumProjectCycleFieldUpdateOperationsInput | $Enums.ProjectCycle
    description?: StringFieldUpdateOperationsInput | string
    dataReceivedTime?: NullableStringFieldUpdateOperationsInput | string | null
    beforeSubmitData?: NullableIntFieldUpdateOperationsInput | number | null
    weakuploadData?: ProjectUpdateweakuploadDataInput | string[]
    monthlyuploadData?: ProjectUpdatemonthlyuploadDataInput | string[]
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    managerId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    chartList?: ProjectUpdatechartListInput | string[]
    estimatedCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentRate?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ProjectEmployeeCreateManyProjectInput = {
    id?: string
    employeeId: string
    assignedAt?: Date | string
  }

  export type TaskCreateManyProjectInput = {
    id?: string
    status?: $Enums.TaskStatus | null
    name: string
    progress?: number | null
    dueDate?: string | null
    assignedTo: string
    assigneeType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateManyProjectInput = {
    id?: string
    userId: string
    timestamp?: Date | string
    description: string
    ipAddress?: string | null
    actionType?: $Enums.ActivityActionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyProjectInput = {
    id?: string
    taskAssignId?: string | null
    status: $Enums.ProjectStatus
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestToAddProjectMemberCreateManyProjectInput = {
    id?: string
    clientId?: string | null
    managerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubmittedCreateManyProjectInput = {
    id?: string
    information: string
    submission: string
    status?: $Enums.SubmittedStatus
    employeeId: string
    sheetId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectEmployeeUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutProjectEmployeesNestedInput
  }

  export type ProjectEmployeeUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectEmployeeUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus | null
    name?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    assigneeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus | null
    name?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    assigneeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus | null
    name?: StringFieldUpdateOperationsInput | string
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    dueDate?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: StringFieldUpdateOperationsInput | string
    assigneeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: EnumActivityActionTypeFieldUpdateOperationsInput | $Enums.ActivityActionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: EnumActivityActionTypeFieldUpdateOperationsInput | $Enums.ActivityActionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: EnumActivityActionTypeFieldUpdateOperationsInput | $Enums.ActivityActionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskAssignId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskAssignId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskAssignId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestToAddProjectMemberUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: ManagerUpdateOneRequiredWithoutRequestsToAddProjectMemberNestedInput
  }

  export type RequestToAddProjectMemberUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestToAddProjectMemberUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmittedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    submission?: StringFieldUpdateOperationsInput | string
    status?: EnumSubmittedStatusFieldUpdateOperationsInput | $Enums.SubmittedStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutSubmittedNestedInput
    sheet?: SheetUpdateOneRequiredWithoutSubmittedNestedInput
    submissionReturn?: SubmissionReturnUpdateOneWithoutSubmittedNestedInput
  }

  export type SubmittedUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    submission?: StringFieldUpdateOperationsInput | string
    status?: EnumSubmittedStatusFieldUpdateOperationsInput | $Enums.SubmittedStatus
    employeeId?: StringFieldUpdateOperationsInput | string
    sheetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionReturn?: SubmissionReturnUncheckedUpdateOneWithoutSubmittedNestedInput
  }

  export type SubmittedUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    submission?: StringFieldUpdateOperationsInput | string
    status?: EnumSubmittedStatusFieldUpdateOperationsInput | $Enums.SubmittedStatus
    employeeId?: StringFieldUpdateOperationsInput | string
    sheetId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmittedCreateManySheetInput = {
    id?: string
    information: string
    submission: string
    status?: $Enums.SubmittedStatus
    employeeId: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubmittedUpdateWithoutSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    submission?: StringFieldUpdateOperationsInput | string
    status?: EnumSubmittedStatusFieldUpdateOperationsInput | $Enums.SubmittedStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutSubmittedNestedInput
    project?: ProjectUpdateOneRequiredWithoutSubmittedNestedInput
    submissionReturn?: SubmissionReturnUpdateOneWithoutSubmittedNestedInput
  }

  export type SubmittedUncheckedUpdateWithoutSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    submission?: StringFieldUpdateOperationsInput | string
    status?: EnumSubmittedStatusFieldUpdateOperationsInput | $Enums.SubmittedStatus
    employeeId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionReturn?: SubmissionReturnUncheckedUpdateOneWithoutSubmittedNestedInput
  }

  export type SubmittedUncheckedUpdateManyWithoutSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    information?: StringFieldUpdateOperationsInput | string
    submission?: StringFieldUpdateOperationsInput | string
    status?: EnumSubmittedStatusFieldUpdateOperationsInput | $Enums.SubmittedStatus
    employeeId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationProvisionCreateManyUserInput = {
    notificationId: string
  }

  export type PaymentCreateManyUserInput = {
    id?: string
    amount: number
    transactionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateManyUserInput = {
    id?: string
    timestamp?: Date | string
    description: string
    projectId: string
    ipAddress?: string | null
    actionType?: $Enums.ActivityActionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationProvisionUpdateWithoutUserInput = {
    notification?: NotificationUpdateOneRequiredWithoutProvisionsNestedInput
  }

  export type NotificationProvisionUncheckedUpdateWithoutUserInput = {
    notificationId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationProvisionUncheckedUpdateManyWithoutUserInput = {
    notificationId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transactionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transactionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transactionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: EnumActivityActionTypeFieldUpdateOperationsInput | $Enums.ActivityActionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: EnumActivityActionTypeFieldUpdateOperationsInput | $Enums.ActivityActionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: EnumActivityActionTypeFieldUpdateOperationsInput | $Enums.ActivityActionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}